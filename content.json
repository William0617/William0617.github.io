{"meta":{"title":"William's Blog","subtitle":"SDET (Software Development Engineer in Test)","description":"Keep moving. Don't settle.","author":"William Sun","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-03-02T17:33:16.000Z","updated":"2018-11-18T20:55:36.697Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-11-18T18:31:43.000Z","updated":"2018-11-18T18:31:55.033Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-02T17:33:16.000Z","updated":"2018-11-18T20:55:38.334Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"海外计算机系留学生2018秋招总结-已拿某AI独角兽offer","slug":"海外计算机系留学生2018秋招总结-已拿某AI独角兽offer","date":"2018-11-19T23:04:44.000Z","updated":"2018-11-19T23:07:28.187Z","comments":true,"path":"2018/11/19/海外计算机系留学生2018秋招总结-已拿某AI独角兽offer/","link":"","permalink":"http://yoursite.com/2018/11/19/海外计算机系留学生2018秋招总结-已拿某AI独角兽offer/","excerpt":"","text":"我本次秋招的基本需求如下： 目标地点：上海； 目标公司：较大的互联网公司； 目标岗位：Java后台开发； 目标新手：年薪30W以上；从六月份开始准备秋招，一直到十一月份拿到满意的offer结束。前前后后一共历时五个半月，下面就每个月的状态和进展进行总结。 六月五月份暑假回国，6月份回家开始准备秋招。开始的时候看到网上的攻略，于是买了书看了一个月基础。这份书单主要是依据Java后台开发工程师秋招攻略2018Fall中列出的材料进行复习。先看了Java基础，然后在网上看了一些Java培训班的视频，记了两本笔记。这样做的结果就是：卵用没有。基础太过庞杂，即便是大佬，没有时间实践，就变成了纯纯的死记硬背。看一遍绝对会忘记，即便是记了笔记。于是在思考后，七月份便改变了战术。 七月战术调整后，了解到国内刷题都用牛客网，于是就在牛客网开始做题。既然做题，就跟着牛客网的顺序来吧，他有个java工程师学习路线，先做的是Java基础的选择题，然后是算法与数据结构的选择题。前前后后做了1580道，后来我觉得这些题在笔试中没有什么用。后来月底的时候，买了牛客网的《BAT算法题精讲》课程，跟着老师一步一步复习和做算法题，感觉终于上了正轨。这个月期间，京东和Thoughtworks，阿里巴巴和拼多多开启了秋招，虽然没有做完题，但是还是投递了简历。 八月八月继续跟着网课做题，所有题都是自己憋出来，不看答案，十分耗时。八月上旬回到美国，基本没怎么学习。20号以后上课了，也收心了，继续做题。在这期间，收到银联，京东，中央结算中心和爱奇艺的面试邀请，都是现场面。无奈，只好错过。与此同时，也投递简历。例如，贝壳找房，携程网，美团，触宝，平安科技等等。 九月九月是真真正正学习的一个月。这个月除了把网课题做了，也在牛客网做了些剑指offer和其他的编程题，前后加一起170多道吧。另外，把牛客各个企业的java岗的面经都做了一遍，并且记录。其实要是对以上的知识完全掌握，我觉得对国内的岗位完全可以了。但是问题在于刷完后面的，肯定会忘记前面的。收到的平安科技，中汇，阿里，美的和小红书的面试。又去了趟Pittsburgh的CMU招聘会，主要是冲着京东去的，结果很恶心。至此，战线已经四个月，身心俱疲。国内的提前批小伙伴已经手握数个offer，心里很方。 十月十月开始就有些自暴自弃、破罐破摔了。主要是被国内某些公司刺激的，再加上课业压力。这个月基本没怎么准备面试题和算法题。阿里有个面试官要给我个intern，被我拒绝。然后过几天阿里给我打电话，由于时差无法接通，回电话是主机号，无法拨通。阿里无疾而终。前前后后，阿里三次面试吧。然后又面了个创业的AI公司，2次技术，1次HR面，聊的很好，顺利拿到offer。这个公司的优点是里面都是高学历和留学生，不加班，福利不错，北京上海也可以选择地点，岗位是想要的后台开发。缺点是，对于应届生第一份工作的平台很重要，创业公司平台不够；其次是薪水与我预期有小几万的差距。但是无论如何，拿到了offer，心里还是很开心的。 十一月这个月国内规模大一点的公司的秋招已经接近尾声，补招很多。刷着牛客网的论坛，看着国内的小伙伴至少都拿了5，6个offer，又羡慕又难受。下了个猎聘APP，很多猎头找到我帮我推岗位，于是拿到了3个面试。头条的补招，还有个车企的智能汽车部门的Java后台，还有个AI公司的测试开发岗。由于可恶的时差，所有的面试都是晚上，连续两天，并且两个面试连起来都是3小时以上，极其痛苦。两天苦战，终于拿到的offer，虽然是AI公司的测试开发岗，但是地点、薪水、公司规模完全符合我的预期，缺点是加班严重。但是作为一个年轻人，加几年班又算得了什么呢？这世界上哪有钱又多、不加班的好公司。若是有，也轮不到我把。至此，11月15日，持续五个半月的漫长秋招结束。 总结1. 海外留学生找工作的痛点在美国找国内的工作是真的难，非常难。绝大多数企业对留学生是不友好的，也可以说很多企业并没有考虑留学生群体。这也很好理解，我要是老板，一样的薪水，不如找几个国内985硕士，又能加班，屁事又少，招聘成本又低，沟通顺畅及时，还能来实习。所以对于留学生来说，身在国外找国内工作有很多痛点： 时差。这个最要命，很多国内HR都联系不到你，并且很多留学生在海外没有国内电话，有些HR不会打海外电话；即便打通了，在美国也是后半夜，一个学期下来就会跟我一样神经衰弱。还有就是，基本笔试都是美东早上6-7点钟，网易两次笔试都是美东凌晨2点，不得不错过了很多笔试。 距离。宣讲会，面试和沟通只能用邮件沟通。国内很多公司都是用第三方面试平台通知，如果想联系HR，那么抱歉，联系不到。另外，最气的是，很多企业把笔试当儿戏吧，宣讲会去了把笔试当抽奖，我这种老老实实投简历、做笔试的学生真的心寒。 课业压力。听说美西那边高校课没有我们这么多，并且我们还有background courses。特别坑。1年半上了13门课，都是400和500的硬课。国内的研究生找工作时，都没有课了。这跟人家比就有很大的劣势。 国内招聘很佛系。有的公司，你觉得面试的不错，他把你挂了；你答的不太行的，反而过了。与此同时，与美国注重算法相比，国内考的体系更为庞杂：算法与数据结构，数据库，语言特性，项目，Linux，计算机网络等等。 2. 秋招遇到的坑2.1 我遇到的坑*公司 京东。这是最坑的。8月份拿到上海现场面试的通知，去不了，发邮件不理我，也没有电话。然后等到9月，说有海外招聘，并且说拿到国内面试的同学可以直接优先安排面试。于是我和俩同学就兴奋地区他们的招聘地点，CMU。我们翘了课，租了车，订了住宿，然后到CMU人家说外校的人不让参加宣讲会。我们找同学又求人，终于在快散场的时候进去和京东HR搭上话了。当时他们给我们的态度是非常重视，会给我们安排远程面试。结果两个月过去了，一个屁都没有。十分失望。 打车 字节跳动（今日头条）。补招视频面试。那个面试官说话极快，听不太清；并且行为很轻浮，估计面我的时候不是在听歌就是工作，不在会议室，就在他工位，我觉得没有给我以尊重。 小红书。前期HR说给我发具体视频面试安排了，但是我没收到。毕竟应届生是弱势群体，我只能承认我的”错误“，希望人家再给次机会。到了视频面试阶段，那个面试官自称全栈工程师，给我甩了一道算法题。我很开心，当时那道题我前几天做过，还参考了牛客网一个同学的一种简单方法。我就原模原样写了上去。他就说我的代码不能跑。然后我跟他犟了几句，估计就把我挂了。 2.2 如果再准备一次，该如何准备？ 首先我会先刷题。把《剑指offer》刷的滚瓜烂熟。然后准备面经，网上前一年所有的后台开发的面经，自己做一遍，然后死记硬背！如果还有时间，在网上找个项目，自己独立把前端后台做一遍，po到github上。 搜索岗位。猎聘APP+校园招+牛客网。这些组合起来用，效果很好。 内推没用。国内内推很多都是免筛简历，我觉得我不至于简历都过不去。 2.3 秋招中需要注意的地方 HR问你能不能实习。国外留学生在读期间肯定不能回国实习。所以毕业后你去实习，实习完人家不要你，你时间耽误了，也没准备题，就等着GG吧。所以我建议，坚决不做intern，直接fulltime。除非特别牛逼的公司，比如google。 别拒offer。拒offer败人品。人家给你就接着，最后也有个比较。我拿到俩offer，都没有违约金。其实有违约金也没所谓吧，给自己多留条路。牛客上很多朋友被dream company坑了，然后又拒掉其他公司，极其痛苦。 找个朋友一起秋招。一起刷题，一起吃饭，一起讨论，一起鼓励。效果很好。孤军奋战很容易坚持不住。 2.4 最后的总结都说程序员工资高，但是他们只看见贼吃肉，没看见贼挨打。我观察了其他行业应届生的找工作情况，基本都先是HR随便问问，然后无领导小组讨论，最后领导面一下画画大饼。顶多加一轮行测笔试了不起。但是码农不同，尤其是对于海外留学生，毫无优势，跟大流投简历、做笔试。以上两次都过了，视频面试也很容易被挂掉。网上有个测试说，远程面试比现场面试挂掉概率更大。关于笔试，我想说，无论你斯坦福、CMU还是MIT的硕士，只要笔试不过，那就是挂你。丝毫展示不出名校光环，除非等着人才池被捞出来。最后，说几个数字。五个半月的秋招，我投的公司主要是上海互联网公司，大大小小加一起差不多50-60家，国企30-40家，小公司20-30家。所以一共投了大概100-130家。拿到面试通知的公司，大概有20-30个。给我远程视频面或者电话面的公司不到10个。这不到10个的公司中，我拿到2个offer。最后去一个。总而言之，以上攻略仅适用于我在2018秋招找工作的情况，我觉得以后的竞争会更加激烈。希望这篇文章能对未来找工作的小伙伴有一些借鉴意义。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"}],"tags":[{"name":"秋招总结","slug":"秋招总结","permalink":"http://yoursite.com/tags/秋招总结/"}]},{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2018-09-02T16:41:00.000Z","updated":"2018-11-18T21:04:55.481Z","comments":true,"path":"2018/09/02/ArrayList源码分析/","link":"","permalink":"http://yoursite.com/2018/09/02/ArrayList源码分析/","excerpt":"","text":"ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。ArrayList继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391package java.util;import sun.misc.SharedSecrets;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;/** * 概述： * List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。 * 除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。 * 时间复杂度： * 方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。 * 添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。 * 容量： * 每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。 * 容量可以自动增长。 * 如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。 * 也可以通过带初始容量的构造器初始化这个容量。 * 线程不安全： * ArrayList不是线程安全的。 * 如果需要应用到多线程中，需要在外部做同步 * modCount： * 定义在AbstractList中：protected transient int modCount = 0; * 已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。 * 此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。 * 如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。 * 在迭代期间面临并发修改时，它提供了快速失败 行为，而不是非确定性行为。 * 子类是否使用此字段是可选的。 * 如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。 * 对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 concurrentmodificationexceptions。 * 如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。 * transient： * 默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8) */public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空的对象数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认的空数组 * 无参构造函数创建的数组 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 存放数据的数组的缓存变量，不可序列化 */ transient Object[] elementData; /** * 元素数量 * * @serial */ private int size; /** * 带有容量initialCapacity的构造方法 * * @param 初始容量列表的初始容量 * @throws IllegalArgumentException 如果指定容量为负 */ public ArrayList(int initialCapacity) &#123; // 如果初始化时ArrayList大小大于0 if (initialCapacity &gt; 0) &#123; // new一个该大小的object数组赋给elementData this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;// 如果大小为0 // 将空数组赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;// 小于0 // 则抛出IllegalArgumentException异常 throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125; &#125; /** * 不带参数的构造方法 */ public ArrayList() &#123; // 直接将空数组赋给elementData this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 带参数Collection的构造方法 * * @param c 其元素将被放入此列表中的集合 * @throws NullPointerException 如果指定的集合是空的 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toarray可能（错误地）不返回对象[]（见JAVA BUG编号6260652） if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 使用空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 因为容量常常会大于实际元素的数量。内存紧张时，可以调用该方法删除预留的位置，调整容量为元素实际数量。 * 如果确定不会再有元素添加进来时也可以调用该方法来节约空间 */ public void trimToSize() &#123; modCount++; // 如果size小于length if (size &lt; elementData.length) &#123; // 重新将elementData设置大小为size elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * 使用指定参数设置数组容量 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，容量预取0，否则去默认值(10) int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; //若参数大于预设的容量，在使用该参数进一步设置数组容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; /** * 得到最小扩容量 * * @param minCapacity */ private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; /** * 判断是否需要扩容 * * @param minCapacity */ private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果最小需要空间比elementData的内存空间要大，则需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 数组的最大容量，可能会导致内存溢出(VM内存限制) */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容，以确保它可以至少持有由参数指定的元素的数目 * * @param minCapacity 所需的最小容量 */ private void grow(int minCapacity) &#123; // 获取到ArrayList中elementData数组的内存空间长度 int oldCapacity = elementData.length; // 扩容至原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， // 不够就将数组长度设置为需要的长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //若预设值大于默认的最大值检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间 // 并将elementData的数据复制到新的内存空间 elementData = Arrays.copyOf(elementData, newCapacity); &#125; /** * 检查是否溢出，若没有溢出，返回最大整数值(java中的int为4字节，所以最大为0x7fffffff)或默认最大值 * * @param minCapacity * @return */ private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) //溢出 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回ArrayList的大小 * * @return ArrayList中的元素数量 */ public int size() &#123; return size; &#125; /** * 返回是否为空 * * @return true 如果ArrayList中无元素 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 是否包含一个数 返回bool * * @param o 检测o是否为ArrayList中元素 * @return true 如果ArrayList中包含o元素 */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回一个值在数组首次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回一个值在数组最后一次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回副本，元素本身没有被复制，复制过程数组发生改变会抛出异常 * * @return v ArrayList副本 */ public Object clone() &#123; try &#123; // 调用父类(翻看源码可见是Object类)的clone方法得到一个ArrayList副本 ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用Arrays类的copyOf，将ArrayList的elementData数组赋值给副本的elementData数组 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; // 返回副本v return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * 转换为Object数组，使用Arrays.copyOf()方法 * * @return 一个数组包含所有列表中的元素, 且顺序正确 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 将ArrayList里面的元素赋值到一个数组中去 * 如果a的长度小于ArrayList的长度，直接调用Arrays类的copyOf，返回一个比a数组长度要大的新数组，里面元素就是ArrayList里面的元素； * 如果a的长度比ArrayList的长度大，那么就调用System.arraycopy，将ArrayList的elementData数组赋值到a数组，然后把a数组的size位置赋值为空。 * * @param a 如果它的长度大的话，列表元素将存储在这个数组中; 否则，将为此分配一个相同运行时类型的新数组。 * @return 一个包含ArrayList元素的数组 * @throws ArrayStoreException 将与数组类型不兼容的值赋值给数组元素时抛出的异常 * @throws NullPointerException 数组为空 */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // 创建一个新的a的运行时类型数组，内容不变 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; /** * 返回指定位置的值，因为是数组，所以速度特别快 * * @param index * @return */ @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回指定位置的值，但是会先检查这个位置数否超出数组长度 * * @param index 要返回的元素的索引 * @return ArrayList中指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 检查是否越界 rangeCheck(index); // 返回ArrayList的elementData数组index位置的元素 return elementData(index); &#125; /** * 设置指定位置为一个新值，并返回之前的值，会检查这个位置是否超出数组长度 * * @param index 要替换的元素的索引 * @param element 要存储在指定位置的元素 * @return 之前在指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; // 检查是否越界 rangeCheck(index); // 调用elementData(index)获取到当前位置的值 E oldValue = elementData(index); // 将element赋值到ArrayList的elementData数组的第index位置 elementData[index] = element; return oldValue; &#125; /** * 添加一个值，首先会确保容量 * * @param e 要添加到此列表中的元素 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将e赋值给elementData的size+1的位置 elementData[size++] = e; return true; &#125; /** * 在ArrayList的index位置，添加元素element，会检查添加的位置和容量 * * @param index 指定元素将被插入的索引 * @param element 要插入的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 判断index是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) //src:源数组； srcPos:源数组要复制的起始位置； dest:目的数组； destPos:目的数组放置的起始位置； length:复制的长度 // 将elementData从index位置开始，复制到elementData的index+1开始的连续空间 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 在elementData的index位置赋值element elementData[index] = element; // ArrayList的大小加一 size++; &#125; /** * 在ArrayList的移除index位置的元素,会检查添加的位置，返回之前的值 * * @param index 要删除的元素的索引 * @return 从ArrayList中删除的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 判断是否越界 rangeCheck(index); modCount++; // 读取旧值 E oldValue = elementData(index); // 获取index位置开始到最后一个位置的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 return oldValue; &#125; /** * 在ArrayList的移除对象为O的元素，跟indexOf方法思想基本一致 * * @param o 要从该列表中删除的元素（如果存在） * @return true 如果这个列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * 快速删除指定位置的值，之所以叫快速，应该是不需要检查和返回值，因为只内部使用 * * @param index */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 &#125; /** * 清空数组，把每一个值设为null,方便垃圾回收(不同于reset，数组默认大小有改变的话不会重置) */ public void clear() &#123; modCount++; //便于垃圾回收器回收 for (int i = 0; i &lt; size; i++) elementData[i] = null; //把size设置为0，以便我们不会浏览到null值的内存空间 size = 0; &#125; /** * 添加一个集合的元素到末端，若要添加的集合为空返回false * * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将c转换为数组a Object[] a = c.toArray(); // 获取a占的内存空间长度赋值给numNew int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 将a的第0位开始拷贝至elementData的size位开始，拷贝长度为numNew System.arraycopy(a, 0, elementData, size, numNew); // 将size增加numNew size += numNew; // 如果c为空，返回false，c不为空，返回true return numNew != 0; &#125; /** * 从第index位开始，将c全部拷贝到ArrayList,若要添加的集合为空返回false * * @param index 在哪个索引处插入指定集合中的第一个元素 * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 判断index大于size或者是小于0,如果是，则抛出IndexOutOfBoundsException异常 rangeCheckForAdd(index); // 将c转换为数组a Object[] a = c.toArray(); int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 获取需要添加的个数 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 删除指定范围元素。参数为开始删的位置和结束位置 * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex;//后段保留的长度 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); //便于垃圾回收期回收 int newSize = size - (toIndex - fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查index是否超出数组长度 用于添加元素时 */ private void rangeCheck(int index) &#123; // 如果下标超过ArrayList的数组长度 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 检查是否溢出 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 抛出的异常的详情 */ private String outOfBoundsMsg(int index) &#123; return \"Index: \" + index + \", Size: \" + size; &#125; /** * ArrayList移除集合c中的所有元素 * * @param c 包含要从此列表中移除的元素的集合 * @return &#123;@code true&#125; 如果该列表因移除而改变 * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; // 如果c为空，则抛出空指针异常 Objects.requireNonNull(c); // 调用batchRemove移除c中的元素 return batchRemove(c, false); &#125; /** * 仅保留指定集合c中的元素 * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); // 调用batchRemove保留c中的元素 return batchRemove(c, true); &#125; /** * 根据complement值，将ArrayList中包含c中元素的元素删除或者保留 * * @param c * @param complement true时从数组保留指定集合中元素的值，为false时从数组删除指定集合中元素的值。 * @return 数组中重复的元素都会被删除(而不是仅删除一次或几次)，有任何删除操作都会返回true */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // 定义一个w，一个r，两个同时右移 int r = 0, w = 0; boolean modified = false; try &#123; // r先右移 for (; r &lt; size; r++) // 如果c中不包含elementData[r]这个元素 if (c.contains(elementData[r]) == complement) // 则直接将r位置的元素赋值给w位置的元素，w自增 elementData[w++] = elementData[r]; &#125; finally &#123; // 防止抛出异常导致上面r的右移过程没完成 if (r != size) &#123; // 将r未右移完成的位置的元素赋值给w右边位置的元素 System.arraycopy(elementData, r, elementData, w, size - r); // 修改w值增加size-r w += size - r; &#125; // 如果有被覆盖掉的元素，则将w后面的元素都赋值为null if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w;//改变的次数 //新的大小为保留的元素的个数 size = w; modified = true; &#125; &#125; return modified; &#125; /** * 保存数组实例的状态到一个流（即序列化）。写入过程数组被更改会抛出异常 * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; //执行默认的反序列化/序列化过程。将当前类的非静态和非瞬态字段写入此流 s.defaultWriteObject(); // 写入大小 s.writeInt(size); // 按顺序写入所有元素 for (int i = 0; i &lt; size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 从流中重构ArrayList实例（即反序列化）。 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // 执行默认的序列化/反序列化过程 s.defaultReadObject(); // 读入数组长度 s.readInt(); // ignored if (size &gt; 0) &#123; // 像clone()方法 ，但根据大小而不是容量分配数组 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; //读入所有元素 for (int i = 0; i &lt; size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * 返回一个从index开始的ListIterator对象 * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \" + index); return new ListItr(index); &#125; /** * 返回一个ListIterator对象，ListItr为ArrayList的一个内部类，其实现了ListIterator&lt;E&gt; 接口 * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * 返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口 * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * 通用的迭代器实现 */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; //游标，下一个元素的索引，默认初始化为0 int lastRet = -1; //上次访问的元素的位置 int expectedModCount = modCount;//迭代过程不运行修改数组，否则就抛出异常 //是否还有下一个 public boolean hasNext() &#123; return cursor != size; &#125; //下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification();//检查数组是否被修改 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1;//向后移动游标 return (E) elementData[lastRet = i];//设置访问的位置并返回这个值 &#125; //删除元素 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification();//检查数组是否被修改 try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; //检查数组是否被修改 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * ListIterator迭代器实现 */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * &lt;p&gt; * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * &lt;p&gt; * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; /** * 安全检查 * * @param fromIndex * @param toIndex * @param size */ static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\"); &#125; /** * 子数组 */ private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize == 0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; /** * 返回指定范围的子数组 * * @param fromIndex * @param toIndex * @return */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return \"Index: \" + index + \", Size: \" + this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Creates a &lt;em&gt;&lt;a href=\"Spliterator.html#binding\"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * &lt;p&gt; * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** * Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; /** * 如果ArrayLists是不可变的，或者在结构上不可变（不添加，删除等），我们可以用Arrays.spliterator实现它们的分割器。 * 相反，我们在遍历期间检测到尽可能多的干扰而不会影响性能。 * 我们主要依靠modCounts。这些不能保证检测到并发冲突，有时对线程内干扰过于保守，但在实践中检测到足够的问题是值得的。 * 为了实现这一点，我们 * （1）懒惰地初始化fence和expectedModCount，直到我们需要提交到我们正在检查的状态的最后一点;从而提高精度。 * （这不适用于SubLists，它会使用当前非惰性值的分割符）。 * （2）我们在forEach（对性能最敏感的方法）结束时只执行一次ConcurrentModificationException检查。 * 当使用forEach（而不是迭代器）时，我们通常只能在行为之后检测干扰，而不是之前。 * 进一步的CME触发检查适用于所有其他可能的违反假设的情况，例如null或过小的elementData数组，因为它的大小（）只能由于干扰而发生。 * 这允许forEach的内循环在没有任何进一步检查的情况下运行，并且简化了lambda分辨率。虽然这需要进行多次检查，但请注意，在list.stream（）。 * forEach（a）的常见情况中，除forEach本身之外，不会执行任何检查或其他计算。其他较少使用的方法无法利用这些优化的大部分优势。 */ private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** * Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings(\"unchecked\") E e = (E) list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings(\"unchecked\") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(\"unchecked\") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i = 0, j = 0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k = newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(\"unchecked\") public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings(\"unchecked\") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125;","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"source code","slug":"source-code","permalink":"http://yoursite.com/tags/source-code/"}]},{"title":"java对象排序-Comparator和Comparable","slug":"java对象排序-Comparator和Comparable","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:33:53.749Z","comments":true,"path":"2018/08/14/java对象排序-Comparator和Comparable/","link":"","permalink":"http://yoursite.com/2018/08/14/java对象排序-Comparator和Comparable/","excerpt":"","text":"当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。 一、Comparator强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。接口方法：int compare(Object o1, Object o2);举例：12345678910111213141516171819202122import java.util.Arrays;import java.util.Comparator;public class SampleComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return toInt(o1) - toInt(o2); &#125; private int toInt(Object o) &#123; String str = (String) o; str = str.replaceAll(&quot;一&quot;, &quot;1&quot;); str = str.replaceAll(&quot;二&quot;, &quot;2&quot;); str = str.replaceAll(&quot;三&quot;, &quot;3&quot;); // return Integer.parseInt(str); &#125; public static void main(String[] args) &#123; String[] array = new String[] &#123; &quot;一二&quot;, &quot;三&quot;, &quot;二&quot; &#125;; Arrays.sort(array, new SampleComparator()); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 二、Comparable强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。接口方法: int compareTo(Object o);假设对象User，需要按年龄排序：123456789101112131415161718192021222324252627public class User &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 改造后的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;public class User implements Comparable &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int compareTo(Object o) &#123; return this.age - ((User) o).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 三、Comparator和Comparable的区别先看一下使用Comparator对User集合实现排序的方式：1234567891011121314151617import java.util.Arrays;import java.util.Comparator;public class UserComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return ((User) o1).getAge() - ((User) o2).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users, new UserComparator()); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用： 类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身 可以使用多种排序标准，比如升序、降序等 四、补充一个例子：12345678List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Collections.sort(persons, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; Collator collator = Collator.getInstance(Locale.CHINA); return collator.compare(o1.getName(), o2.getName()); &#125; &#125;); 使用Collections.sort方法，传一个Comparator实现类，比较对象字段实现compare方法。 References java对象排序-Comparator和Comparable Java根据对象的某个字段排序","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Development","slug":"Java/Development","permalink":"http://yoursite.com/categories/Java/Development/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JDK1.5与JDK8新特性","slug":"JDK1.5与JDK8新特性","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:30:38.723Z","comments":true,"path":"2018/08/14/JDK1.5与JDK8新特性/","link":"","permalink":"http://yoursite.com/2018/08/14/JDK1.5与JDK8新特性/","excerpt":"","text":"一、JDK1.5新特性 自动装箱与拆箱：自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。自动拆箱的过程：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。自动拆箱，只需将该对象值赋给一个基本类型即可。java——类的包装器类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean 枚举把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。 静态导入通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner;后者一般是导入静态的方法，import static java.lang.System.out。 可变参数（Varargs）可变参数的简单语法格式为：methodName([argumentList], dataType…argumentName); 内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新 的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。一 般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。 泛型(Generic)C++通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。 For-Each循环For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。 JUCConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的,是concurrent包的重要成员。 二、JDK8新特性 Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 接口的默认方法与静态方法我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。 方法引用通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用。 构造器引用。语法是Class::new，或者更一般的Class&lt; T &gt;::new，要求构造器方法是没有参数。 静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数。 特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的。 特定对象的方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入。 重复注解在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。 扩展注解的支持Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。 OptionalJava 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。 StreamStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！ Date/Time API (JSR 310)Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。 JavaScript引擎NashornNashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。 Base64在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。 除了这十大新特性之外，还有另外的一些新特性： 更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。 编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。 并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。 并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。 Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）。另外Java8在JDK JUC 增加新的并发API。 三、参考资料 JDK各个版本的新特性jdk1.5-jdk8 Java8的十大新特性","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java保留两位小数的5种方法","slug":"java保留两位小数5种方法","date":"2018-08-14T19:24:40.000Z","updated":"2018-11-18T20:34:18.312Z","comments":true,"path":"2018/08/14/java保留两位小数5种方法/","link":"","permalink":"http://yoursite.com/2018/08/14/java保留两位小数5种方法/","excerpt":"","text":"#java保留两位小数5种方法 第一种： 1System.out.println(String.format(&quot;%.2f&quot;, f)); 第二种： 123BigDecimal bg = new BigDecimal(f); double f1 = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(f1); 第三种： 12DecimalFormat df = new DecimalFormat(&quot;#.00&quot;); System.out.println(df.format(f)); 第四种： 123NumberFormat nf = NumberFormat.getNumberInstance(); nf.setMaximumFractionDigits(2); System.out.println(nf.format(f)); 第五种： 1234float price=89.89;int itemNum=3;float totalPrice=price*itemNum;float num=(float)(Math.round(totalPrice*100)/100);//如果要求精确4位就*10000然后/10000 Referencejava保留两位小数5种方法","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java常见的坑","slug":"Java常见的坑","date":"2018-07-24T20:27:45.000Z","updated":"2018-11-18T21:38:08.469Z","comments":true,"path":"2018/07/24/Java常见的坑/","link":"","permalink":"http://yoursite.com/2018/07/24/Java常见的坑/","excerpt":"","text":"对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals方法进行判断。 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException。subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生ConcurrentModificationException 异常。 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(\"guan\"); list.add(\"bao\"); String[] array = new String[list.size()]; array = list.toArray(array); 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出 UnsupportedOperationException异常。asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。 使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Development","slug":"Java/Development","permalink":"http://yoursite.com/categories/Java/Development/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Git面试题","slug":"Git面试题","date":"2018-07-18T18:59:43.000Z","updated":"2018-11-18T20:32:54.809Z","comments":true,"path":"2018/07/18/Git面试题/","link":"","permalink":"http://yoursite.com/2018/07/18/Git面试题/","excerpt":"","text":"fetch和merge和pull的区别pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。git fetch：相当于是从远程获取最新版本到本地，不会自动mergegit merge : 将内容合并到当前分支git pull：相当于是从远程获取最新版本并merge到本地 tagtag指向一次commit的id，通常用来给开发分支做一个标记打标签 : git tag -a v1.01 -m “Relase version 1.01”提交标签到远程仓库 : git push origin –tags查看标签 : git tag查看某两次tag之间的commit：git log –pretty=oneline tagA..tagB查看某次tag之后的commit: git log –pretty=oneline tagA.. Git和SVN的区别Git是分布式版本控制系统，SVN是集中式版本控制系统 Git工作流程 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中 常用命令git show # 显示某次提交的内容 git show $idgit add # 将工作文件修改提交到本地暂存区git rm # 从版本库中删除文件git reset # 从暂存区恢复到工作文件git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git diff # 比较当前文件和暂存区文件差异 git diffgit log -p # 查看每次详细修改内容的diffgit branch -r # 查看远程分支git merge # 将branch分支合并到当前分支git stash # 暂存git stash pop #恢复最近一次的暂存git pull # 抓取远程仓库所有分支更新并合并到本地git push origin master # 将本地主分支推到远程主分支 git add 和 git stage 有什么区别？其实，他们两是同义的，所以，惊不惊喜，意不意外？这个问题竟然是个陷阱…引入 git stage 的原因其实比较有趣：是因为要跟 svn add 区分，两者的功能是完全不一样的，svn add 是将某个文件加入版本控制，而 git add 则是把某个文件加入暂存区，因为在 git 出来之前大家用 svn 比较多，所以为了避免误导，git 引入了git stage，然后把 git diff –staged 做为 git diff –cached 的相同命令。基于这个原因，我们建议使用 git stage 以及 git diff –staged。 git reset、git revert 和 git checkout 有什么区别？首先是它们的共同点：用来撤销代码仓库中的某些更改。然后是不同点：首先，从 commit 层面来说：git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset 还支持三种标记，用来标记 reset 指令影响的范围。git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。 然后，从文件层面来说：git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 –mixed、–soft 和 –hard。git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。git revert 不支持文件层面的操作. 参考资料 面试中的那些 Git 问题 - 基础部分 git常见面试题","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"如何删除GitHub中的目录?","slug":"如何删除GitHub中的目录?","date":"2018-06-30T20:35:01.000Z","updated":"2018-11-18T20:23:53.142Z","comments":true,"path":"2018/06/30/如何删除GitHub中的目录?/","link":"","permalink":"http://yoursite.com/2018/06/30/如何删除GitHub中的目录?/","excerpt":"","text":"如何删除GitHub中的目录？ 有时候错误上传目录到GitHub上，需要删除。只需要执行以下步骤： git clone 你的文件路径 ls -la git rm -r --cached 要删除的文件夹 git commit -m &#39;删除了target&#39; //提交,添加操作说明 git push -u origin master 将本次更改更新到github项目上去 关于git rm -r --cached中的“cached”参数，经查阅StackOverflow，解释如下： git rm on the other hand removes a file from the working directory and the index and when you commit, the file is removed from the tree as well. git rm –cached however removes the file from index alone and keeps it in your working copy. This is the exact opposite of git add file In this case, you made index to be different from the HEAD and the working, in it that the HEAD has the previously committed version of the file, working copy had the las modification if any or content from HEAD of the file and you removed the file from the index. A commit now will sync the index and tree and the file will be removed. 参考资料 “git rm –cached x” vs “git reset head — x”?","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git删除远程仓库文件夹或文件的方法","slug":"Git删除远程仓库文件夹或文件的方法","date":"2018-06-20T14:59:21.000Z","updated":"2018-11-18T20:48:14.332Z","comments":true,"path":"2018/06/20/Git删除远程仓库文件夹或文件的方法/","link":"","permalink":"http://yoursite.com/2018/06/20/Git删除远程仓库文件夹或文件的方法/","excerpt":"","text":"Git删除远程仓库文件夹或文件的方法 背景：想删除一个git目录里的文件，当时提交了，但想删除master里的，怎么办？1234git rm -r -n --cached *git rm -r --cached *git commit -m &quot;移除src目录下所有文件的版本控制&quot;git push origin master 如下，我把src里的全部移除，但是本地文件还保留: git rm -r -n –cached /src/\\ //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。 git rm -r –cached /src/\\ //最终执行命令. git commit -m”移除src目录下所有文件的版本控制” //提交 git push origin master //提交到远程服务器 原文链接：http://www.cnblogs.com/xusir/p/4111723.html","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java常考面试题","slug":"Java常考面试题","date":"2018-06-20T00:34:09.000Z","updated":"2018-11-18T21:39:35.168Z","comments":true,"path":"2018/06/19/Java常考面试题/","link":"","permalink":"http://yoursite.com/2018/06/19/Java常考面试题/","excerpt":"","text":"Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或是static的方法?“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。 是否可以在static环境中访问非static变量？static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 Java支持的数据类型有哪些？什么是自动拆装箱？Java语言支持的8种基本数据类型是：byte，short，int，long，float，double，boolean，char。自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程 Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。方法的重载是可以改变返回值类型的。 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。 Java支持多继承么？Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 接口和抽象类的区别是什么？不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 什么是值传递和引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递. 进程和线程的区别是什么？进程是运行在内存中的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。线程与进程的区别归纳：a. 进程是运行中的程序，线程是进程的内部的一个执行序列b. 进程是资源分配的单元，线程是执行行单元c. 进程间切换代价大，线程间切换代价小d. 进程拥有资源多，线程拥有资源少e. 多个线程共享进程的资源 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 继承Thread类，重写run方法； 实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性； 实现callable接口，重写call方法，有返回值。 使用实现了Executor接口的ThreadPoolExecutor来创建线程池。实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 概括的解释下线程的几种可用状态。 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 同步方法和同步代码块的区别是什么？同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；同步方法使用关键字 synchronized修饰方法;同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰； 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？监视器和锁在java中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程能访问同步代码块。每一个对象都与一个监视器相关联，没有获取到锁的对象不能执行这块同步代码块. 什么是死锁(deadlock)？所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类框架的基本接口有哪些？Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。克隆和序列化又被称为标识接口，在java中只起到标识类的作用。 什么是迭代器(Iterator)？迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 算法导论中原话：“基数排序是首先按最低位有效数字进行排序，才是稳定的算法”。 不稳定：快选堆希稳定：插冒归基 Iterator和ListIterator的区别是什么？下面列出了他们的区别：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 快速失败（fail—fast）：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 安全失败（fail—safe）采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。在java.util包下的都是快速失败。安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。在java.util.concurrent包下的全是安全失败的。 Java中的HashMap的工作原理是什么？hashmap的底层是以数组和单向链表进行实现的，当进行put操作的时候，首先通过hashcode()方法进行计算key的hash值，然后找出链表索引，然后看索引上是否有相同的key值，如果有就更新value值，如果没有就把值加在链表尾。hashmap有两个重要的属性参数，capacity（容量）和loadfactor（负载因子），初始值分别为16与0.75，当存储的数据的数量达到了capacity*loadfactor就会进行扩容操作（resize），将容量扩充为2n。一般进行初始化的时候，可以重新设置capacity与loadfactor，但是一般capacity的默认值一般是比较好的，不需要进行更改。只需要考虑capacity的值就行了，一般如果能够提前预估容量大小，将会大大减少扩容的消耗。 hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 HashMap和Hashtable有什么区别？都实现了Map接口，但是不同点有: HashMap是非线程安全的，HashTable是线程安全的。 HashMap的键和值都允许有null值存在，而HashTable则不行。 因为线程安全的问题，HashMap效率比HashTable的要高。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？下面列出了Array和ArrayList的不同点： Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 什么是Java优先级队列(Priority Queue)？优先级队列就是一种自己定义队列中元素大小的队列 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？O：大O是上界Θ：大Θ是平均值Ω：大Ω是下界 如何权衡是使用无序的数组还是有序的数组？有序数组查询容易，插入难。无序数组插入容易，查询难.查找复杂度：有序数组O(log n) ，无序数组 O(n)插入复杂度：有序数组O(n) ，无序数组 O(1) Java集合类框架的最佳实践有哪些？一开始还在想，难道有什么经典的算法或者什么方法理论，称之为最佳实践。看了答案才知道是怎么去选择一个合适的集合类框架。 那么，首先选一个适合的。比如固定那就选不拓展，插入频繁就链表，查询频繁就数组。不知道这个答案可以不？根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。编程的时候接口优于实现。底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 Enumeration接口和Iterator接口的区别有哪些？iterator是快速失败的，当你在遍历的时候，如果另起一个线程来修改它（集合的内容）的结构，这时迭代器会立马感知到，引起快速失败，抛出ConcurrentModificationException异常。所以说iterator 是安全的。 HashSet和TreeSet有什么区别？HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。触发主GC（Garbage Collector，垃圾回收）的条件：（1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。（2）Java堆内存不足时，GC会被调用。 System.gc()和Runtime.gc()会做什么事情？这俩个方法都是用来提示java虚拟机进行垃圾回收，但是否立即回收还是延迟回收由java虚拟机决定。 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 垃圾回收器在回收某对象时，垃圾收集器会调用对象的finalize()方法。 析构finalization，比如你在调用了一些native的方法，可以要在finaliztion里去调用释放函数。 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?虚拟机中的共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 年轻代: 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 年老代: 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代:用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 JVM的永久代中会发生垃圾回收么？JAVA堆内存分为持久代，年轻代和老年代。年轻代存放新生成的对象。垃圾回收主要是针对这个区域。在年轻代中经历了N次垃圾回收依然存活的对象被放入老年代中。持久代存放的是类定义信息，与垃圾收集器关系不大。 Java中的两种异常类型是什么？他们有什么区别？Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。 Java中Exception和Error有什么区别？Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。 throw和throws有什么区别？throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 finally代码块和finalize()方法有什么区别？无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 什么是JDBC？JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 Class.forName()方法有什么作用？初始化参数指定的类，并且返回此类对应的Class 对象. PreparedStatement比Statement有什么优势？PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象。PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法, excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。PreparedStatements的代码可读性，可维护性强于statement.防止sql注入攻击，极大的提高了安全性。 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStatement Connection.prepareCall(); 数据库连接池是什么意思？像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 什么是RMI？Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。 RMI体系结构的基本原则是什么？RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。 RMI体系结构分哪几层？RMI体系结构分以下几层：存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 RMI中的远程接口(Remote Interface)扮演了什么样的角色？远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 java.rmi.Naming类扮演了什么样的角色？java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。 RMI的绑定(Binding)是什么意思？绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。 Naming类的bind()和rebind()方法有什么区别？bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 让RMI程序能正确运行有哪些步骤？为了让RMI程序能正确运行必须要包含以下几个步骤：编译所有的源文件。使用rmic生成stub。启动rmiregistry。启动RMI服务器。运行客户端程序 RMI的stub扮演了什么样的角色？远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：初始化到包含了远程对象的JVM的连接。序列化参数到远程的JVM。等待方法调用和执行的结果。反序列化返回的值或者是方法没有执行成功情况下的异常。把值返回给调用者。 什么是分布式垃圾回收(DGC)？它是如何工作的？DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。 解释下Marshalling和demarshalling。当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。 解释下Serialization和Deserialization。Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 什么是Servlet？Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。 说一下Servlet的体系结构。所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。 GenericServlet和HttpServlet有什么区别？GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法. 解释下Servlet的生命周期。1.加载实例化 2.初始化 3.处理请求 4.销毁Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。②装载并创建该Servlet的一个实例对象。③调用Servlet实例对象的init()方法。④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 doGet()方法和doPost()方法有什么区别？doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。 什么是Web应用程序？web应用程序就是一种可以通过web进行访问的应用程序，简单的说就是可以直接通过浏览器进行访问的应用程序。基于典型的B/S模式的应用程序，核心是对数据库的相关操作和处理. 什么是服务端包含(Server Side Include)？服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。 什么是Servlet链(Servlet Chaining)？Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 如何知道是哪一个客户端的机器正在请求你的Servlet？ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。 HTTP响应的结构是怎么样的？响应消息行：包含协议/版本，响应状态码，对响应状态码的描述（一切正常);响应消息头：:服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作;响应消息正文：和网页右键“查看源码”看到的内容一样; 什么是cookie？session和cookie有什么区别？cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。 浏览器和Servlet通信使用的是什么协议？浏览器和Servlet通信使用的是HTTP协议。 什么是HTTP隧道？HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。 sendRedirect()和forward()方法有什么区别？sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。 么是URL编码和URL解码？URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 什么是JSP页面？jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。 JSP请求是如何被处理的？客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。 JSP有什么优点？JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。JSP页面可以被预编译。JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive：包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。Taglib指令： 用来声明页面中使用的自定义的标签库。 什么是JSP动作(JSP action)？JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：jsp:include-当JSP页面被请求的时候包含一个文件。jsp:useBean-找出或者是初始化Javabean。jsp:setProperty-设置JavaBean的属性。jsp:getProperty-获取JavaBean的属性。jsp:forward-把请求转发到新的页面。jsp:plugin-产生特定浏览器的代码。 什么是Scriptlets？指jsp页面里 &lt;% %&gt; 中间的代码。一个包含任何在JSP页面中合法的脚本语言的代码片断的JSP脚本元素。Java Web开发时，尽量不要在JSP中出现这种Scriptlets，尽量多使用JSP标签，或者JSTL，或者一些框架的标签。 什么是JSP表达式(Expression)？格式：&lt;%=有值得表达式%&gt; 表达式返回值不能是void类型。 隐含对象（内置对象）是什么意思？有哪些隐含对象？JSP隐含对象就是在编译成servlet时，servlet里产生的可以直接用的内置对象，共有九个：application，request，response，session，config，page，out，pagecontext，exception。 面向对象软件开发的优点有哪些？代码开发模块化，更易维护和修改。代码复用。增强代码的可靠性和灵活性。增加代码的可理解性。面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。 封装的定义和好处有哪些？封装就是将过程和数据包围起来，对数据的访问只能通过自定义的界面。封装有属性封装和方法封装，封装定义了访问这些属性和方法的范围，分别有pubilc，paivare，protected和默认的friendy。封装减少了复杂性，提高了代码的安全性. 多态的定义？多态就是：父类对象的引用，所指对象，可以是父类的对象，也可以是子类的对象。为了实现代码复用，减少代码量。 继承的定义？继承就是对象的新类从现有类中派生，新类拥有原始类所有特性。 抽象的定义？抽象和封装的不同点？抽象: 抽象就是忽略一个问题中与当前目标无关的那些方面，以便更充分的注意与当前目标有关的部分，抽象不打算了解问题的全部，而是只选择其中的一个部分，抽象包括两个方面：过程抽象和数据抽象。封装：就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。 Networks OSI，TCP/IP，五层协议的体系结构，以及各层协议.OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS每一层的作用如下：物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类?A类地址：以0开头， 第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）E类地址：保留其中A、B、C是基本类，D、E类作为多播和保留使用。以下是留用的内部私有地址：A类 10.0.0.0–10.255.255.255B类 172.16.0.0–172.31.255.255C类 192.168.0.0–192.168.255.255IP地址与子网掩码相与得到网络号：ip : 192.168.2.110&amp;Submask : 255.255.255.0=网络号 ：192.168.2 .0注: 主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255） 巧记IP地址分类。A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。D类地址(224~239)：以1110开头，保留位多播地址。E类地址(240~255)：以1111开头，保留位今后使用。 ARP是地址解析协议，简单语言解释一下工作原理。1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 各种协议的介绍。ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 描述RARP协议。RARP，逆地址解析协议，其作用是完成MAC地址到IP地址的映射，主要用于无盘工作站，因为为无盘工作站配置对额IP地址无法保存。其工作流程是：在网络中建立一个ARAP服务器，用于保存MAC地址和IP地址的映射关系。当无盘工作站启动后，其会封装一个ARAP数据包，其中尤其MAC地址，然后广播到网络中去，当服务器接收到请求包，就查找对应的MAC地址对应的IP地址装入响应报文中发给请求者。因为需要广播请求报文，所以RARP只能用于具有广播能力的网络。 TCP三次握手和四次挥手的全过程？ 三次握手： 客户端发送SYN请求，进入SYN_SEND状态 服务端收到SYN请求，并返回一个ACK应答，并发送一个SYN其请求，服务器进入SYN_RECV状态。 客户端收到服务端的SYN请求和ACK应答，发送ACK应答，客户端进入ESTABLISH状态，服务端收到应答后进入ESTABLISH。如果没有收到应答，数据包都会根据TCP的重传机制进行重传。 四次挥手： 客户端发送FIN包，请求断开连接，客户端进入FIN_WAIT1状态 服务端收到FIN包后返回应答，进入CLOSE_WAIT状态 客户端收到FIN的应答后进入FIN_WAIT2状态 服务端发送FIN请求包，进入LAST_ACK状态 客户端收到FIN请求包后，发送应答进入TIME_WAIT状态 服务器收到ACK应答后，进入close状态。 在浏览器中输入www.baidu.com后执行的全部过程。 客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 TCP和UDP的区别？ TCP面向连接的运输层协议，UDP无连接 TCP是可靠交付，UDP是尽最大努力交付 TCP面向字节流，UDP面向报文 TCP是点对点连接的，UDP一对一，一对多，多对多都可以 TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等TCP对应的协议：（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。当一个应用进程需要把某个域名解析为IP地址时，该应用进程就会调用解析程序，并成为一个DNS用户，把待解析的域名放在DNS请求报文中，以UDP数据报的形式发送给本地域名服务器，本地域名服务器查找到相应域名的IP地址后，就将该域名的IP地址信息放入应答报文中返回给客户进程，如果本地域名服务器没有直接查找到对应的IP地址，则向根域名服务器发出迭代查询，再将查询到的IP地址信息回传给客户程序。 TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？A：喂，听到吗？ B：能听到，你呢？A：….B：… OS 操作系统的五大管理功能:（1）作业管理：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等；（2）文件管理：又称为信息管理；（3）存储管理：实质是对存储“空间”的管理，主要指对主存的管理；（4）设备管理：实质是对硬件设备的管理，其中包括对输入输出设备的分配、启动、完成和回收；（5）进程管理：实质上是对处理机执行“时间”的管理，即如何将CPU真正合理地分配给每个任务。 cpu工作状态分为系统态（或称管理态，管态）和用户态（或称目态）。 引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为：当cpu处于用户态时，不允许执行特权指令，当cpu处于系统态时，可执行包括特权指令在内的一切机器指令。 98或 xp 都可以有多个用户帐号密码，但请注意多用户是指多个用户同时操作。而98和 XP 在同一时间只能使用一个用户，所以包括 XP 在内，都只是单用户多任务的。 操作系统有四个明显的特征：并发性，共享性，虚拟性以及不确定性。 CPU要完成一组I/O操作，只需要向I/O通道发送一条I/O指令，通道接到指令，通过执行通道程序，并且与设备控制器一起共同来实现对I/O设备的控制和操作。 分时系统具有多路性、交互性、“独占”性和及时性的特征。 并发和共享是操作系统的两个最基本的特性，它们又是互为存在条件。一方面资源共享是以程序（进程）的并发性执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题。另一方面若系统不能对资源共享实施有效管理，则也必将影响到程序并发执行。 系统调用提供了用户程序和操作系统之间的接口。 多道程序系统的运行必须要依赖通道和中断硬件机构的支持。 系统态，即内核态，三种情况下会出现由用户态转为内核态，中断，异常，系统调用。 单道批处理并不会因为你请求了我就准备响应你，我的响应不是你的请求决定的，而是取决于我执行完上一个没有，多道批处理是我空出CPU了你就可以进来执行，取决于什么时候空出来，这两个都没有一个时间标准，不确定什么时候响应，，时间间隔的标准要求在一定时间内必须响应，不管你做没做完。 批处理不能处理需要交互类型的作业啊。 多道操作系统特意准备：特权指令（多道优先级）跳转指令（程序跳转）。如果不是多道的操作系统，也就是单任务处理的，那么一个一个的执行就好了，当出现多道的时候，就会出现优先级的问题，因此特权指令是为了提供在优先级不同的条件下，用户状态的切换，跳转指令就是从我们的程序跳转到另一个了，可能会感觉时钟会有用，给每一个程序分配一定的时间，让其运行，但是这个并不是必须的，因为可以根据优先级来采取抢占式的执行，所以时钟不是特别提供的，特权指令和跳转指令在单道批处理下是不能够起到作用的 独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。共享设备：多个用户作业或多个进程可以“同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。 进程的模式有系统态和用户态 两种，一般用户编写的程序是在用户态下工作，当程序中有中断或者调用系统函数 时，会切换到系统态下运行。 分时操作系统 ，主要分为三类：单道分时操作系统，多道分时操作系统，具有前台和后台的分时操作系统。 实时系统应具有的两个基本特征是( 及时)和( 可靠)。 批处理操作系统的主要缺点是缺少交互性。 操作系统的三种基本类型是：批处理操作系统,分时操作系统,实时操作系统。 从用户的观点出发，操作系统是用户和计算机之间的接口有命令接口,程序接口,图形接口三种。 操作系统中采用多道程序设计技术后，提高了CPU和外部设备的利用率。 操作系统的特征是并发性,共享性,虚拟性,异步性。 操作系统目前有五大类型：批处理操作系统,分时操作系统,实时操作系统,网络操作系统,分布式操作系统。 dos是磁盘操作系统的缩写。 计算机操作命令可分为联机命令,shell程序语言命令,脱机作业控制语言命令。 操作系统的目标是方便性,有效性,可扩充性,开放性。 系统调用和一般用户函数调用的区别？在操作系统中，系统调用程序在系统态执行；一般用户函数调用程序由用户准备，在用户态执行。 一般用户最常用的操作系统接口是什么接口？一般用户最常用的操作系统与用户的接口是控制接口。用户使用这个接口控制、管理和操作计算机系统，利用它控制程序的执行。控制接口分为脱机接连、命令接口、图形接口、多媒体接口。 过程调用和系统调用的共同点是什么，它们与中断调用的差别是什么？过程调用和系统调用的执行完全是同步的，也就是在相同的数据集上重复执行，它们的调用点是相同的，都需要保存现场信息，转去执行另外的程序，执行后返回。中断调用是异步的，在相同的数据集上重复执行，中断的发生点可以是不同的。 分时系统的响应时间受哪些因素的影响？分时系统的相应时间是指用户从终端发出一个命令到系统处理完这个命令并做出回答所需要的时间。这个时间受时间片长度、终端用户个数、命令本身功能、硬件特性、主存与辅存的交换速度等影响。 实时系统和分时系统的主要区别有两点：（1）分时系统的目标是提供一种通用性很强的系统，有较强的交互能力；而实时系统则大都是具有特殊用途的专用系统，交互能力略差。（2）分时系统对响应时间虽有要求，但一般来说，响应时间由人所能承受的等待时间来确定；而实时系统对响应时间要求很高，一般由控制系统或信息处理磁头所能接受的延迟时间来决定。 为什么中断机构对于多道操作系统是必不可少的？很多进程的切换是由中断引起的，如时钟中断，尤其是分时系统。用户程序进行系统调用时通过软中断来实现，如TRAP。通道和外设的操作也要向操作系统发送中断。 网络操作系统和分布式操作系统的区别？网络OS中的用户使用自己的机器可以访问网络上别的机器的资源，通过网络将很多机器连接起来，共享硬件资源，但是，整个系统对用户来说是分散的，不透明的。分布式OS的用户也是通过网络将多台机器连接起来，但是整个系统对用户是透明的，用户对整个OS就好像使用一个自己的机器一样。 简述操作系统的定义。操作系统是计算机系统的一种系统软件，它统一管理计算机系统的资源和控制程序的执行。 作业在系统中有哪几种状态？一个作业进入系统到运行结束，一般要经历进入、后备、运行和完成四个阶段，相应地，作业亦有进入、后备、运行和完成四种状态。① 进入状态：作业的信息从输入设备上预输入到输入井，此时称为作业处于进入状态。② 后备状态：当作业的全部信息都已输入，且由操作系统将其存放在输入井中，此时称作业处于后备状态。系统将所有处于后备状态的作业组成后备作业队列，等待作业调度程序的调度。③ 运行状态：一个后备作业被作业调度程序选中，分配了必要的资源，调入内存运行，称作业处于运行状态。④ 完成状态：当作业正常运行完毕或因发生错误非正常终止时，作业进入这完成状态。 中断装置的职能主要有三点：① 检查是否有中断事件发生；② 若有中断发生，保护好被中断进程的断点及现场信息，以便进程在适当时候能恢复执行；③ 启动操作系统的中断处理程序。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"},{"name":"Java","slug":"面试/Java","permalink":"http://yoursite.com/categories/面试/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"macOS下安装及卸载MySQL","slug":"macOS下安装及卸载MySQL","date":"2018-06-12T14:24:17.000Z","updated":"2018-11-18T20:33:22.817Z","comments":true,"path":"2018/06/12/macOS下安装及卸载MySQL/","link":"","permalink":"http://yoursite.com/2018/06/12/macOS下安装及卸载MySQL/","excerpt":"","text":"一、安装 直接从官网down下来，我的macOS版本是10.13.5，使用的mysql版本是5.7.22。 无脑下一步，切记要记住初始时候设置的root密码。如果跟我一样不记得，请参考第三部分。 启动mysql：在MAC中的System Preference里，最后一栏，可以启动和停止mysql，也可以设置开机自动启动。 使用terminal操作mysql： 为Path路径附加mysql的bin目录：PATH=&quot;$PATH&quot;:/usr/local/mysql/bin 登录mysql：mysql -u root -p 你的密码 二、卸载卸载比较麻烦，在terminal下输入以下命令： 123456789sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig //执行完上面命令后使用的是Vim指令，复制上述命令，保存，退出即可。继续完成下列指令：rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* 最后打开系统偏好设置，最下方MySQL图标消失。 三、 忘记密码 击系统偏好设置-&gt;最下边点MySQL，在弹出页面中，关闭服务 进入终端输入 cd /usr/local/mysql/bin/ 切换为管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 继续输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES 回车后，输入命令 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;你的新密码&#39;); 密码设置成功！ 四、参考资料 Mac OS X下完全卸载MySQL mac 安装mysql详细教程","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"},{"name":"MySQL","slug":"Database/MySQL","permalink":"http://yoursite.com/categories/Database/MySQL/"},{"name":"Development","slug":"Database/MySQL/Development","permalink":"http://yoursite.com/categories/Database/MySQL/Development/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"Maven常用构建命令","slug":"Maven常用构建命令","date":"2018-06-03T18:05:11.000Z","updated":"2018-11-18T20:26:26.273Z","comments":true,"path":"2018/06/03/Maven常用构建命令/","link":"","permalink":"http://yoursite.com/2018/06/03/Maven常用构建命令/","excerpt":"","text":"Maven常用构建命令 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 mvn -v:查看版本 mvn compile mvn test mvn package mvn clean：删除target mvn install：安装jar包到本地仓库中","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"MAC下安装并配置Maven","slug":"MAC下安装并配置Maven","date":"2018-06-03T12:14:33.000Z","updated":"2018-11-18T20:27:18.081Z","comments":true,"path":"2018/06/03/MAC下安装并配置Maven/","link":"","permalink":"http://yoursite.com/2018/06/03/MAC下安装并配置Maven/","excerpt":"","text":"下载Maven打开Maven官网下载页面：http://maven.apache.org/download.cgi下载:apache-maven-3.1.0-bin.tar.gz。解压下载的安装包到某一目录，比如：/Users/xxx/Documents/maven 配置环境变量打开terminel输入以下命令：vim ~/.bash_profile 打开.bash_profile文件，在次文件中添加设置环境变量的命令 12export M2_HOME=/Users/xxx/Documents/maven/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 添加之后保存并推出，执行以下命令使配置生效：source ~/.bash_profile 查看配置是否生效terminal输入：mvn -v命令，输出如下： Maven 3.1.0 (893ca28a1da9d5f51ac03827af98bb730128f9f2; 2013-06-28 10:15:32+0800)12345Maven home: /Users/***/Library/MavenJava version: 1.*.*_40, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jreDefault locale: en_US, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.13.4\", arch: \"x86_64\", family: \"mac\" 则表示配置成功。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Java后台开发工程师秋招攻略2018Fall","slug":"Java后台开发工程师秋招攻略2018Fall","date":"2018-06-02T22:21:44.000Z","updated":"2018-11-19T21:29:01.393Z","comments":true,"path":"2018/06/02/Java后台开发工程师秋招攻略2018Fall/","link":"","permalink":"http://yoursite.com/2018/06/02/Java后台开发工程师秋招攻略2018Fall/","excerpt":"","text":"这份攻略是6月份左右刚开始准备秋招时候用的，但是后来在执行的时候发现，这份网上总结而来的攻略并不符合实际情况。现在已找到工作，把6月-11月以来所闻所见所想记录于2018秋招总结中。 一、 算法和数据结构基础1. 数据结构：数组，链表，哈希表，堆，队列，栈，二叉树，B树/B+树，红黑树，图(研发问图不多) 2. 常见的排序算法(冒泡，插入，快排，堆排，归并排序…) 3. 简单的动态规划问题(背包，上楼梯) 4. 各种时间空间复杂度分析 二、Java 基础1. 最基本的语言基础：语法，关键字含义，面向对象…. 2. 集合类(ArrayList, HashMap, ConcurrentHashmap…等等) 3. 多线程(锁，CAS，线程池，concurrent 包下的类) 4. 语言特性：反射，动态代理，泛型，Java 8 新特性 5. IO (装饰器模式，NIO) 6. JVM：内存模型，垃圾回收，类加载机制 三、 Java Web1. Tomcat，Servlet，JSP，Cookie/Session 等基本概念 2. 框架使用和原理：Spring(AOP，IoC)，MyBatis 等 四、数据库(主要是 MySQL)1. 基本 SQL 语句，索引优化 2. 存储引擎(InnoDB，MyISAM)，索引原理 3. 事务 ACID，隔离级别 4. 分库分表，主从复制，读写分离 五、计算机网络1. OSI 7 层模型和 TCP 4 层模型 2. 传输层：TCP/IP 相关知识，和 UDP 比较 3. HTTP 协议：报文结构，POST/GET 方法 4. 网络编程 (socket, NIO, select 等) 六、操作系统1. 基本 Linux 的操作指令 2. 进程/线程比较，进程间通信方式，P/V 操作 3. 磁盘调度，虚拟内存 4. 死锁，中断 七、书籍推荐1. 《算法》（第四版）图以前章节 2. 《剑指 Offer》 3. 《Java 编程思想》 4. 《Java多线程编程核心技术》(高洪岩 著) 5. 《Java 并发编程实战》 6. 《深入理解 Java 虚拟机》 7. 《Java 8 实战》 8. 《鸟哥的 Linux 私房菜》 9. 《MySQL 必知必会》 10. 《Maven 实战》 11. 《图解 HTTP》 12. 《敏捷软件开发》 13. 《架构探险－从零开始写 Java Web 框架》 14. 《Spring 3.x 企业应用开发实战》 15. 《Head First 设计模式》 16. 《大型网站技术架构》（李智慧 著） 17. 《大型网站系统与 Java 中间件实践》","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"}],"tags":[{"name":"秋招攻略","slug":"秋招攻略","permalink":"http://yoursite.com/tags/秋招攻略/"}]},{"title":"鸟哥Linux私房菜学习笔记（二）","slug":"鸟哥Linux私房菜学习笔记（二）","date":"2018-05-23T15:50:30.000Z","updated":"2018-11-18T20:38:08.958Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（二）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（二）/","excerpt":"","text":"##什么是挂载？挂载的用途是什么？书上讲的挂载不是很清楚，在网络上搜索后，对挂载有了较为深刻的理解，在此总结如下。 在Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。 Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给Linux的所有区都在/下的某个位置，比如/home等等。 提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。 我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。 这时提问者使用了mount /dev/sdb1 ~/Share/，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。 所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。 Linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ 这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。 插入CD，系统其实自动执行了mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理 ##参考资料 Linux学习笔记（二）：什么是挂载？mount的用处在哪？","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"鸟哥Linux私房菜学习笔记（一）","slug":"鸟哥Linux私房菜学习笔记（一）","date":"2018-05-23T15:39:11.000Z","updated":"2018-11-18T20:37:46.301Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（一）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（一）/","excerpt":"","text":"之前把这本书看过一遍，但是时间一长就忘记了。在此review一遍，准备秋招，又能加深理解。虚拟机：VMware物理机版本：macOS10.13.4Linux版本：CentOS7.0 64位虚拟机配置：20G硬盘，2GB内存 ##基础知识及常用命令 Linux默认提供6个terminal来让用户登录，切换的方式为：CTRL+ALT+F1~F6。F7切换为图形界面。 Linux系统对字母大小写敏感。 显示时间和日期的命令：date 显示日历的命令：cal 计算器：bc 常用的关机命令：shutdown； shutdown -h 20:00是指在晚上8点钟关机；shutdown -h now是指立刻关机。 ##注意事项 VMware虚拟机进入BIOS：开机按F2键 安装时需自定义分区 ##参考资料 Linux学习笔记(一)：Win10上用VMware虚拟机安装Linux-CentOS","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"七牛云qshell使用教程","slug":"七牛云qshell使用教程","date":"2018-04-22T12:44:56.000Z","updated":"2018-11-18T20:32:05.181Z","comments":true,"path":"2018/04/22/七牛云qshell使用教程/","link":"","permalink":"http://yoursite.com/2018/04/22/七牛云qshell使用教程/","excerpt":"","text":"###1.下载qshell本人使用的是MAC，官网开发者工具处下载的qshell无法运行，但是可以从Github下载qshell，修改名称为qshell,并运行。 ###2.修改权限如果在Linux或者Mac系统上遇到Permission Denied的错误，请使用命令chmod +x qshell来为文件添加可执行权限。 ###3.修改路径将qshell复制到/usr/local/bin/目录下。使其在terminal下能够直接被调用。 ###4.配置账户 配置access key和secret key：qshell account AK SK 查看当前key：qshell account ###5.常用命令|命令|类别|描述|详细||——|————|———-|——–||account|账号|设置或显示当前用户的AccessKey和SecretKey|文档||dircache|存储|输出本地指定路径下所有的文件列表|文档||listbucket|存储|列举七牛空间里面的所有文件|文档||prefop|存储|查询七牛数据处理的结果|文档||fput|存储|以文件表单的方式上传一个文件|文档||rput|存储|以分片上传的方式上传一个文件|文档||qupload|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（配置式）|文档||qupload2|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（命令式）|文档||qdownload|存储|从七牛空间同步数据到本地，支持只同步某些前缀的文件，支持增量同步|文档||stat|存储|查询七牛空间中一个文件的基本信息|文档||delete|存储|删除七牛空间中的一个文件|文档||move|存储|移动或重命名七牛空间中的一个文件|文档||copy|存储|复制七牛空间中的一个文件|文档||chgm|存储|修改七牛空间中的一个文件的MimeType|文档||chtype|存储|修改七牛空间中的一个文件的存储类型，支持普通存储（0）和低频存储（1）|文档||expire|存储|修改七牛空间中的一个文件的生存时间|文档||fetch|存储|从Internet上抓取一个资源并存储到七牛空间中|文档||sync|存储|从Internet上抓取一个资源并存储到七牛空间中，适合大文件的场合|文档||prefetch|存储|更新七牛空间中从源站镜像过来的文件|文档||batchdelete|存储|批量删除七牛空间中的文件，可以直接根据listbucket的结果来删除|文档||batchchgm|存储|批量修改七牛空间中文件的MimeType|文档||batchchtype|存储|批量修改七牛空间中的文件的存储类型，支持普通存储（0）和低频存储（1）|文档||batchexpire|存储|批量修改七牛空间中的文件的生存时间|文档||batchcopy|存储|批量复制七牛空间中的文件到另一个空间|文档||batchmove|存储|批量移动七牛空间中的文件到另一个空间|文档||batchrename|存储|批量重命名七牛空间中的文件|文档||batchsign|存储|批量根据资源的公开外链生成资源的私有外链|文档||batchstat|存储|批量查询七牛空间中文件的基本信息|文档||privateurl|存储|生成私有空间资源的访问外链|文档||saveas|存储|实时处理的saveas链接快捷生成工具|文档||reqid|存储|七牛自定义头部X-Reqid解码工具|文档||buckets|存储|获取当前账号下所有的空间名称|文档||domains|存储|获取指定空间的所有关联域名|文档||qetag|存储|根据七牛的qetag算法来计算文件的hash|文档||m3u8delete|存储|根据流媒体播放列表文件删除七牛空间中的流媒体切片|文档||m3u8replace|存储|修改流媒体播放列表文件中的切片引用域名|文档||cdnrefresh|CDN|批量刷新cdn的访问外链或目录|文档||cdnprefetch|CDN|批量预取cdn的访问外链|文档||b64encode|工具|base64编码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||b64decode|工具|base64解码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||urlencode|工具|url编码工具|文档||urldecode|工具|url解码工具|文档||ts2d|工具|将timestamp(单位秒)转为UTC+8:00中国日期，主要用来检查上传策略的deadline参数|文档||tms2d|工具|将timestamp(单位毫秒)转为UTC+8:00中国日期|文档||tns2d|工具|将timestamp(单位100纳秒)转为UTC+8:00中国日期|文档||d2ts|工具|将日期转为timestamp(单位秒)|文档||ip|工具|根据淘宝的公开API查询ip地址的地理位置|文档||unzip|工具|解压zip文件，支持UTF-8编码和GBK编码|文档||alilistbucket|第三方|列举阿里OSS空间里面的所有文件|文档|","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"七牛云","slug":"七牛云","permalink":"http://yoursite.com/tags/七牛云/"}]},{"title":"尾调用及其优化","slug":"尾调用及其优化","date":"2018-04-04T01:31:21.000Z","updated":"2018-11-18T20:25:38.750Z","comments":true,"path":"2018/04/03/尾调用及其优化/","link":"","permalink":"http://yoursite.com/2018/04/03/尾调用及其优化/","excerpt":"","text":"之前一直对尾调用相关概念比较模糊，在此做一个总结。 一、 什么是尾调用尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。function f(x){ return g(x); }上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下两种情况，都不属于尾调用。 // 情况一function f(x){ let y = g(x); return y;}// 情况二function f(x){ return g(x) + 1;}上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x &gt; 0) { return m(x) } return n(x);}上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 二、 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3);上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。 三、 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5) // 120上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1) // 120对于以上的阶乘，由于递归在方法的末尾，因此方法中的局部变量已经毫无用处，编译器完全可以将其“复用”，并把尾递归优化为“循环”方式。由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 四、递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}function factorial(n) { return tailFactorial(n, 1);}factorial(5) // 120上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 function currying(fn, n) { return function (m) { return fn.call(this, m, n); };}function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5) // 120 五、参考资料 尾调用优化 浅谈尾递归的优化方式","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"recursive","slug":"recursive","permalink":"http://yoursite.com/tags/recursive/"}]},{"title":"MAC下Homebrew的安装及使用","slug":"MAC下Homebrew的安装及使用","date":"2018-04-02T15:19:03.000Z","updated":"2018-11-18T20:28:24.927Z","comments":true,"path":"2018/04/02/MAC下Homebrew的安装及使用/","link":"","permalink":"http://yoursite.com/2018/04/02/MAC下Homebrew的安装及使用/","excerpt":"","text":"##1. 什么是什么是HomebrewHomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebrew可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 ##2. Homebrew的安装Homebrew的安装很简单，只需在终端下输入如下指令：ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序。 这时你在命令行状态下面就可以使用 brew 命令了。 ##3. Homebrew的使用 安装软件：brew install 软件名，例：brew install wget 搜索软件：brew search 软件名，例：brew search wget 卸载软件：brew uninstall 软件名，例：brew uninstall wget 更新所有软件：brew update 更新具体软件：brew upgrade 软件名 ，例：brew upgrade git 显示已安装软件：brew list 查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git 查看那些已安装的程序需要更新： brew outdated 显示包依赖：brew reps通过 update 可以把包信息更新到最新，不过包更新是通过git命令，所以要先通过 brew install git 命令安装git。 ##4. 参考资料 【工具】Homebrew的安装及使用","categories":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/categories/Mac/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://yoursite.com/tags/homebrew/"}]},{"title":"比特币与区块链","slug":"比特币与区块链","date":"2018-03-23T23:23:18.000Z","updated":"2018-11-18T20:36:41.843Z","comments":true,"path":"2018/03/23/比特币与区块链/","link":"","permalink":"http://yoursite.com/2018/03/23/比特币与区块链/","excerpt":"","text":"I learned the basic ideas of bitcoin and blockchain in the computer security class last week, so I just write a summary here. ##1.LedgerFirstly, let’s talk about the ledger. Why use a ledger? If you exchange money with some people very frequently, using a ledger is better than cash. So you guys can create a ledger and record all the transactions. For example, Alice, Bob, Charlie and you. You can see some records in the ledger as below:Alice pays Bob $20Bob pays Charlie $40Charle pays you $30You pay Alice $10 This ledger is public, everybody could add new records in it. In the end of every moth, people will look at the list of records and settle up.As above description, the protocol is pretty simple: Anyone could add records to the Ledger; Settle up with US dollars every moth; However, there is a problem of the protocol. Anyone can add a new transaction if he/she want. For example, Alice can add a record that Bob pays Alice $200 without telling Bob. How to solve this problem? ##2.Digital SignatureIn the real world, we can sign our name at the end of every transaction. The signature could prove we already have seen it and approve it. In the computer world, we should use digital signature. The digital signature leverages hash function. There is an example as below: Transaction Signature Alice pays Bob $20 Signature1=hash(“Alice pays Bob $20”) Bob pays Charlie $40 Signature2=hash(“Bob pays Charlie $40”) Bob pays Charlie $30 Signature3=hash(“Bob pays Charlie $30”) There is a crucial problem. As the handwritten signature, a digital signature could be forged. Actually, the digital signature is a string of bits, people could copy it. So it cannot prevent forgeries. How to prove the signature’s owner? ##3.Public-key CryptoWhat is Public-key cryptography? You can click the hyperlink to see the details. To solve the problem as above, the basic idea is: Get the hash value by hash fuction (SHA-256);HashValue=SHA-256(OriginalRecord) Alice use her own private key to encrypt the hash value generated before;Signature=Sign(HashValue,PrivateKey) Anyone could use Alice’s public key to decrypt the signature and compare the result with original record. This process is called signature verify, the result is true or false;Result(T/F)=Verify(OriginalRecord,Signature,PublicKey) If the result is true, it means: This signature belongs to this record; This signature belongs to Alice; This record is not modified by others; However, there is another problem: even though other people cannot forge Alice’s signature, but they can copy a whole record to a new line. Luckily, there is a solution: add an unique sequence number to every record. Until now, the protocol looks like below. Anyone could add records to the Ledger; Settle up with US dollars every moth; Only signed transactions are valid; It seems perfect, but there must be some people break the rules. So we must rely on some honor system. In the paper “Bitcoin: A Peer-to-Peer Electronic Cash System”, the author proposed “peer-to-peer”. It means that it shouldn’t be a central system in the protocol. If Bob owes a lot of money and runs away, how to handle this problem? The protocol should be changed as below: Anyone could add records to the Ledger; No overspending; Only signed transactions are valid; In theory, if all people in the world was using this ledger, people could live their whole life just sending and receiving money on this ledger without real US dollars. So the ledger should be placed in a public place, such as a website where anyone can add new records. But who host the website? As I described above, we cannot use a central system, but we can have everybody hold their own copy of ledger. In the network, if someone makes a transaction what he/she does it broadcast that out into the whole network. According to this approach, how could you get everyone to agree on what the right ledger is? how to make everyone received and believes that transaction? how to add the transactions in the ledger if you received them together? ##4.Bitcoin&amp;BlockchainFor a hash function like SHA-256, whatever you put into it, the result is a 256 bits string. What the miners do is that they find a number add into the ledger, and then use SHA-256(ledger+number) to get a result. The result first 30 bits are “0”! But find the number is very very hard. The only way to find the special number is guessing and checking. So the miner has to go through about a billion different numbers before finding the special one. But the verify process is much easier. The process that people find the number is called “proof of work”. Let’s go back the distributed ledger situations. In the whole network, there are many copies of ledger, every copy is a block. And in each block, it contains a list of transactions(records) with a proof of work(special number). A block is only considered valid if it has a proof of work. But how the next transactions know the previous transactions that use to make sure someone has enough money to pay? We make a block has to contain the hash of the previous block at its header, it means every transaction should base on the previous transactions. It looks like a blockchain. In the blockchain, anyone could be a block creater. The creator is going to listen for transactions being broadcast, collect into some block, and then computes the special number that makes the hash of that block start with N zeros. Once he/she find it, just broadcast out the block he/she found. To reward a bloack creator for all this work, when the creator puts together a block, we allow he/she to include a very special transaction at the top of it, it is called block reward. It means the total number of bitcoin in our economy increases with each block. The process of creating blocks is called “mining”, the creator called “miner”. what the miner did is listening for transactions, creating blocks, broadcasting those blocks, and getting rewarded with new money for doing so. The miner’s computer more powerful, the high possibility they have. However, if someone receive two blocks at the same, what should he does? The solution is that he just makes a branch and keep both of them, and waits for the next block. It is hardly to receive two blocks at the same time. If receive, just wait for the third block. After that, he/she just selects the longer branch and discard the other one. ##5.Techniques Leverage SHA-256 hash function and public-key crypto to generate digital signature Save the transactions by blocks of blockchain Protect the bitcoin network and control the average block time by setting extra works Incent miner to increase the network Transactions of bitcoin don’t rely on bank or other honor system ##6.Tips The Average Block Time is about 10 minuetes The total number of bitcoin is less than 21 million GPU mining is faster than CPU mining. Block Reward: 12.5 BTC (2017) Transaction Fee: average 2 BTC (2017) Average income of one block: 14.5 BTC = 260 thousand USD = 1.7 million USD To maintain the average block time, the bitcoin network upgrade the degree of difficulty every two weeks Bitcoin is saved in your bitcoin client ##7.Reference Ever wonder how Bitcoin (and other cryptocurrencies) actually work? 比特币的原理","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"concepts","slug":"concepts","permalink":"http://yoursite.com/tags/concepts/"}]},{"title":"Markdonw语法","slug":"Markdown语法","date":"2018-01-05T14:40:51.000Z","updated":"2018-11-18T20:24:42.831Z","comments":true,"path":"2018/01/05/Markdown语法/","link":"","permalink":"http://yoursite.com/2018/01/05/Markdown语法/","excerpt":"","text":"1.标题标题共有六级。“#”数量代表标题级数。 一级标题 # text 二级标题 ## text 三级标题 ### text … 2.列表 有序列表:1. text2. text3. text 无序列表：* text* text 3.引用只需要在需要引用的文本前加入 “&gt;” 这种尖括号（大于号）即可。&gt; text This is a reference. 4.图片与链接插入链接与插入图片的语法很像，区别在一个”!”号。 图片为：![]() 链接为：[]()My Blog 5.粗体与斜体在文本前加入**text**，即为粗体， *text*即为斜体。注意，星号间不能有空格。 这是 粗体 ，这是 斜体。 6.分隔线分隔线只需要三个星号，像这样***。 我上面和下面都是分隔线。 7.表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 8.代码框代码框只需要用包裹文字即可。用TAB缩进。 参考 Markdown——入门指南 Learning-Markdown","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"markdonw","slug":"markdonw","permalink":"http://yoursite.com/tags/markdonw/"}]}]}