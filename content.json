{"meta":{"title":"William's Blog","subtitle":null,"description":"Keep moving. Don't settle.","author":"William Sun","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-11-18T18:31:43.000Z","updated":"2018-11-18T18:31:55.033Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-18T18:27:32.000Z","updated":"2018-11-18T18:28:48.858Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-18T18:30:47.000Z","updated":"2018-11-18T18:31:14.672Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2018-09-02T16:41:00.000Z","updated":"2018-11-18T20:35:42.140Z","comments":true,"path":"2018/09/02/ArrayList源码分析/","link":"","permalink":"http://yoursite.com/2018/09/02/ArrayList源码分析/","excerpt":"","text":"package java.util; import sun.misc.SharedSecrets; import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /** 概述： List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。 除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。 时间复杂度： 方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。 添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。 容量： 每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。 容量可以自动增长。 如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。 也可以通过带初始容量的构造器初始化这个容量。 线程不安全： ArrayList不是线程安全的。 如果需要应用到多线程中，需要在外部做同步 modCount： 定义在AbstractList中：protected transient int modCount = 0; 已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。 此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。 如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。 在迭代期间面临并发修改时，它提供了快速失败 行为，而不是非确定性行为。 子类是否使用此字段是可选的。 如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。 对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 concurrentmodificationexceptions。 如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。 transient： 默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8)*/ public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空的对象数组 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 默认的空数组 * 无参构造函数创建的数组 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 存放数据的数组的缓存变量，不可序列化 */ transient Object[] elementData; /** * 元素数量 * * @serial */ private int size; /** * 带有容量initialCapacity的构造方法 * * @param 初始容量列表的初始容量 * @throws IllegalArgumentException 如果指定容量为负 */ public ArrayList(int initialCapacity) { // 如果初始化时ArrayList大小大于0 if (initialCapacity &gt; 0) { // new一个该大小的object数组赋给elementData this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) {// 如果大小为0 // 将空数组赋给elementData this.elementData = EMPTY_ELEMENTDATA; } else {// 小于0 // 则抛出IllegalArgumentException异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity); } } /** * 不带参数的构造方法 */ public ArrayList() { // 直接将空数组赋给elementData this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 带参数Collection的构造方法 * * @param c 其元素将被放入此列表中的集合 * @throws NullPointerException 如果指定的集合是空的 */ public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toarray可能（错误地）不返回对象[]（见JAVA BUG编号6260652） if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 使用空数组 this.elementData = EMPTY_ELEMENTDATA; } } /** * 因为容量常常会大于实际元素的数量。内存紧张时，可以调用该方法删除预留的位置，调整容量为元素实际数量。 * 如果确定不会再有元素添加进来时也可以调用该方法来节约空间 */ public void trimToSize() { modCount++; // 如果size小于length if (size &lt; elementData.length) { // 重新将elementData设置大小为size elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } /** * 使用指定参数设置数组容量 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { //如果数组为空，容量预取0，否则去默认值(10) int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&apos;s already // supposed to be at default size. : DEFAULT_CAPACITY; //若参数大于预设的容量，在使用该参数进一步设置数组容量 if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); } } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } /** * 得到最小扩容量 * * @param minCapacity */ private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } /** * 判断是否需要扩容 * * @param minCapacity */ private void ensureExplicitCapacity(int minCapacity) { modCount++; // 如果最小需要空间比elementData的内存空间要大，则需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } /** * 数组的最大容量，可能会导致内存溢出(VM内存限制) */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容，以确保它可以至少持有由参数指定的元素的数目 * * @param minCapacity 所需的最小容量 */ private void grow(int minCapacity) { // 获取到ArrayList中elementData数组的内存空间长度 int oldCapacity = elementData.length; // 扩容至原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， // 不够就将数组长度设置为需要的长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //若预设值大于默认的最大值检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间 // 并将elementData的数据复制到新的内存空间 elementData = Arrays.copyOf(elementData, newCapacity); } /** * 检查是否溢出，若没有溢出，返回最大整数值(java中的int为4字节，所以最大为0x7fffffff)或默认最大值 * * @param minCapacity * @return */ private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) //溢出 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } /** * 返回ArrayList的大小 * * @return ArrayList中的元素数量 */ public int size() { return size; } /** * 返回是否为空 * * @return true 如果ArrayList中无元素 */ public boolean isEmpty() { return size == 0; } /** * 是否包含一个数 返回bool * * @param o 检测o是否为ArrayList中元素 * @return true 如果ArrayList中包含o元素 */ public boolean contains(Object o) { return indexOf(o) &gt;= 0; } /** * 返回一个值在数组首次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } /** * 返回一个值在数组最后一次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int lastIndexOf(Object o) { if (o == null) { for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; } else { for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } /** * 返回副本，元素本身没有被复制，复制过程数组发生改变会抛出异常 * * @return v ArrayList副本 */ public Object clone() { try { // 调用父类(翻看源码可见是Object类)的clone方法得到一个ArrayList副本 ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用Arrays类的copyOf，将ArrayList的elementData数组赋值给副本的elementData数组 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; // 返回副本v return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); } } /** * 转换为Object数组，使用Arrays.copyOf()方法 * * @return 一个数组包含所有列表中的元素, 且顺序正确 */ public Object[] toArray() { return Arrays.copyOf(elementData, size); } /** * 将ArrayList里面的元素赋值到一个数组中去 * 如果a的长度小于ArrayList的长度，直接调用Arrays类的copyOf，返回一个比a数组长度要大的新数组，里面元素就是ArrayList里面的元素； * 如果a的长度比ArrayList的长度大，那么就调用System.arraycopy，将ArrayList的elementData数组赋值到a数组，然后把a数组的size位置赋值为空。 * * @param a 如果它的长度大的话，列表元素将存储在这个数组中; 否则，将为此分配一个相同运行时类型的新数组。 * @return 一个包含ArrayList元素的数组 * @throws ArrayStoreException 将与数组类型不兼容的值赋值给数组元素时抛出的异常 * @throws NullPointerException 数组为空 */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) // 创建一个新的a的运行时类型数组，内容不变 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } /** * 返回指定位置的值，因为是数组，所以速度特别快 * * @param index * @return */ @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) { return (E) elementData[index]; } /** * 返回指定位置的值，但是会先检查这个位置数否超出数组长度 * * @param index 要返回的元素的索引 * @return ArrayList中指定位置的元素 * @throws IndexOutOfBoundsException {@inheritDoc} */ public E get(int index) { // 检查是否越界 rangeCheck(index); // 返回ArrayList的elementData数组index位置的元素 return elementData(index); } /** * 设置指定位置为一个新值，并返回之前的值，会检查这个位置是否超出数组长度 * * @param index 要替换的元素的索引 * @param element 要存储在指定位置的元素 * @return 之前在指定位置的元素 * @throws IndexOutOfBoundsException {@inheritDoc} */ public E set(int index, E element) { // 检查是否越界 rangeCheck(index); // 调用elementData(index)获取到当前位置的值 E oldValue = elementData(index); // 将element赋值到ArrayList的elementData数组的第index位置 elementData[index] = element; return oldValue; } /** * 添加一个值，首先会确保容量 * * @param e 要添加到此列表中的元素 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将e赋值给elementData的size+1的位置 elementData[size++] = e; return true; } /** * 在ArrayList的index位置，添加元素element，会检查添加的位置和容量 * * @param index 指定元素将被插入的索引 * @param element 要插入的元素 * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { // 判断index是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) //src:源数组； srcPos:源数组要复制的起始位置； dest:目的数组； destPos:目的数组放置的起始位置； length:复制的长度 // 将elementData从index位置开始，复制到elementData的index+1开始的连续空间 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 在elementData的index位置赋值element elementData[index] = element; // ArrayList的大小加一 size++; } /** * 在ArrayList的移除index位置的元素,会检查添加的位置，返回之前的值 * * @param index 要删除的元素的索引 * @return 从ArrayList中删除的元素 * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { // 判断是否越界 rangeCheck(index); modCount++; // 读取旧值 E oldValue = elementData(index); // 获取index位置开始到最后一个位置的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 return oldValue; } /** * 在ArrayList的移除对象为O的元素，跟indexOf方法思想基本一致 * * @param o 要从该列表中删除的元素（如果存在） * @return true 如果这个列表包含指定的元素 */ public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } /** * 快速删除指定位置的值，之所以叫快速，应该是不需要检查和返回值，因为只内部使用 * * @param index */ private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 } /** * 清空数组，把每一个值设为null,方便垃圾回收(不同于reset，数组默认大小有改变的话不会重置) */ public void clear() { modCount++; //便于垃圾回收器回收 for (int i = 0; i &lt; size; i++) elementData[i] = null; //把size设置为0，以便我们不会浏览到null值的内存空间 size = 0; } /** * 添加一个集合的元素到末端，若要添加的集合为空返回false * * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(Collection&lt;? extends E&gt; c) { // 将c转换为数组a Object[] a = c.toArray(); // 获取a占的内存空间长度赋值给numNew int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 将a的第0位开始拷贝至elementData的size位开始，拷贝长度为numNew System.arraycopy(a, 0, elementData, size, numNew); // 将size增加numNew size += numNew; // 如果c为空，返回false，c不为空，返回true return numNew != 0; } /** * 从第index位开始，将c全部拷贝到ArrayList,若要添加的集合为空返回false * * @param index 在哪个索引处插入指定集合中的第一个元素 * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws IndexOutOfBoundsException {@inheritDoc} * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 判断index大于size或者是小于0,如果是，则抛出IndexOutOfBoundsException异常 rangeCheckForAdd(index); // 将c转换为数组a Object[] a = c.toArray(); int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 获取需要添加的个数 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } /** * 删除指定范围元素。参数为开始删的位置和结束位置 * * @throws IndexOutOfBoundsException if {@code fromIndex} or * {@code toIndex} is out of range * ({@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex}) */ protected void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = size - toIndex;//后段保留的长度 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); //便于垃圾回收期回收 int newSize = size - (toIndex - fromIndex); for (int i = newSize; i &lt; size; i++) { elementData[i] = null; } size = newSize; } /** * 检查index是否超出数组长度 用于添加元素时 */ private void rangeCheck(int index) { // 如果下标超过ArrayList的数组长度 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * 检查是否溢出 */ private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * 抛出的异常的详情 */ private String outOfBoundsMsg(int index) { return &quot;Index: &quot; + index + &quot;, Size: &quot; + size; } /** * ArrayList移除集合c中的所有元素 * * @param c 包含要从此列表中移除的元素的集合 * @return {@code true} 如果该列表因移除而改变 * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) { // 如果c为空，则抛出空指针异常 Objects.requireNonNull(c); // 调用batchRemove移除c中的元素 return batchRemove(c, false); } /** * 仅保留指定集合c中的元素 * * @param c collection containing elements to be retained in this list * @return {@code true} if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); // 调用batchRemove保留c中的元素 return batchRemove(c, true); } /** * 根据complement值，将ArrayList中包含c中元素的元素删除或者保留 * * @param c * @param complement true时从数组保留指定集合中元素的值，为false时从数组删除指定集合中元素的值。 * @return 数组中重复的元素都会被删除(而不是仅删除一次或几次)，有任何删除操作都会返回true */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; // 定义一个w，一个r，两个同时右移 int r = 0, w = 0; boolean modified = false; try { // r先右移 for (; r &lt; size; r++) // 如果c中不包含elementData[r]这个元素 if (c.contains(elementData[r]) == complement) // 则直接将r位置的元素赋值给w位置的元素，w自增 elementData[w++] = elementData[r]; } finally { // 防止抛出异常导致上面r的右移过程没完成 if (r != size) { // 将r未右移完成的位置的元素赋值给w右边位置的元素 System.arraycopy(elementData, r, elementData, w, size - r); // 修改w值增加size-r w += size - r; } // 如果有被覆盖掉的元素，则将w后面的元素都赋值为null if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w;//改变的次数 //新的大小为保留的元素的个数 size = w; modified = true; } } return modified; } /** * 保存数组实例的状态到一个流（即序列化）。写入过程数组被更改会抛出异常 * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; //执行默认的反序列化/序列化过程。将当前类的非静态和非瞬态字段写入此流 s.defaultWriteObject(); // 写入大小 s.writeInt(size); // 按顺序写入所有元素 for (int i = 0; i &lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } /** * 从流中重构ArrayList实例（即反序列化）。 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // 执行默认的序列化/反序列化过程 s.defaultReadObject(); // 读入数组长度 s.readInt(); // ignored if (size &gt; 0) { // 像clone()方法 ，但根据大小而不是容量分配数组 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; //读入所有元素 for (int i = 0; i &lt; size; i++) { a[i] = s.readObject(); } } } /** * 返回一个从index开始的ListIterator对象 * * @throws IndexOutOfBoundsException {@inheritDoc} */ public ListIterator&lt;E&gt; listIterator(int index) { if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot; + index); return new ListItr(index); } /** * 返回一个ListIterator对象，ListItr为ArrayList的一个内部类，其实现了ListIterator&lt;E&gt; 接口 * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() { return new ListItr(0); } /** * 返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口 * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() { return new Itr(); } /** * 通用的迭代器实现 */ private class Itr implements Iterator&lt;E&gt; { int cursor; //游标，下一个元素的索引，默认初始化为0 int lastRet = -1; //上次访问的元素的位置 int expectedModCount = modCount;//迭代过程不运行修改数组，否则就抛出异常 //是否还有下一个 public boolean hasNext() { return cursor != size; } //下一个元素 @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification();//检查数组是否被修改 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1;//向后移动游标 return (E) elementData[lastRet = i];//设置访问的位置并返回这个值 } //删除元素 public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification();//检查数组是否被修改 try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } //检查数组是否被修改 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } /** * ListIterator迭代器实现 */ private class ListItr extends Itr implements ListIterator&lt;E&gt; { ListItr(int index) { super(); cursor = index; } public boolean hasPrevious() { return cursor != 0; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } @SuppressWarnings(&quot;unchecked&quot;) public E previous() { checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; } public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.set(lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void add(E e) { checkForComodification(); try { int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } } /** * Returns a view of the portion of this list between the specified * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive. (If * {@code fromIndex} and {@code toIndex} are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * &lt;p&gt; * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for {@link #indexOf(Object)} and * {@link #lastIndexOf(Object)}, and all of the algorithms in the * {@link Collections} class can be applied to a subList. * &lt;p&gt; * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public List&lt;E&gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } /** * 安全检查 * * @param fromIndex * @param toIndex * @param size */ static void subListRangeCheck(int fromIndex, int toIndex, int size) { if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;); } /** * 子数组 */ private class SubList extends AbstractList&lt;E&gt; implements RandomAccess { private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) { this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; } public E set(int index, E e) { rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; } public E get(int index) { rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); } public int size() { checkForComodification(); return this.size; } public void add(int index, E e) { rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; } public E remove(int index) { rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; } protected void removeRange(int fromIndex, int toIndex) { checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; } public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(this.size, c); } public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); int cSize = c.size(); if (cSize == 0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; } public Iterator&lt;E&gt; iterator() { return listIterator(); } public ListIterator&lt;E&gt; listIterator(final int index) { checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() { int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() { return cursor != SubList.this.size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; } public boolean hasPrevious() { return cursor != 0; } @SuppressWarnings(&quot;unchecked&quot;) public E previous() { checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; } @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[offset + (i++)]); } // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.set(offset + lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void add(E e) { checkForComodification(); try { int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); } }; } /** * 返回指定范围的子数组 * * @param fromIndex * @param toIndex * @return */ public List&lt;E&gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); } private void rangeCheck(int index) { if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private String outOfBoundsMsg(int index) { return &quot;Index: &quot; + index + &quot;, Size: &quot; + this.size; } private void checkForComodification() { if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); } public Spliterator&lt;E&gt; spliterator() { checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); } } @Override public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(&quot;unchecked&quot;) final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) { action.accept(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } /** * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this * list. * &lt;p&gt; * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED}, * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a {@code Spliterator} over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() { return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); } /** * Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; { /** * 如果ArrayLists是不可变的，或者在结构上不可变（不添加，删除等），我们可以用Arrays.spliterator实现它们的分割器。 * 相反，我们在遍历期间检测到尽可能多的干扰而不会影响性能。 * 我们主要依靠modCounts。这些不能保证检测到并发冲突，有时对线程内干扰过于保守，但在实践中检测到足够的问题是值得的。 * 为了实现这一点，我们 * （1）懒惰地初始化fence和expectedModCount，直到我们需要提交到我们正在检查的状态的最后一点;从而提高精度。 * （这不适用于SubLists，它会使用当前非惰性值的分割符）。 * （2）我们在forEach（对性能最敏感的方法）结束时只执行一次ConcurrentModificationException检查。 * 当使用forEach（而不是迭代器）时，我们通常只能在行为之后检测干扰，而不是之前。 * 进一步的CME触发检查适用于所有其他可能的违反假设的情况，例如null或过小的elementData数组，因为它的大小（）只能由于干扰而发生。 * 这允许forEach的内循环在没有任何进一步检查的情况下运行，并且简化了lambda分辨率。虽然这需要进行多次检查，但请注意，在list.stream（）。 * forEach（a）的常见情况中，除forEach本身之外，不会执行任何检查或其他计算。其他较少使用的方法无法利用这些优化的大部分优势。 */ private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** * Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) { this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; } private int getFence() { // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) { if ((lst = list) == null) hi = fence = 0; else { expectedModCount = lst.modCount; hi = fence = lst.size; } } return hi; } public ArrayListSpliterator&lt;E&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); } public boolean tryAdvance(Consumer&lt;? super E&gt; action) { if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) { index = i + 1; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } public void forEachRemaining(Consumer&lt;? super E&gt; action) { int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) { if ((hi = fence) &lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) { for (; i &lt; hi; ++i) { @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i]; action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); } public long estimateSize() { return (long) (getFence() - index); } public int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } } @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) { Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) { @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; if (filter.test(element)) { removeSet.set(i); removeCount++; } } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) { final int newSize = size - removeCount; for (int i = 0, j = 0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) { i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; } for (int k = newSize; k &lt; size; k++) { elementData[k] = null; // Let gc do its work } this.size = newSize; if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } return anyToRemove; } @Override @SuppressWarnings(&quot;unchecked&quot;) public void replaceAll(UnaryOperator&lt;E&gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) { elementData[i] = operator.apply((E) elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } @Override @SuppressWarnings(&quot;unchecked&quot;) public void sort(Comparator&lt;? super E&gt; c) { final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } }","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"source code","slug":"source-code","permalink":"http://yoursite.com/tags/source-code/"}]},{"title":"java对象排序-Comparator和Comparable","slug":"java对象排序-Comparator和Comparable","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:33:53.749Z","comments":true,"path":"2018/08/14/java对象排序-Comparator和Comparable/","link":"","permalink":"http://yoursite.com/2018/08/14/java对象排序-Comparator和Comparable/","excerpt":"","text":"当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。 一、Comparator强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。接口方法：int compare(Object o1, Object o2);举例：12345678910111213141516171819202122import java.util.Arrays;import java.util.Comparator;public class SampleComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return toInt(o1) - toInt(o2); &#125; private int toInt(Object o) &#123; String str = (String) o; str = str.replaceAll(&quot;一&quot;, &quot;1&quot;); str = str.replaceAll(&quot;二&quot;, &quot;2&quot;); str = str.replaceAll(&quot;三&quot;, &quot;3&quot;); // return Integer.parseInt(str); &#125; public static void main(String[] args) &#123; String[] array = new String[] &#123; &quot;一二&quot;, &quot;三&quot;, &quot;二&quot; &#125;; Arrays.sort(array, new SampleComparator()); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 二、Comparable强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。接口方法: int compareTo(Object o);假设对象User，需要按年龄排序：123456789101112131415161718192021222324252627public class User &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 改造后的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;public class User implements Comparable &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int compareTo(Object o) &#123; return this.age - ((User) o).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 三、Comparator和Comparable的区别先看一下使用Comparator对User集合实现排序的方式：1234567891011121314151617import java.util.Arrays;import java.util.Comparator;public class UserComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return ((User) o1).getAge() - ((User) o2).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users, new UserComparator()); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用： 类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身 可以使用多种排序标准，比如升序、降序等 四、补充一个例子：12345678List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Collections.sort(persons, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; Collator collator = Collator.getInstance(Locale.CHINA); return collator.compare(o1.getName(), o2.getName()); &#125; &#125;); 使用Collections.sort方法，传一个Comparator实现类，比较对象字段实现compare方法。 References java对象排序-Comparator和Comparable Java根据对象的某个字段排序","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Development","slug":"Java/Development","permalink":"http://yoursite.com/categories/Java/Development/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JDK1.5与JDK8新特性","slug":"JDK1.5与JDK8新特性","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:30:38.723Z","comments":true,"path":"2018/08/14/JDK1.5与JDK8新特性/","link":"","permalink":"http://yoursite.com/2018/08/14/JDK1.5与JDK8新特性/","excerpt":"","text":"一、JDK1.5新特性 自动装箱与拆箱：自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。自动拆箱的过程：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。自动拆箱，只需将该对象值赋给一个基本类型即可。java——类的包装器类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean 枚举把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。 静态导入通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner;后者一般是导入静态的方法，import static java.lang.System.out。 可变参数（Varargs）可变参数的简单语法格式为：methodName([argumentList], dataType…argumentName); 内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新 的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。一 般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。 泛型(Generic)C++通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。 For-Each循环For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。 JUCConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的,是concurrent包的重要成员。 二、JDK8新特性 Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 接口的默认方法与静态方法我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。 方法引用通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用。 构造器引用。语法是Class::new，或者更一般的Class&lt; T &gt;::new，要求构造器方法是没有参数。 静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数。 特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的。 特定对象的方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入。 重复注解在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。 扩展注解的支持Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。 OptionalJava 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。 StreamStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！ Date/Time API (JSR 310)Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。 JavaScript引擎NashornNashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。 Base64在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。 除了这十大新特性之外，还有另外的一些新特性： 更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。 编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。 并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。 并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。 Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）。另外Java8在JDK JUC 增加新的并发API。 三、参考资料 JDK各个版本的新特性jdk1.5-jdk8 Java8的十大新特性","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java保留两位小数的5种方法","slug":"java保留两位小数5种方法","date":"2018-08-14T19:24:40.000Z","updated":"2018-11-18T20:34:18.312Z","comments":true,"path":"2018/08/14/java保留两位小数5种方法/","link":"","permalink":"http://yoursite.com/2018/08/14/java保留两位小数5种方法/","excerpt":"","text":"#java保留两位小数5种方法 第一种： 1System.out.println(String.format(&quot;%.2f&quot;, f)); 第二种： 123BigDecimal bg = new BigDecimal(f); double f1 = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(f1); 第三种： 12DecimalFormat df = new DecimalFormat(&quot;#.00&quot;); System.out.println(df.format(f)); 第四种： 123NumberFormat nf = NumberFormat.getNumberInstance(); nf.setMaximumFractionDigits(2); System.out.println(nf.format(f)); 第五种： 1234float price=89.89;int itemNum=3;float totalPrice=price*itemNum;float num=(float)(Math.round(totalPrice*100)/100);//如果要求精确4位就*10000然后/10000 Referencejava保留两位小数5种方法","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Git面试题","slug":"Git面试题","date":"2018-07-18T18:59:43.000Z","updated":"2018-11-18T20:32:54.809Z","comments":true,"path":"2018/07/18/Git面试题/","link":"","permalink":"http://yoursite.com/2018/07/18/Git面试题/","excerpt":"","text":"fetch和merge和pull的区别pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。git fetch：相当于是从远程获取最新版本到本地，不会自动mergegit merge : 将内容合并到当前分支git pull：相当于是从远程获取最新版本并merge到本地 tagtag指向一次commit的id，通常用来给开发分支做一个标记打标签 : git tag -a v1.01 -m “Relase version 1.01”提交标签到远程仓库 : git push origin –tags查看标签 : git tag查看某两次tag之间的commit：git log –pretty=oneline tagA..tagB查看某次tag之后的commit: git log –pretty=oneline tagA.. Git和SVN的区别Git是分布式版本控制系统，SVN是集中式版本控制系统 Git工作流程 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中 常用命令git show # 显示某次提交的内容 git show $idgit add # 将工作文件修改提交到本地暂存区git rm # 从版本库中删除文件git reset # 从暂存区恢复到工作文件git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git diff # 比较当前文件和暂存区文件差异 git diffgit log -p # 查看每次详细修改内容的diffgit branch -r # 查看远程分支git merge # 将branch分支合并到当前分支git stash # 暂存git stash pop #恢复最近一次的暂存git pull # 抓取远程仓库所有分支更新并合并到本地git push origin master # 将本地主分支推到远程主分支 git add 和 git stage 有什么区别？其实，他们两是同义的，所以，惊不惊喜，意不意外？这个问题竟然是个陷阱…引入 git stage 的原因其实比较有趣：是因为要跟 svn add 区分，两者的功能是完全不一样的，svn add 是将某个文件加入版本控制，而 git add 则是把某个文件加入暂存区，因为在 git 出来之前大家用 svn 比较多，所以为了避免误导，git 引入了git stage，然后把 git diff –staged 做为 git diff –cached 的相同命令。基于这个原因，我们建议使用 git stage 以及 git diff –staged。 git reset、git revert 和 git checkout 有什么区别？首先是它们的共同点：用来撤销代码仓库中的某些更改。然后是不同点：首先，从 commit 层面来说：git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset 还支持三种标记，用来标记 reset 指令影响的范围。git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。 然后，从文件层面来说：git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 –mixed、–soft 和 –hard。git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。git revert 不支持文件层面的操作. 参考资料 面试中的那些 Git 问题 - 基础部分 git常见面试题","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"如何删除GitHub中的目录?","slug":"如何删除GitHub中的目录?","date":"2018-06-30T20:35:01.000Z","updated":"2018-11-18T20:23:53.142Z","comments":true,"path":"2018/06/30/如何删除GitHub中的目录?/","link":"","permalink":"http://yoursite.com/2018/06/30/如何删除GitHub中的目录?/","excerpt":"","text":"如何删除GitHub中的目录？ 有时候错误上传目录到GitHub上，需要删除。只需要执行以下步骤： git clone 你的文件路径 ls -la git rm -r --cached 要删除的文件夹 git commit -m &#39;删除了target&#39; //提交,添加操作说明 git push -u origin master 将本次更改更新到github项目上去 关于git rm -r --cached中的“cached”参数，经查阅StackOverflow，解释如下： git rm on the other hand removes a file from the working directory and the index and when you commit, the file is removed from the tree as well. git rm –cached however removes the file from index alone and keeps it in your working copy. This is the exact opposite of git add file In this case, you made index to be different from the HEAD and the working, in it that the HEAD has the previously committed version of the file, working copy had the las modification if any or content from HEAD of the file and you removed the file from the index. A commit now will sync the index and tree and the file will be removed. 参考资料 “git rm –cached x” vs “git reset head — x”?","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git删除远程仓库文件夹或文件的方法","slug":"Git删除远程仓库文件夹或文件的方法","date":"2018-06-20T14:59:21.000Z","updated":"2018-11-18T20:34:22.808Z","comments":true,"path":"2018/06/20/Git删除远程仓库文件夹或文件的方法/","link":"","permalink":"http://yoursite.com/2018/06/20/Git删除远程仓库文件夹或文件的方法/","excerpt":"","text":"Git删除远程仓库文件夹或文件的方法 背景：想删除一个git目录里的文件，当时提交了，但想删除master里的，怎么办？1234git rm -r -n --cached *git rm -r --cached *git commit -m &quot;移除src目录下所有文件的版本控制&quot;git push origin master 如下，我把src里的全部移除，但是本地文件还保留: git rm -r -n –cached /src/\\ //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。 git rm -r –cached /src/\\ //最终执行命令. git commit -m”移除src目录下所有文件的版本控制” //提交 git push origin master //提交到远程服务器 原文链接：http://www.cnblogs.com/xusir/p/4111723.html","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"macOS下安装及卸载MySQL","slug":"macOS下安装及卸载MySQL","date":"2018-06-12T14:24:17.000Z","updated":"2018-11-18T20:33:22.817Z","comments":true,"path":"2018/06/12/macOS下安装及卸载MySQL/","link":"","permalink":"http://yoursite.com/2018/06/12/macOS下安装及卸载MySQL/","excerpt":"","text":"一、安装 直接从官网down下来，我的macOS版本是10.13.5，使用的mysql版本是5.7.22。 无脑下一步，切记要记住初始时候设置的root密码。如果跟我一样不记得，请参考第三部分。 启动mysql：在MAC中的System Preference里，最后一栏，可以启动和停止mysql，也可以设置开机自动启动。 使用terminal操作mysql： 为Path路径附加mysql的bin目录：PATH=&quot;$PATH&quot;:/usr/local/mysql/bin 登录mysql：mysql -u root -p 你的密码 二、卸载卸载比较麻烦，在terminal下输入以下命令： 123456789sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig //执行完上面命令后使用的是Vim指令，复制上述命令，保存，退出即可。继续完成下列指令：rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* 最后打开系统偏好设置，最下方MySQL图标消失。 三、 忘记密码 击系统偏好设置-&gt;最下边点MySQL，在弹出页面中，关闭服务 进入终端输入 cd /usr/local/mysql/bin/ 切换为管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 继续输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES 回车后，输入命令 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;你的新密码&#39;); 密码设置成功！ 四、参考资料 Mac OS X下完全卸载MySQL mac 安装mysql详细教程","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"},{"name":"MySQL","slug":"Database/MySQL","permalink":"http://yoursite.com/categories/Database/MySQL/"},{"name":"Development","slug":"Database/MySQL/Development","permalink":"http://yoursite.com/categories/Database/MySQL/Development/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"Maven常用构建命令","slug":"Maven常用构建命令","date":"2018-06-03T18:05:11.000Z","updated":"2018-11-18T20:26:26.273Z","comments":true,"path":"2018/06/03/Maven常用构建命令/","link":"","permalink":"http://yoursite.com/2018/06/03/Maven常用构建命令/","excerpt":"","text":"Maven常用构建命令 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 mvn -v:查看版本 mvn compile mvn test mvn package mvn clean：删除target mvn install：安装jar包到本地仓库中","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"MAC下安装并配置Maven","slug":"MAC下安装并配置Maven","date":"2018-06-03T12:14:33.000Z","updated":"2018-11-18T20:27:18.081Z","comments":true,"path":"2018/06/03/MAC下安装并配置Maven/","link":"","permalink":"http://yoursite.com/2018/06/03/MAC下安装并配置Maven/","excerpt":"","text":"下载Maven打开Maven官网下载页面：http://maven.apache.org/download.cgi下载:apache-maven-3.1.0-bin.tar.gz。解压下载的安装包到某一目录，比如：/Users/xxx/Documents/maven 配置环境变量打开terminel输入以下命令：vim ~/.bash_profile 打开.bash_profile文件，在次文件中添加设置环境变量的命令 12export M2_HOME=/Users/xxx/Documents/maven/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 添加之后保存并推出，执行以下命令使配置生效：source ~/.bash_profile 查看配置是否生效terminal输入：mvn -v命令，输出如下： Maven 3.1.0 (893ca28a1da9d5f51ac03827af98bb730128f9f2; 2013-06-28 10:15:32+0800)12345Maven home: /Users/***/Library/MavenJava version: 1.*.*_40, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jreDefault locale: en_US, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.13.4\", arch: \"x86_64\", family: \"mac\" 则表示配置成功。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"鸟哥Linux私房菜学习笔记（二）","slug":"鸟哥Linux私房菜学习笔记（二）","date":"2018-05-23T15:50:30.000Z","updated":"2018-11-18T20:38:08.958Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（二）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（二）/","excerpt":"","text":"##什么是挂载？挂载的用途是什么？书上讲的挂载不是很清楚，在网络上搜索后，对挂载有了较为深刻的理解，在此总结如下。 在Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。 Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给Linux的所有区都在/下的某个位置，比如/home等等。 提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。 我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。 这时提问者使用了mount /dev/sdb1 ~/Share/，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。 所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。 Linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ 这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。 插入CD，系统其实自动执行了mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理 ##参考资料 Linux学习笔记（二）：什么是挂载？mount的用处在哪？","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"鸟哥Linux私房菜学习笔记（一）","slug":"鸟哥Linux私房菜学习笔记（一）","date":"2018-05-23T15:39:11.000Z","updated":"2018-11-18T20:37:46.301Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（一）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（一）/","excerpt":"","text":"之前把这本书看过一遍，但是时间一长就忘记了。在此review一遍，准备秋招，又能加深理解。虚拟机：VMware物理机版本：macOS10.13.4Linux版本：CentOS7.0 64位虚拟机配置：20G硬盘，2GB内存 ##基础知识及常用命令 Linux默认提供6个terminal来让用户登录，切换的方式为：CTRL+ALT+F1~F6。F7切换为图形界面。 Linux系统对字母大小写敏感。 显示时间和日期的命令：date 显示日历的命令：cal 计算器：bc 常用的关机命令：shutdown； shutdown -h 20:00是指在晚上8点钟关机；shutdown -h now是指立刻关机。 ##注意事项 VMware虚拟机进入BIOS：开机按F2键 安装时需自定义分区 ##参考资料 Linux学习笔记(一)：Win10上用VMware虚拟机安装Linux-CentOS","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"七牛云qshell使用教程","slug":"七牛云qshell使用教程","date":"2018-04-22T12:44:56.000Z","updated":"2018-11-18T20:32:05.181Z","comments":true,"path":"2018/04/22/七牛云qshell使用教程/","link":"","permalink":"http://yoursite.com/2018/04/22/七牛云qshell使用教程/","excerpt":"","text":"###1.下载qshell本人使用的是MAC，官网开发者工具处下载的qshell无法运行，但是可以从Github下载qshell，修改名称为qshell,并运行。 ###2.修改权限如果在Linux或者Mac系统上遇到Permission Denied的错误，请使用命令chmod +x qshell来为文件添加可执行权限。 ###3.修改路径将qshell复制到/usr/local/bin/目录下。使其在terminal下能够直接被调用。 ###4.配置账户 配置access key和secret key：qshell account AK SK 查看当前key：qshell account ###5.常用命令|命令|类别|描述|详细||——|————|———-|——–||account|账号|设置或显示当前用户的AccessKey和SecretKey|文档||dircache|存储|输出本地指定路径下所有的文件列表|文档||listbucket|存储|列举七牛空间里面的所有文件|文档||prefop|存储|查询七牛数据处理的结果|文档||fput|存储|以文件表单的方式上传一个文件|文档||rput|存储|以分片上传的方式上传一个文件|文档||qupload|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（配置式）|文档||qupload2|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（命令式）|文档||qdownload|存储|从七牛空间同步数据到本地，支持只同步某些前缀的文件，支持增量同步|文档||stat|存储|查询七牛空间中一个文件的基本信息|文档||delete|存储|删除七牛空间中的一个文件|文档||move|存储|移动或重命名七牛空间中的一个文件|文档||copy|存储|复制七牛空间中的一个文件|文档||chgm|存储|修改七牛空间中的一个文件的MimeType|文档||chtype|存储|修改七牛空间中的一个文件的存储类型，支持普通存储（0）和低频存储（1）|文档||expire|存储|修改七牛空间中的一个文件的生存时间|文档||fetch|存储|从Internet上抓取一个资源并存储到七牛空间中|文档||sync|存储|从Internet上抓取一个资源并存储到七牛空间中，适合大文件的场合|文档||prefetch|存储|更新七牛空间中从源站镜像过来的文件|文档||batchdelete|存储|批量删除七牛空间中的文件，可以直接根据listbucket的结果来删除|文档||batchchgm|存储|批量修改七牛空间中文件的MimeType|文档||batchchtype|存储|批量修改七牛空间中的文件的存储类型，支持普通存储（0）和低频存储（1）|文档||batchexpire|存储|批量修改七牛空间中的文件的生存时间|文档||batchcopy|存储|批量复制七牛空间中的文件到另一个空间|文档||batchmove|存储|批量移动七牛空间中的文件到另一个空间|文档||batchrename|存储|批量重命名七牛空间中的文件|文档||batchsign|存储|批量根据资源的公开外链生成资源的私有外链|文档||batchstat|存储|批量查询七牛空间中文件的基本信息|文档||privateurl|存储|生成私有空间资源的访问外链|文档||saveas|存储|实时处理的saveas链接快捷生成工具|文档||reqid|存储|七牛自定义头部X-Reqid解码工具|文档||buckets|存储|获取当前账号下所有的空间名称|文档||domains|存储|获取指定空间的所有关联域名|文档||qetag|存储|根据七牛的qetag算法来计算文件的hash|文档||m3u8delete|存储|根据流媒体播放列表文件删除七牛空间中的流媒体切片|文档||m3u8replace|存储|修改流媒体播放列表文件中的切片引用域名|文档||cdnrefresh|CDN|批量刷新cdn的访问外链或目录|文档||cdnprefetch|CDN|批量预取cdn的访问外链|文档||b64encode|工具|base64编码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||b64decode|工具|base64解码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||urlencode|工具|url编码工具|文档||urldecode|工具|url解码工具|文档||ts2d|工具|将timestamp(单位秒)转为UTC+8:00中国日期，主要用来检查上传策略的deadline参数|文档||tms2d|工具|将timestamp(单位毫秒)转为UTC+8:00中国日期|文档||tns2d|工具|将timestamp(单位100纳秒)转为UTC+8:00中国日期|文档||d2ts|工具|将日期转为timestamp(单位秒)|文档||ip|工具|根据淘宝的公开API查询ip地址的地理位置|文档||unzip|工具|解压zip文件，支持UTF-8编码和GBK编码|文档||alilistbucket|第三方|列举阿里OSS空间里面的所有文件|文档|","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"七牛云","slug":"七牛云","permalink":"http://yoursite.com/tags/七牛云/"}]},{"title":"尾调用及其优化","slug":"尾调用及其优化","date":"2018-04-04T01:31:21.000Z","updated":"2018-11-18T20:25:38.750Z","comments":true,"path":"2018/04/03/尾调用及其优化/","link":"","permalink":"http://yoursite.com/2018/04/03/尾调用及其优化/","excerpt":"","text":"之前一直对尾调用相关概念比较模糊，在此做一个总结。 一、 什么是尾调用尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。function f(x){ return g(x); }上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下两种情况，都不属于尾调用。 // 情况一function f(x){ let y = g(x); return y;}// 情况二function f(x){ return g(x) + 1;}上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x &gt; 0) { return m(x) } return n(x);}上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 二、 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3);上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。 三、 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5) // 120上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1) // 120对于以上的阶乘，由于递归在方法的末尾，因此方法中的局部变量已经毫无用处，编译器完全可以将其“复用”，并把尾递归优化为“循环”方式。由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 四、递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}function factorial(n) { return tailFactorial(n, 1);}factorial(5) // 120上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 function currying(fn, n) { return function (m) { return fn.call(this, m, n); };}function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5) // 120 五、参考资料 尾调用优化 浅谈尾递归的优化方式","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"recursive","slug":"recursive","permalink":"http://yoursite.com/tags/recursive/"}]},{"title":"MAC下Homebrew的安装及使用","slug":"MAC下Homebrew的安装及使用","date":"2018-04-02T15:19:03.000Z","updated":"2018-11-18T20:28:24.927Z","comments":true,"path":"2018/04/02/MAC下Homebrew的安装及使用/","link":"","permalink":"http://yoursite.com/2018/04/02/MAC下Homebrew的安装及使用/","excerpt":"","text":"##1. 什么是什么是HomebrewHomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebrew可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 ##2. Homebrew的安装Homebrew的安装很简单，只需在终端下输入如下指令：ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序。 这时你在命令行状态下面就可以使用 brew 命令了。 ##3. Homebrew的使用 安装软件：brew install 软件名，例：brew install wget 搜索软件：brew search 软件名，例：brew search wget 卸载软件：brew uninstall 软件名，例：brew uninstall wget 更新所有软件：brew update 更新具体软件：brew upgrade 软件名 ，例：brew upgrade git 显示已安装软件：brew list 查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git 查看那些已安装的程序需要更新： brew outdated 显示包依赖：brew reps通过 update 可以把包信息更新到最新，不过包更新是通过git命令，所以要先通过 brew install git 命令安装git。 ##4. 参考资料 【工具】Homebrew的安装及使用","categories":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/categories/Mac/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://yoursite.com/tags/homebrew/"}]},{"title":"比特币与区块链","slug":"比特币与区块链","date":"2018-03-23T23:23:18.000Z","updated":"2018-11-18T20:36:41.843Z","comments":true,"path":"2018/03/23/比特币与区块链/","link":"","permalink":"http://yoursite.com/2018/03/23/比特币与区块链/","excerpt":"","text":"I learned the basic ideas of bitcoin and blockchain in the computer security class last week, so I just write a summary here. ##1.LedgerFirstly, let’s talk about the ledger. Why use a ledger? If you exchange money with some people very frequently, using a ledger is better than cash. So you guys can create a ledger and record all the transactions. For example, Alice, Bob, Charlie and you. You can see some records in the ledger as below:Alice pays Bob $20Bob pays Charlie $40Charle pays you $30You pay Alice $10 This ledger is public, everybody could add new records in it. In the end of every moth, people will look at the list of records and settle up.As above description, the protocol is pretty simple: Anyone could add records to the Ledger; Settle up with US dollars every moth; However, there is a problem of the protocol. Anyone can add a new transaction if he/she want. For example, Alice can add a record that Bob pays Alice $200 without telling Bob. How to solve this problem? ##2.Digital SignatureIn the real world, we can sign our name at the end of every transaction. The signature could prove we already have seen it and approve it. In the computer world, we should use digital signature. The digital signature leverages hash function. There is an example as below: Transaction Signature Alice pays Bob $20 Signature1=hash(“Alice pays Bob $20”) Bob pays Charlie $40 Signature2=hash(“Bob pays Charlie $40”) Bob pays Charlie $30 Signature3=hash(“Bob pays Charlie $30”) There is a crucial problem. As the handwritten signature, a digital signature could be forged. Actually, the digital signature is a string of bits, people could copy it. So it cannot prevent forgeries. How to prove the signature’s owner? ##3.Public-key CryptoWhat is Public-key cryptography? You can click the hyperlink to see the details. To solve the problem as above, the basic idea is: Get the hash value by hash fuction (SHA-256);HashValue=SHA-256(OriginalRecord) Alice use her own private key to encrypt the hash value generated before;Signature=Sign(HashValue,PrivateKey) Anyone could use Alice’s public key to decrypt the signature and compare the result with original record. This process is called signature verify, the result is true or false;Result(T/F)=Verify(OriginalRecord,Signature,PublicKey) If the result is true, it means: This signature belongs to this record; This signature belongs to Alice; This record is not modified by others; However, there is another problem: even though other people cannot forge Alice’s signature, but they can copy a whole record to a new line. Luckily, there is a solution: add an unique sequence number to every record. Until now, the protocol looks like below. Anyone could add records to the Ledger; Settle up with US dollars every moth; Only signed transactions are valid; It seems perfect, but there must be some people break the rules. So we must rely on some honor system. In the paper “Bitcoin: A Peer-to-Peer Electronic Cash System”, the author proposed “peer-to-peer”. It means that it shouldn’t be a central system in the protocol. If Bob owes a lot of money and runs away, how to handle this problem? The protocol should be changed as below: Anyone could add records to the Ledger; No overspending; Only signed transactions are valid; In theory, if all people in the world was using this ledger, people could live their whole life just sending and receiving money on this ledger without real US dollars. So the ledger should be placed in a public place, such as a website where anyone can add new records. But who host the website? As I described above, we cannot use a central system, but we can have everybody hold their own copy of ledger. In the network, if someone makes a transaction what he/she does it broadcast that out into the whole network. According to this approach, how could you get everyone to agree on what the right ledger is? how to make everyone received and believes that transaction? how to add the transactions in the ledger if you received them together? ##4.Bitcoin&amp;BlockchainFor a hash function like SHA-256, whatever you put into it, the result is a 256 bits string. What the miners do is that they find a number add into the ledger, and then use SHA-256(ledger+number) to get a result. The result first 30 bits are “0”! But find the number is very very hard. The only way to find the special number is guessing and checking. So the miner has to go through about a billion different numbers before finding the special one. But the verify process is much easier. The process that people find the number is called “proof of work”. Let’s go back the distributed ledger situations. In the whole network, there are many copies of ledger, every copy is a block. And in each block, it contains a list of transactions(records) with a proof of work(special number). A block is only considered valid if it has a proof of work. But how the next transactions know the previous transactions that use to make sure someone has enough money to pay? We make a block has to contain the hash of the previous block at its header, it means every transaction should base on the previous transactions. It looks like a blockchain. In the blockchain, anyone could be a block creater. The creator is going to listen for transactions being broadcast, collect into some block, and then computes the special number that makes the hash of that block start with N zeros. Once he/she find it, just broadcast out the block he/she found. To reward a bloack creator for all this work, when the creator puts together a block, we allow he/she to include a very special transaction at the top of it, it is called block reward. It means the total number of bitcoin in our economy increases with each block. The process of creating blocks is called “mining”, the creator called “miner”. what the miner did is listening for transactions, creating blocks, broadcasting those blocks, and getting rewarded with new money for doing so. The miner’s computer more powerful, the high possibility they have. However, if someone receive two blocks at the same, what should he does? The solution is that he just makes a branch and keep both of them, and waits for the next block. It is hardly to receive two blocks at the same time. If receive, just wait for the third block. After that, he/she just selects the longer branch and discard the other one. ##5.Techniques Leverage SHA-256 hash function and public-key crypto to generate digital signature Save the transactions by blocks of blockchain Protect the bitcoin network and control the average block time by setting extra works Incent miner to increase the network Transactions of bitcoin don’t rely on bank or other honor system ##6.Tips The Average Block Time is about 10 minuetes The total number of bitcoin is less than 21 million GPU mining is faster than CPU mining. Block Reward: 12.5 BTC (2017) Transaction Fee: average 2 BTC (2017) Average income of one block: 14.5 BTC = 260 thousand USD = 1.7 million USD To maintain the average block time, the bitcoin network upgrade the degree of difficulty every two weeks Bitcoin is saved in your bitcoin client ##7.Reference Ever wonder how Bitcoin (and other cryptocurrencies) actually work? 比特币的原理","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"concepts","slug":"concepts","permalink":"http://yoursite.com/tags/concepts/"}]},{"title":"Markdonw语法","slug":"Markdown语法","date":"2018-01-05T14:40:51.000Z","updated":"2018-11-18T20:24:42.831Z","comments":true,"path":"2018/01/05/Markdown语法/","link":"","permalink":"http://yoursite.com/2018/01/05/Markdown语法/","excerpt":"","text":"1.标题标题共有六级。“#”数量代表标题级数。 一级标题 # text 二级标题 ## text 三级标题 ### text … 2.列表 有序列表:1. text2. text3. text 无序列表：* text* text 3.引用只需要在需要引用的文本前加入 “&gt;” 这种尖括号（大于号）即可。&gt; text This is a reference. 4.图片与链接插入链接与插入图片的语法很像，区别在一个”!”号。 图片为：![]() 链接为：[]()My Blog 5.粗体与斜体在文本前加入**text**，即为粗体， *text*即为斜体。注意，星号间不能有空格。 这是 粗体 ，这是 斜体。 6.分隔线分隔线只需要三个星号，像这样***。 我上面和下面都是分隔线。 7.表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 8.代码框代码框只需要用包裹文字即可。用TAB缩进。 参考 Markdown——入门指南 Learning-Markdown","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"markdonw","slug":"markdonw","permalink":"http://yoursite.com/tags/markdonw/"}]}]}