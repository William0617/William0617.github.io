{"meta":{"title":"William's Blog","subtitle":"SDET (Software Development Engineer in Test)","description":"Keep moving. Don't settle.","author":"William Sun","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-11-18T18:31:43.000Z","updated":"2018-11-21T01:24:41.921Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于学历 学士： 北京科技大学世界第一的冶金工程 北京大学软件工程 硕士： 美国宾夕法尼亚州立大学计算机科学与工程 关于工作 地点：上海 公司：某AI厂测试开发工程师（待入职） 关于运动 2012年完成丽江-拉萨段滇藏线骑行 2013年完成环台湾岛骑行 关于爱好 四国军棋菜鸡 Youtube重度用户 现实的浪漫主义者 关于项目 国密SM2云加密机 [加密/解密，签名/验签]（https://ci.idsmanager.com:8888/EDES/） 关于未来在上海，有辆车，有套房，有个它，再有个她。"},{"title":"categories","date":"2018-03-02T17:33:16.000Z","updated":"2018-11-18T20:55:38.334Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-02T17:33:16.000Z","updated":"2018-11-18T20:55:36.697Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"海外计算机系留学生2018秋招总结-已拿某AI独角兽offer","slug":"海外计算机系留学生2018秋招总结-已拿某AI独角兽offer","date":"2018-11-19T23:04:44.000Z","updated":"2018-11-20T04:08:56.089Z","comments":true,"path":"2018/11/19/海外计算机系留学生2018秋招总结-已拿某AI独角兽offer/","link":"","permalink":"http://yoursite.com/2018/11/19/海外计算机系留学生2018秋招总结-已拿某AI独角兽offer/","excerpt":"","text":"我本次秋招的基本需求如下： 目标地点：上海； 目标公司：较大的互联网公司； 目标岗位：Java后台开发； 目标薪酬：年薪30W以上；从六月份开始准备秋招，一直到十一月份拿到满意的offer结束。前前后后一共历时五个半月，下面就每个月的状态和进展进行总结。 六月五月份暑假回国，6月份回家开始准备秋招。开始的时候看到网上的攻略，于是买了书看了一个月基础。这份书单主要是依据Java后台开发工程师秋招攻略2018Fall中列出的材料进行复习。先看了Java基础，然后在网上看了一些Java培训班的视频，记了两本笔记。这样做的结果就是：卵用没有。基础太过庞杂，即便是大佬，没有时间实践，就变成了纯纯的死记硬背。看一遍绝对会忘记，即便是记了笔记。于是在思考后，七月份便改变了战术。 七月战术调整后，了解到国内刷题都用牛客网，于是就在牛客网开始做题。既然做题，就跟着牛客网的顺序来吧，他有个java工程师学习路线，先做的是Java基础的选择题，然后是算法与数据结构的选择题。前前后后做了1580道，后来我觉得这些题在笔试中没有什么用。后来月底的时候，买了牛客网的《BAT算法题精讲》课程，跟着老师一步一步复习和做算法题，感觉终于上了正轨。这个月期间，京东和Thoughtworks，阿里巴巴和拼多多开启了秋招，虽然没有做完题，但是还是投递了简历。 八月八月继续跟着网课做题，所有题都是自己憋出来，不看答案，十分耗时。八月上旬回到美国，基本没怎么学习。20号以后上课了，也收心了，继续做题。在这期间，收到银联，京东，中央结算中心和爱奇艺的面试邀请，都是现场面。无奈，只好错过。与此同时，也投递简历。例如，贝壳找房，携程网，美团，触宝，平安科技等等。 九月九月是真真正正学习的一个月。这个月除了把网课题做了，也在牛客网做了些剑指offer和其他的编程题，前后加一起170多道吧。另外，把牛客各个企业的java岗的面经都做了一遍，并且记录。其实要是对以上的知识完全掌握，我觉得对国内的岗位完全可以了。但是问题在于刷完后面的，肯定会忘记前面的。收到的平安科技，中汇，阿里，美的和小红书的面试。又去了趟Pittsburgh的CMU招聘会，主要是冲着京东去的，结果很恶心。至此，战线已经四个月，身心俱疲。国内的提前批小伙伴已经手握数个offer，心里很方。 十月十月开始就有些自暴自弃、破罐破摔了。主要是被国内某些公司刺激的，再加上课业压力。这个月基本没怎么准备面试题和算法题。阿里有个面试官要给我个intern，被我拒绝。然后过几天阿里给我打电话，由于时差无法接通，回电话是主机号，无法拨通。阿里无疾而终。前前后后，阿里三次面试吧。然后又面了个创业的AI公司，2次技术，1次HR面，聊的很好，顺利拿到offer。这个公司的优点是里面都是高学历和留学生，不加班，福利不错，北京上海也可以选择地点，岗位是想要的后台开发。缺点是，对于应届生第一份工作的平台很重要，创业公司平台不够；其次是薪水与我预期有小几万的差距。但是无论如何，拿到了offer，心里还是很开心的。 十一月这个月国内规模大一点的公司的秋招已经接近尾声，补招很多。刷着牛客网的论坛，看着国内的小伙伴至少都拿了5，6个offer，又羡慕又难受。下了个猎聘APP，很多猎头找到我帮我推岗位，于是拿到了3个面试。头条的补招，还有个车企的智能汽车部门的Java后台，还有个AI公司的测试开发岗。由于可恶的时差，所有的面试都是晚上，连续两天，并且两个面试连起来都是3小时以上，极其痛苦。两天苦战，终于拿到的offer，虽然是AI公司的测试开发岗，但是地点、薪水、公司规模完全符合我的预期，缺点是加班严重。但是作为一个年轻人，加几年班又算得了什么呢？这世界上哪有钱又多、不加班的好公司。若是有，也轮不到我把。至此，11月15日，持续五个半月的漫长秋招结束。 总结1. 海外留学生找工作的痛点在美国找国内的工作是真的难，非常难。绝大多数企业对留学生是不友好的，也可以说很多企业并没有考虑留学生群体。这也很好理解，我要是老板，一样的薪水，不如找几个国内985硕士，又能加班，屁事又少，招聘成本又低，沟通顺畅及时，还能来实习。所以对于留学生来说，身在国外找国内工作有很多痛点： 时差。这个最要命，很多国内HR都联系不到你，并且很多留学生在海外没有国内电话，有些HR不会打海外电话；即便打通了，在美国也是后半夜，一个学期下来就会跟我一样神经衰弱。还有就是，基本笔试都是美东早上6-7点钟，网易两次笔试都是美东凌晨2点，不得不错过了很多笔试。 距离。宣讲会，面试和沟通只能用邮件沟通。国内很多公司都是用第三方面试平台通知，如果想联系HR，那么抱歉，联系不到。另外，最气的是，很多企业把笔试当儿戏吧，宣讲会去了把笔试当抽奖，我这种老老实实投简历、做笔试的学生真的心寒。 课业压力。听说美西那边高校课没有我们这么多，并且我们还有background courses。特别坑。1年半上了13门课，都是400和500的硬课。国内的研究生找工作时，都没有课了。这跟人家比就有很大的劣势。 国内招聘很佛系。有的公司，你觉得面试的不错，他把你挂了；你答的不太行的，反而过了。与此同时，与美国注重算法相比，国内考的体系更为庞杂：算法与数据结构，数据库，语言特性，项目，Linux，计算机网络等等。 2. 秋招遇到的坑2.1 我遇到的坑*公司 京东。这是最坑的。8月份拿到上海现场面试的通知，去不了，发邮件不理我，也没有电话。然后等到9月，说有海外招聘，并且说拿到国内面试的同学可以直接优先安排面试。于是我和俩同学就兴奋地区他们的招聘地点，CMU。我们翘了课，租了车，订了住宿，然后到CMU人家说外校的人不让参加宣讲会。我们找同学又求人，终于在快散场的时候进去和京东HR搭上话了。当时他们给我们的态度是非常重视，会给我们安排远程面试。结果两个月过去了，一个屁都没有。十分失望。 赛可出行。这个公司HR怼人很厉害。招聘简章上写，可以提供远程/现场面试。结果开始时候要给我远程，后来说公司只给非技术岗远程。我于是回信说希望贵公司在招聘简章中写清楚细节。HR回信怼我，让我在简历里标注好坐标是不是国外。我就很纳闷，我上面教育经历上明明写着美国xxx大学，2017年8月至今。真的是服了。国内HR素质参差不齐，希望未来找工作的小伙伴们一定注意。 字节跳动（今日头条）。补招视频面试。那个面试官说话极快，听不太清；并且行为很轻浮，估计面我的时候不是在听歌就是工作，不在会议室，就在他工位，我觉得没有给我以尊重。 小红书。前期HR说给我发具体视频面试安排了，但是我没收到。毕竟应届生是弱势群体，我只能承认我的”错误“，希望人家再给次机会。到了视频面试阶段，那个面试官自称全栈工程师，给我甩了一道算法题。我很开心，当时那道题我前几天做过，还参考了牛客网一个同学的一种简单方法。我就原模原样写了上去。他就说我的代码不能跑。然后我跟他犟了几句，估计就把我挂了。 2.2 如果再准备一次，该如何准备？ 首先我会先刷题。把《剑指offer》刷的滚瓜烂熟。然后准备面经，网上前一年所有的后台开发的面经，自己做一遍，然后死记硬背！如果还有时间，在网上找个项目，自己独立把前端后台做一遍，po到github上。 搜索岗位。猎聘APP+校园招+牛客网。这些组合起来用，效果很好。 内推没用。国内内推很多都是免筛简历，我觉得我不至于简历都过不去。 2.3 秋招中需要注意的地方 HR问你能不能实习。国外留学生在读期间肯定不能回国实习。所以毕业后你去实习，实习完人家不要你，你时间耽误了，也没准备题，就等着GG吧。所以我建议，坚决不做intern，直接fulltime。除非特别牛逼的公司，比如google。 别拒offer。拒offer败人品。人家给你就接着，最后也有个比较。我拿到俩offer，都没有违约金。其实有违约金也没所谓吧，给自己多留条路。牛客上很多朋友被dream company坑了，然后又拒掉其他公司，极其痛苦。 找个朋友一起秋招。一起刷题，一起吃饭，一起讨论，一起鼓励。效果很好。孤军奋战很容易坚持不住。 2.4 最后的总结都说程序员工资高，但是他们只看见贼吃肉，没看见贼挨打。我观察了其他行业应届生的找工作情况，基本都先是HR随便问问，然后无领导小组讨论，最后领导面一下画画大饼。顶多加一轮行测笔试了不起。但是码农不同，尤其是对于海外留学生，毫无优势，跟大流投简历、做笔试。以上两次都过了，视频面试也很容易被挂掉。网上有个测试说，远程面试比现场面试挂掉概率更大。关于笔试，我想说，无论你斯坦福、CMU还是MIT的硕士，只要笔试不过，那就是挂你。丝毫展示不出名校光环，除非等着人才池被捞出来。最后，说几个数字。五个半月的秋招，我投的公司主要是上海互联网公司，大大小小加一起差不多50-60家，国企30-40家，小公司20-30家。所以一共投了大概100-130家。拿到面试通知的公司，大概有20-30个。给我远程视频面或者电话面的公司不到10个。这不到10个的公司中，我拿到2个offer。最后去一个。总而言之，以上攻略仅适用于我在2018秋招找工作的情况，我觉得以后的竞争会更加激烈。希望这篇文章能对未来找工作的小伙伴有一些借鉴意义。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"}],"tags":[{"name":"秋招总结","slug":"秋招总结","permalink":"http://yoursite.com/tags/秋招总结/"}]},{"title":"Java后台开发2018校招复习材料汇总","slug":"Java后台开发2018校招复习材料汇总","date":"2018-10-25T20:21:16.000Z","updated":"2018-11-20T21:22:23.321Z","comments":true,"path":"2018/10/25/Java后台开发2018校招复习材料汇总/","link":"","permalink":"http://yoursite.com/2018/10/25/Java后台开发2018校招复习材料汇总/","excerpt":"","text":"以下为Java后台开发2018校招复习材料汇总，均为本人整理。如有错误，欢迎批评指正。 1. 牛客网这个没什么说的，上面的《剑指offer》多刷几次。我还报了个《BAT算法班》。 2. 牛客网论坛前一年的所有面试题 Java基础知识总结 排序算法总结 Java集合框架知识点总结 Java多线程面经题总结 JVM知识点总结 牛客网Java面试常考知识点总结 面经算法题总结 数据库面经知识点总结 计算机网络常见面试题 Linux、Git、Maven、Jenkins、软件工程面经知识点总结 Java Web框架面经题（未整理） Java其他面经题（未整理） Java后台开发工程师秋招攻略2018Fall","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java","slug":"秋招/面试题/Java","permalink":"http://yoursite.com/categories/秋招/面试题/Java/"},{"name":"面经","slug":"秋招/面试题/Java/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java/面经/"},{"name":"汇总","slug":"秋招/面试题/Java/面经/汇总","permalink":"http://yoursite.com/categories/秋招/面试题/Java/面经/汇总/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"汇总","slug":"汇总","permalink":"http://yoursite.com/tags/汇总/"}]},{"title":"Java其他面经题（未整理）","slug":"Java其他面经（未整理）","date":"2018-10-19T01:11:43.000Z","updated":"2018-11-20T20:43:30.121Z","comments":true,"path":"2018/10/18/Java其他面经（未整理）/","link":"","permalink":"http://yoursite.com/2018/10/18/Java其他面经（未整理）/","excerpt":"","text":"介绍一下Syncronized锁。如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？答：Syncronized锁是同步锁，如果关键字修饰静态方法的话是一个类锁（当前类的所有线程都必须等待同步线程执行）， 如果关键字修饰成员方法的话是一个对象锁（当前对象的所有进程必须等待同步进程执行完，释放锁）。 Java线程面试题 Top 5040个多线程问题总结 多线程同步的方法?Java实现线程同步的几种方式 ConcurrentHashMap锁加在了哪些地方?彻头彻尾理解 ConcurrentHashMap 单例模式和多线程有关系吗？单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。一个单例模式创建的对象是可以同时被多个线程处理的，如果一个对象被多个线程同时处理的话，很有可能出现线程同步问题。一个单例模式的方法可以同时被多个线程处理，多个线程如果不是同时处理一个对象的共有属性，则不会出现线程问题，即使是方法中的属性如果两个线程同时访问同一个方法的时候，如果这个方法中没有共有的属性，则不需要加锁，反之则需要加锁。 说一说对Java io的理解？IO，其实意味着：数据不停地搬入搬出缓冲区而已（使用了缓冲区）。 Java并发的理解?Java是一种多线程编程语言，我们可以使用Java来开发多线程程序。 多线程程序包含两个或多个可同时运行的部分，每个部分可以同时处理不同的任务，从而能更好地利用可用资源，特别是当您的计算机有多个CPU时。多线程使您能够写入多个活动，可以在同一程序中同时进行操作处理。 Java如何实现线程安全？锁机制：synchronized，Lock；concurrent包：atomic，容器等。 Java中都有什么锁?隐式锁（并不需要显示的加锁和解锁的过程，所以称之为隐式锁）：synchroniezed；显示锁：Lock（ReentrantLock，ReentrantReadWriteLocK）；按照其性质分类：（1）公平锁/非公平锁（2）乐观锁/悲观锁：乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。（3）独享锁/共享锁（4）互斥锁/读写锁 CAS如何实现? 线程池原理?线程池的排队策略和拒绝策略的试用条件和具体内容。线程池的类型，详细介绍cached和fixed Java并发包里面的CountdownLatch怎么使用? 一般线程和守护线程的区别?他们两个是依赖关系。所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。 一致性Hash原理，实现负载均衡? 消息队列了解吗？通俗的说，就是一个容器，把消息丢进去，不需要立即处理。然后有个程序去从容器里面把消息一条条读出来处理。也就是你有一个程序在产生内容然后入队（生产者），另一个程序读取内容，内容出队（消费者）。也就是说当你不需要立即获得结果，但是并发量又不能无限大的时候，差不多就是你需要使用消息队列的时候。 多线程问题，有10个线程，每个线程作自增到10000，怎么保证不出错！ 两种锁的区别：synchronized、ReentrantLock？这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。 并发常用方法，一个方法创建多个线程，这样保证线程全部结束后再结束方法； 线程池有几种，工作队列可以重写嘛，java中什么类不可以重写； java中哪些类是线程安全的? java线程与操作系统中的线程有什么区别? jvm中堆内存泄漏时怎么定位到导致内存泄漏的代码? 异步队列的实现 你老家是哪里的，工作地点在北京接受吗，你实习主要做什么，学到了什么，项目里面的登陆验证是怎么做的，验证码的模块是你自己写的还是用的开源的，session和token， 分布式集群， redis有什么数据类型，redis里面的zset和set有什么区别，底层怎么实现的，redis的List能用做什么场景，注解的原理，拦截器的原理，对IoC和AOP的理解，AOP有什么用处，除了日志和事务管理你还知道他的其他用途吗，AOP的原理，动态代理有哪几种实现方式，JDK动态代理有哪几个类，有什么参数，看过什么的源码，怎么看的，知道正则表达式吗，正则表达式的group有什么用，数据库用的是mysql吗，索引了解吗，B+树的工作原理是什么，全文索引知道原理和数据结构吗，倒排索引知道吗，给你设计一个搜索系统你要怎么设计，elasticSearch了解吗，java多线程了解吗，线程池用过吗，原理知道吗，让你设计一个数据库连接池你需要对数据库连接进行怎么样的封装，要设计哪些模块，怎么解决长时间无操作服务器把某连接置为不可用但是客户端还是以为是可用的问题，Java的并发包下面的用过哪些，AtomicInteger有什么特性，底层是怎么实现的知道吗，CAS是什么介绍一下，ConcurrentHashMap了解多少，说下工作原理，怎么解决哈希冲突，红黑树了解吗，数据结构没有学过吗，那你知道平衡二叉树吗，有什么特性，插入是怎么插入的，和二叉查找树相比效率有什么差别，Java中的锁知道多少，平常看什么书，有计划吗，怎么看的，中途还穿插了负载均衡和设计模式的小问题。 JUnit知道吗，写你知道的命令解释运行字节码程序 消除平台相关性。jvm将java字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，至少需要编译成不同的目标代码。而引入JVM后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 请求失败怎么办，加锁失败怎么办，回滚失败怎么办。 公平锁和非公平锁的区别。 问我对Java7、8的新特性有什么了解 死锁，写一个死锁的例子 进程间通信是怎么实现的（我回答了信号量，共享内存，无名管道，命名管道，消息队列），然后让我详细说一下用管道是怎么实现的 ConcurrentHashMap 1.7和1.8的实现有什么不同。 泛型在编译期和运行期的作用。 线程池是如何创建的？需要几个参数？分别是什么含义？ 乐观锁和悲观锁的实现。（数据库、Java） CAS syncronized实现有什么区别。 讲一下线程池工作原理，结合源码来谈 Java 10 对象内存布局，然后讲下对象的死亡过程？ 一致性哈希是干嘛的？ 线程池，如何设计的，里面的参数有多少种，里面的工作队列和线程队列是怎样的结构，如果给你，怎样设计线程池？ AQS原理，ReentranLock源码，设计原理，整体过程。 怎么认为一个类是线程安全？线程安全的定义是什么？Java有多少个关键字进行同步？为什么这样设计？ 两个线程设计题。记得一个是：t1,t2,t3，让t1，t2执行完才执行t3，原生实现。 写个后缀表达式，为什么要设计后缀表达式，有什么好处？然后写下中缀。 把所有认识熟用的JUC下的类写出来，讲下使用，然后讲下原生的线程操作 涉及OOM、JVM优化、源码问题、数据库优化、多线程等问题 cyclicbarrier和countdownlatch的区别 如何判断一段代码的好坏 锁机制 描述一下微信支付的过程 文件上传 线程共享进程哪些资源？ 说说es分词算法 es倒排索引；es分词选型。ik分词器 bio和nio 如何保证集群环境下抢购的并发安全？如何设计一个定时器定时完成某个任务？ kafka的作用 java原子类使用和实现原理 netty是什么？netty可以干什么?有哪些优点? 可重入锁的设计思路是什么 常问的知识点总结 多个用户抢购同一件商品，如何保证不会出错。——乐观锁， 了解连接池吗 MySQL你了解些什么？索引（聚簇、非聚簇、最左匹配），范式，explain,processlist指令，慢查询日志等 lock的源码实现?多线程中断的原理?数据库索引的实现原理 kafka的topic、partion能解释一下吗 线程池的几种实现你知道吗？ 线程是不是越多越好，一般设置多少个?电脑CPU为4…。适合设置多少个线程 线程里面有什么是独立的？ synchronize 与reentralock哪个是公平锁 如果 fork() 的父進程掛了，那麼子進程還會存在嗎 分别介绍一下NIO,AIO,BIO(非阻塞，同步非阻塞，阻塞) 微信紅包，隨機算法怎麼分？ 什么是restful String a = “abc” + “def”在jvm中有几个对象 如何在秋招拿到offer的？ 悲观锁和乐观锁，应用中的案例，mysql当中怎么实现，java中的实现 CurrentHashMap的特点和实现原理（按源码讲） ReentrantLock的底层实现机制（讲源码） 使用Iterator遍历HashMap，删除值为a的元素会发生什么？快速失败：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。 怎么解决你这个系统高并发的问题?我说可以用负载均衡来平衡流量，扩大服务器规模，面试官说你数据库服务器不要处理嘛，我赶紧补了一句可以用缓存 IO流熟悉吗，用的什么设计模式。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java Web","slug":"秋招/面试题/Java-Web","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/"},{"name":"面经","slug":"秋招/面试题/Java-Web/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/面经/"},{"name":"未整理","slug":"秋招/面试题/Java-Web/面经/未整理","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/面经/未整理/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/tags/Java-Web/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"未整理","slug":"未整理","permalink":"http://yoursite.com/tags/未整理/"}]},{"title":"Java Web框架面经题（未整理）","slug":"JavaWeb框架面经题（未整理）","date":"2018-10-18T00:09:54.000Z","updated":"2018-11-20T20:40:15.812Z","comments":true,"path":"2018/10/17/JavaWeb框架面经题（未整理）/","link":"","permalink":"http://yoursite.com/2018/10/17/JavaWeb框架面经题（未整理）/","excerpt":"","text":"Spring MVC注解的优点 Spring MVC有了解嘛，Spring 事务有了解嘛 说一下IOC和AOP Java的反射机制? tomcat均衡方式? Spring IOC AOP?IOC:控制反转也叫依赖注入，IOC利用java反射机制。所谓控制反转是指，本来被调用者的实例是有调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。AOP是对OOP的补充和完善。AOP利用的是代理，分为CGLIB动态代理和JDK动态代理。OOP引入封装、继承和多态性等概念来建立一种对象层次结构。OOP编程中，会有大量的重复代码。而AOP则是将这些与业务无关的重复代码抽取出来，然后再嵌入到业务代码当中。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理. Spring IOC有哪些好处?降低了组件之间的耦合性 ，实现了软件各层之间的解耦. SpringMVC的运行流程?客户端发送HTTP请求到服务器SpringMVC的核心DispatcherServlet将请求交给HandlerMapping处理HandlerMapping通过查询机制找到处理当前请求的HandlerDispatcherServlet将请求交给这个Handler处理Handler处理完成后返回一个ModleAndView对象，这个对象包含视图逻辑名和数据对象返回的视图逻辑名会通过视图解析器解析成真正的视图，并交给DispatcherServlet处理DispatcherServlet将请求分派给真正的视图对象，并反映到客户端 说几个SpringMVC的几个注解，都是干啥的？@Controller：用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。@RequestMapping：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。@Resource和@Autowired：@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。@ResponseBody：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用。@Repository：DAO层@Service：服务层 autowired 和resource区别? 类加载机制loadclass和findclass使用，defineclass怎么用呢。 如何写一个自己的类加载器呢。 说说filter、servlet、listener。Listener我是这样理解他的，他是一种观察者模式的实现。Filter的使用户可以改变一 个request或修改一个response。 Filter 不是一个servlet,它不能产生一个response,但是他能够在一个request到达servlet之前预先处理request,也可以在一个响应离开 servlet时处理response。 @Autowired的实现原理 拦截器相关，属于哪个包 Servlet是线程安全的吗？ java中的类加载过程？ 说一下类加载器，自定义一个类加载器。 tomcat缓存，聊下缓存的整体理解，知道多少种缓存 spring的bean生命周期（详细）、作用域 聊下spring注解，@Autowire，@Resource，以及他们的解析过程 springioc的具体优势，和直接new一个对象有什么区别 什么情况下会触发类加载 拦截器和Spring AOP区别 @restcontroller和@controller的区别 依赖注入的方式有几种，哪几种 Mybatis和Hibernate的区别 Filter和Servlet先过哪个 web.xml里面一般配了哪些东西 一个url如何映射到controller的 你觉得Spring设计得最好的是？(答IOC,AOP) JVM加载.class文件的过程 SpringMVC 和 struts2 的区别。 了解正向代理和反向代理吗 拦截器底层实现原理 SpringMVC的底层原理和运行机制 SpringMVC的URL映射原理 SpringIOC底层原理 Class类了解吗 servlet流程? 介绍一下bean的生命周期? hibernate 和 mybatis 你觉得选哪个？原因？","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java Web","slug":"秋招/面试题/Java-Web","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/"},{"name":"面经","slug":"秋招/面试题/Java-Web/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/面经/"},{"name":"未整理","slug":"秋招/面试题/Java-Web/面经/未整理","permalink":"http://yoursite.com/categories/秋招/面试题/Java-Web/面经/未整理/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/tags/Java-Web/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"未整理","slug":"未整理","permalink":"http://yoursite.com/tags/未整理/"}]},{"title":"面经算法题总结","slug":"面经算法题总结","date":"2018-10-16T16:49:46.000Z","updated":"2018-11-20T20:35:51.813Z","comments":true,"path":"2018/10/16/面经算法题总结/","link":"","permalink":"http://yoursite.com/2018/10/16/面经算法题总结/","excerpt":"","text":"寻找一数组中前K个最大的数。 暴力破解：该解法是大部分能想到的，也是第一想到的方法。假设数据量不大，可以先用快速排序或堆排序，他们的平均时间复杂度为O(N logN),然后取出前K个，时间复杂度为O(K)，总的时间复杂度为O(NlogN)+O(K). 利用快排的划分：假设N个数存储在数组S中，从数组中随机找一个元素X，将数组分成两部分Sa和Sb。Sa中的元素大于等于X,Sb中的元素小于X。出现如下两种情况：(1)若Sa组的个数大于或等于K，则继续在sa分组中找取最大的K个数字。(2)若Sa组中的数字小于K，其个数为T，则继续在sb中找取K-T个数字。一直这样递归下去，不断把问题分解成小问题，平均时间复杂度为O(N*logK)。 利用最小堆：用容量为K的最小堆来存储最大的K个数。最小堆的堆顶元素就是最大K个数中的最小的一个。每次扫描一个数据X，如果X比堆顶元素Y小，则不需要改变原来的堆。如果X比堆顶元素大，那么用X替换堆顶元素Y，在替换之后，X可能破坏了最小堆的结构，需要调整堆来维持堆的性质。调整过程时间复杂度为O(logK)。 全部的时间复杂度为O(NlogK)。这种方法当数据量比较大的时候，比较方便。因为对所有的数据只会遍历一次，第一种方法则会多次遍历数组。 如果所查找的K的数量比较大。可以考虑先求出k‘ ，然后再求出看k’+1 到 2 k‘之间的数据，然后一次求取。 求一个数组中连续子数组的最大和？动态规划思想：如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max(f[0…n])。我们可以给出如下递归公式求f(i)：(1)f(x) = pData[i]， 当i = 0 || f(i-1) &lt;= 0时；(2)f(x) = pData[i] + f(i-1)， 当i != 0 &amp;&amp; f(i - 1) &gt; 0时；ps：用一个值保存最大的f(x)； 二叉树Z字型遍历?按层遍历，设置个flag，然后按层遍历，需要的层reverse一下。按层遍历思想：（1）设置3个指针current，last和nLast和一个队列，先把root放入队列queue；（2）循环判断queue是否为空，若不为空则出队一个元素记作current，然后判断current是否有左右孩子，将nLast置为左孩子或右孩子；（3）如果last==nLast，存入list；（4）全部存储完毕后，按行号奇偶决定打印顺序； 两个数组A和B,怎么求解两个数组中和为S的所有组合（组合中一个元素是A的，一个元素是B的）（1）先排序，然后头尾指针遍历；时间复杂度O(n2)，空间O(1);（2）合并后排序；时间复杂度O(n)； 两个字符串（数组？），比较是否相等，忽略顺序？把数组转化为byte[] arr = string.getBytes(); Arrays.sort(arr);然后比较是否相等。 有序链表，让奇数位升序偶数位降序，让链表变成升序的。这道题可以分成三步：（1）首先根据奇数位和偶数位拆分成两个链表。（2）然后对偶数链表进行反转。（3）最后将两个有序链表进行合并。 将一个L长有序数组A放入2L长数组B（前L有序，后L为空）得到一个有序数组，三种方法。–新建一个2L长数组，将A的元素与B第一个比较，＜A放新建第一个,看A第二个与B第一个，否则B放第一个，看A与B第二个………–B的后L个为空，合成后的最大值不是在A的后一个要不就是在B的最后一个，由后往前填，不用添加新数组–拼接 插入排序 在一个给定数组中找到最大的两个数？（1）排序；（2）一趟遍历，用max,max2存较大的数。注意，每次从max和max2中较小的一个数，和数组中的元素比较。以下算法时间复杂度为O(n)。 海量数据topK算法？先拿k个数建堆，然后一次添加剩余元素，如果大于堆顶的数（k中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的k个数就是所需的最大的k个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为总数据量，m为k）。优化的方法：可以把所有10壹个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。 给定1/2/3/4/5五个数，已知现在有m = 12543。求用这五个数凑出大于m的最小值（数字不能重复，如：111111）。换m第一个降序的两个数，然后把后面的逆序。 已知有A、B两个增序数组，先将A、B合成一个新的增序数组C，该如何操作？需要另外空间的话，双指针遍历。不需要另外空间的话，末尾遍历。 两个人取100个小球，每次取1个或2个，最后拿不到球的人输，如果你是先手，有什么策略可以一定赢？100/3=33余1,那么策略为甲先拿1个球，然后当乙拿了x个球，甲拿3-x即可，最后不管乙拿了多少个，甲都能保证一次性拿完。 1001个球，两人拿，一次只能拿1,2,4次，甲先拿，最后一个拿球的人输，甲必胜策略？1001-4=997，不能被3整除，所以甲先拿4个，后面不管乙拿多少个，甲可以保证和乙的和能被3整除（3或6），这样最后剩下的一个球肯定就是乙的。 基本排序算法中，哪一个最快，说说原理？平均情况下，快排较快。因为堆排序下，数据读取的开销变大。 举例使用分治思想的算法。归并排序。 把递归实现的快排改成非递归，你知道非递归有什么好处吗？递归好处：代码更简洁清晰。一般来说，一个人可能很容易的写出前中后序的二叉树遍历的递归算法，要写出相应的非递归算法就比较考验水平了，恐怕至少一半的人搞不定。所以说递归代码更简洁明了。递归坏处：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多。而且，如果递归深度太大，可能系统撑不住。 大数据排序？1.把一个bigdata文件拆分成N个小文件，小文件容量小于当前机器的内存;2.对小文件进行排序处理;3.对小文件进行并归排序; 什么是哈夫曼编码？哈夫曼（Huffman）编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间。哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且哈夫曼二叉树始终保证权重越大的字符出现在越高的地方。1.根据给定的n个权值{w1 , w2 , w3 , … , wn},构造n棵只有根节点的二叉树，令其权值为wi。2.在森林中选取两棵根节点权值最小的树作为左右子树，构造一棵新的二叉树，置新的二叉树的权值为左右子树的权值和。3.在森林中删去这两棵已被合并的树，将新得到的二叉树加入到森林中。4.重复以上两步，直到最后森林中只含有一棵树，那么这棵树就是哈夫曼树。应用：有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1。这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。 100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？用0 代表 灯灭 1 代表灯亮。用一个array[100][100]储存每个人按的状态 index 由1—100 初始值为0。array[i][j]代表第i个人按了第j盏灯。for（i=1；i＜＝100;i++)for（j＝1；j&lt;=100；j++）if(j%i==0）{arrray[i][j]=1; } 排序数组怎么在O（n）内生成一个乱序的数组？排序数组怎么在O（n) 约瑟夫问题 O(n)的算法？n表示人数，m表示出局的编号。最终的递推关系式为：f(1,m) = 0; (n=1)f(n,m)=(f(n-1,m)+m)%n; （n&gt;1） 两个文件都是10G，里面存着32位整数型，给8G内存，怎么求交集？哈希法，通过哈希值来对文件中的数据分到多个文件中，然后两个文件分解完的文件中相对应的再进行数据比较，确定是否有相同的数据，如果有就输出。 一棵树，求所有路径之和？结点数-1 30瓶水，其中有一瓶毒药，小白鼠喝了毒药之后一天会死，求只有一天时间，用最少的小白鼠找出毒药。输出a~z全排列。海明码。所需小白鼠数量为大于等于以2为底n+1的对数的最小整数。 给定一个文件名，如何在d盘找出来这个文件，说说思路。递归遍历d盘所有文件夹，寻找匹配的文件。 25匹马，只有一个5个赛道的跑道，最少多少次，找到top3？5+1+1=7; 一共有n乘以n匹马，有一个赛场，赛场有n个赛道，就是说最多同时可以有n匹马一起比赛。假设每匹马都跑的很稳定，不用任何其他工具，只通过马与马之间的比赛，试问最少得比多少场才能找出跑得最快的k匹马。(1)如果k = 1, f(n,k) = n + 1；(2)如果k&gt;1 &amp;&amp; k &lt;= n, f(n,k) = n + 1 + w(n,k)(3)如果k&gt;n, f(n,k) = n + 1 + w(n,k) + k - n 实现斐波拉契数列?递归和非递归两种方式。F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2) 排序01无序数组，最低的时间复杂度。（1）借助一个额外的数组，去寻找原始数组中的元素1，找到从新数据的末端开始不断插入1元素；（2）原地排序。两个指针，一个从头，一个从末尾，尾指针遇到0和头指针遇到1互换，两指针相遇结束。 将一个四则表达式变为后缀波兰表达式 比如1+5*2变为125*+Java数据结构和算法（六）——前缀、中缀、后缀表达式一个中缀式到其他式子的转换方法：a+b*c-(d+e)第一步：按照运算符的优先级对所有的运算单位加括号： 式子变成拉：((a+(b*c))-(d+e)) 第二步：转换前缀与后缀表达式 前缀：把运算符号移动到对应的括号前面 则变成拉：-( +(a *(bc)) +(de)) 把括号去掉：-+a*bc+de 前缀式子出现 后缀：把运算符号移动到对应的括号后面 则变成拉：((a(bc)* )+ (de)+ )- 把括号去掉：abc*+de+- 后缀式子出现 给定一个排序后的数组，要求移除重复的元素，返回新的数组长度。要求O(1)空间。/两个数组合并成一个升序数组，去掉重复的数？使用双指针。使用两个下标i和j，其中i用于记录去重后所得新数组最后一个元素的位置，j用于遍历整个数组，i和j同向移动，通过j移动来带动i的移动。在处理中，当遇到j和i所指向的元素值不同时，把j所指元素的值拷贝到新数组最后一个位置（i所在位置），然后将i向后移动一位。当遇到j和i所指的元素值相同时，不对i进行处理，只移动j，这样就能保证i遍历过得元素值各不相同。 快排为什么快？Quicksort是对归并排序算法的优化，继承了归并排序的优点，同样应用了分治思想。所谓的分治思想就是对一个问题“分而治之”，用分治思想来解决问题需要两个步骤：1.如何“分”？（如何缩小问题的规模）2.如何“治”？（如何解决子问题）快排的前身是归并，而正是因为归并存在不可忽视的缺点，才产生了快排。归并的最大问题是需要额外的存储空间，并且由于合并过程不确定，致使每个元素在序列中的最终位置上不可预知的。针对这一点，快速排序提出了新的思路：把更多的时间用在“分”上，而把较少的时间用在“治”上。从而解决了额外存储空间的问题，并提升了算法效率。快排之所以被称为“快”排，是因为它在平均时间上说最快的，主要原因是硬件方面的，每趟快排需要指定一个“支点”（也就是作为分界点的值），一趟中涉及的所有比较都是与这个“支点”来进行比较的，那么我们可以把这个“支点”放在寄存器里，如此这般，效率自然大大提高。除此之外，快排的高效率与分治思想也是分不开的。 给一个数n，快速判断是否为2的N次幂。(n-1) &amp; n == 0 ? true:false; 数组，链表，队列，栈之间的关系。队列和栈可以用链表或者数组实现。数组是顺序存储结构，链表是链式存储结构。 统计文本中出现频率最高的前五个单词。/一篇英文文献，怎么找出出现次数最多的单词？顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 多个字符串求最长公共前缀。寻找若干个字符串的最长公共前缀 Longest Common Prefix 查找数组中是否存在任意一个三角形。（1）先将数组从大到小进行排序。（2）将数组排序后，固定一个数c（从0到n-3），然后左指针b=c+1，右指针a=n-1；循环直到a&lt;b，如果nums[a] + nums[b] &gt; nums[c]，那么a与b之间所有的数都成立，随后左指针b++；否则，说明a不够大，a–。该算法复杂度O(n2)。（Leetcode611. Valid Triangle Number） 2017的2017次方的最后一位数是什么？7。 两个有序链表a和b，合并成有序链表c？1.链表L1的第一个结点的值小于链表L2的第一个结点的值，因此链表1的头结点是合并后链表的头结点。2.在剩下的结点中链表L2的第一个结点的值小于链表L1的第一个结点的值，因此将链表二的第一个结点与第一步的头结点连接。3.然后继续在剩下的结点中重复第二、三步，直到有链表为空。 给一串数字，把它翻译成汉语。最大到亿。阿拉伯数字转为中文读法 B+树和二叉树的区别?B+树一种多路搜索树，是多叉树。 有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和最接近零。先将两个数组排序，正数从小到大，负数从大到小。i，j然后两个指针从头到尾遍历两个链表。如果i+j的结果&lt;0，i++；如果结果大于0，j++。在这过程中用个变量min记录绝对值。 找出数组中和为M的两个数。排序数组。先用M减去数组中每个数，得到一个新数组arr。设定2个指针i和j，分别指向老数组的头和新数组的尾。找到相同就返回。时间复杂度O（n），空间复杂度O（1）。 链表中倒数第K个大的数。建立一个大小为K的数组arr，用2个变量max和min标记arr的最大值和最小值。遍历链表，每次用链表中的值替换掉arr中的最小值。直到遍历结束，min即为所求。 有一个无序的数据流，维护已经有的数字里的中位数。用两个堆实现。一个最大堆，一个最小堆。保证最小堆里的数都大于最大堆里的数。 如何将一个搜索二叉树，转为有序的双向链表？中序遍历，调整打印的根节点。 贪心算法是什么？贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。动态规划和贪心算法都是用来求最优化问题，且二者都必须具有最有子结构。贪心算法可以解决的问题，动态规划都能解决，可以说，贪心算法是动态规划的一个特例。 有一个能够产生1-5的随机数的函数，如何利用这个函数实现产生1-7的随机函数。更通俗一般的如果randomM()产生0~M-1之间的随机数，那么插空一次randomM()M+randomM()产生0~M^2-1之间的随机数。 ` int x = 5 (random5() - 1) + random5() - 1;` 判断两个链表是否相交。4种情况： 先判断两个链表有没有环； 两个无环链表； 一个有环一个无环；(不可能相交) 两个都有环； LRU算法？LRU就是Least Recently Used的缩写，翻译过来就是“最近最少使用”。也就是说LRU算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好LRU算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。通过对LinkedHashMap继承实现。 B+，B，红黑树，二叉搜索树，平衡搜索树?avl树怎么构建，怎么调整？二叉搜索树，平衡树，B，b-，b+,b*,红黑树AVL调整平衡的基本思想：旋转当在二叉排序树中插入一个节点时，首先检查是否因插入而破坏了平衡，若破坏，则找出其中的最小不平衡二叉树，在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，以达到新的平衡。所谓最小不平衡子树，指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。RR-左旋转；LL-右旋转；LR；RL； 求二维数组的盆地？岛问题。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"算法题","slug":"秋招/面试题/算法题","permalink":"http://yoursite.com/categories/秋招/面试题/算法题/"},{"name":"智力题","slug":"秋招/面试题/算法题/智力题","permalink":"http://yoursite.com/categories/秋招/面试题/算法题/智力题/"},{"name":"面经","slug":"秋招/面试题/算法题/智力题/面经","permalink":"http://yoursite.com/categories/秋招/面试题/算法题/智力题/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"},{"name":"智力题","slug":"智力题","permalink":"http://yoursite.com/tags/智力题/"}]},{"title":"Linux、Git、Maven、Jenkins、软件工程面经知识点总结","slug":"Linux、Git、Maven、Jenkins、软件工程面经知识点总结","date":"2018-10-16T03:01:04.000Z","updated":"2018-11-20T20:36:03.750Z","comments":true,"path":"2018/10/15/Linux、Git、Maven、Jenkins、软件工程面经知识点总结/","link":"","permalink":"http://yoursite.com/2018/10/15/Linux、Git、Maven、Jenkins、软件工程面经知识点总结/","excerpt":"","text":"Linux Linux查询Java进程?ps -ef | grep javaps:将某个进程显示出来-e 显示所有程序。-f 显示UID,PPIP,C与STIME栏位。 怎么杀死进程?kill -9 PID来强制杀死进程。 Linux命令，怎么日志文件里面找关键字?cat 路径/文件名 | grep 关键词例如：cat test.log | grep &quot;http&quot; # 返回test.log中包含http的所有行 Linux环境下，在10g数据中如何找到包含某字符串的一行? 常用的Linux命令。查找某端口的进程与用户?lsof -i:端口号，用于查看某一端口的占用情况，比如查看22号端口使用情况，lsof -i:22 写出你熟悉的Linux命令?top, cd, pwd, cp, rf, mkdir, cat, touch, grep, kill, chmod 777, reboot Linux怎么把日志输入到文件中?使用&gt;输出重定向到文件中。 64位和32位的区别？32位操作系统通用寄存器的数据宽度是32位的，一次最多能处理32位数据。相应的，64位操作系统一次处理数据要比32位高一倍，一次能运行64位的数据。 讲一下系统内存是怎样的？分段分页虚拟内存？ Windows和Linux内存管理对比？ 你能解释一下Linux的软链接和硬链接吗？硬链接文件与源文件的inode节点号相同，而软链接文件相当于windows下面的快捷方式（inode节点号与源文件不同）。硬链接和源文件具有相同的inode，软链接和源文件具有不同的inode。文件的链接数显示的是硬链接的个数，和软链接个数无关。 操作系统分页、分段？ 缺页机制能说一下吗？ Git 写你知道的Git命令 初始化一个Git仓库，使用git init命令。 使用命令git commit -m &quot;备注&quot;, 提交到仓库; 掌握工作区的状态，使用git status命令。 关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git; git pull origin master git push -u origin master; git clone 远程地址 Maven 熟悉maven是吧？我们来聊下maven的源码原理，maven冲突的时候，怎么选择依赖包，我们怎么查，我们遇到两个不一样的版本，我们应该如何去选择，为什么？ JenkinsTODO 软件工程 什么是敏捷开发，防御式编程。敏捷开发： 敏捷并不是快，而是灵活。灵活地适应需求的变化； 敏捷不需要面面俱到的文档，但是离不开文档； 敏捷开发要求项目透明，最小化验证（灵活），及时调整，增量迭代； 缺点是：对人的要求高，强调自组织；强调沟通，对技术人员打断太多，降低工作效率； 防御性编程：防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，然后创建一个环境来测试错误，当预见的问题出现的时候通知你，并执行一个你指定的损害控制动作。 问面试官 你有没有什么想问的？常规三问：您是哪个部门的，做什么？对我今天面试的表现，简单评价一下？对我今后的学习或者工作提些建议？）","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Linux","slug":"秋招/面试题/Linux","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/"},{"name":"Git","slug":"秋招/面试题/Linux/Git","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/Git/"},{"name":"Maven","slug":"秋招/面试题/Linux/Git/Maven","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/Git/Maven/"},{"name":"Jenkins","slug":"秋招/面试题/Linux/Git/Maven/Jenkins","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/Git/Maven/Jenkins/"},{"name":"软件工程","slug":"秋招/面试题/Linux/Git/Maven/Jenkins/软件工程","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/Git/Maven/Jenkins/软件工程/"},{"name":"面经","slug":"秋招/面试题/Linux/Git/Maven/Jenkins/软件工程/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Linux/Git/Maven/Jenkins/软件工程/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"},{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/tags/软件工程/"}]},{"title":"Java多线程面经题总结","slug":"Java多线程面经题总结","date":"2018-10-13T18:30:16.000Z","updated":"2018-11-20T20:37:38.476Z","comments":true,"path":"2018/10/13/Java多线程面经题总结/","link":"","permalink":"http://yoursite.com/2018/10/13/Java多线程面经题总结/","excerpt":"","text":"一、基本概念 什么是进程？什么是线程？进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。CPU很快，那当多个任务要执行的时候怎么办呢？答案是CPU轮流着来执行。执行一段程序代码，当得到CPU的时候，相关的资源必须也已经就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。因此前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境的更为细小的CPU时间段。 什么是进程？什么是线程？进程就是在内存中执行的程序；线程是轻量级进程；各进程是独立的，而各线程则不一定。 什么是并行？什么是并发？并行：并行的关键是你有同时处理多个任务的能力；并发：有处理多个任务的能力，不一定要同时； 为什么要使用多线程？最大化利用CPU和CPU时间片。发挥多处理器的作用，提高性能和响应速度。 多线程研究什么？ 线程间的互斥：多线程加法； 线程间的协同：生产者消费者模型；i++的操作分为如下下三步：1. 读取内存中原有i值; 2. 计算i+1; 3. 将i写入内存; 用户进程间通信主要哪几种方式？1、管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I/O操作以后，命名管道将继续保存在文件系统中以便以后使用。2、信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。3、消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。4、信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。5、共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。6、套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。 二、多线程的实现方法 创建线程的方法？ 继承Thread类，重写run()方法；无返回值。 实现Runnable接口，重写run()方法。创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象；runnable接口是一个task，需要分配一个线程。无返回值。 实现Callable接口。有返回值。 一些常用的多线程的方法(Thread类)： currentThread()：返回对当前正在执行的线程对象的引用。 getId()：返回此线程的标识符； getName()：返回此线程的名称； getPriority()：返回此线程的优先级； isAlive()：测试这个线程是否还处于活动状态； sleep(long millis)：使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行）； interrupt()：中断这个线程； interrupted()： 测试当前线程是否已经是中断状态 setDaemon(boolean on)：将此线程标记为 daemon线程或用户线程； join()：如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。join()方法是指等待调用join()方法的线程执行结束，程序才会继续执行下去。 yield()：作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。 如何停止一个线程？一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。具体来说，当对一个线程，调用 interrupt() 时，有两种情况：① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做：① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。） 多线程的分类？ 用户进程； 守护进程，最常见的守护线程：垃圾回收线程 三、线程的生命周期 wait/notify机制主要用于线程间的协同。等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()/notifyAll()方法，线程A收到通知后退出等待队列，进入可运行状态，进而执行后续操作。上诉两个线程通过对象O来完成交互，而对象上的wait()方法和notify()/notifyAll()方法的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。当方法wait()被执行后，锁自动被释放，但执行完notify()方法后，锁不会自动释放。必须执行完notify()方法所在的synchronized代码块后才释放。 三、线程属性 什么是线程组？在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。简单地说，线程组就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。默认情况下，系统线程组是所有线程和线程组的父级。 获取当前线程？Thread current = Thread.currentThread(); wait()，sleep()和start()方法？sleep()：释放CPU的执行权，不释放锁；wait()：释放CPU的执行权，释放锁；start()：让线程跑起来； 四、线程锁 隐式锁synchronized？如果两个线程同时操作对象中的实例变量，则会出现“非线程安全”，解决办法就是在方法前加上synchronized关键字即可。synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。前提是多个线程访问的是同一个对象。如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。利用sychronized实现同步的基础：java中每一个对象都可以作为锁。具体表现为以下3中形式。1.对于普通方法的同步，锁是当前实例对象。2.对于静态方法的同步，锁是当前类的Class对象。3.对于同步方法块，锁是sychronized括号里配置的对象。当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。如果父类有一个带synchronized关键字的方法，子类继承并重写了这个方法。 但是同步不能继承，所以还是需要在子类方法中添加synchronized关键字。 显示锁Lock?Lock接口的实现类：ReentrantLock， ReentrantReadWriteLock.ReadLock，ReentrantReadWriteLock.WriteLocksynchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。在使用notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。await()/signal()/signalAll() Synchronized和lock区别? 公平锁与非公平锁.Lock锁分为：公平锁 和 非公平锁。公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获取锁的，和公平锁不一样的就是先来的不一定先的到锁，这样可能造成某些线程一直拿不到锁，结果也就是不公平的了。Service service = new Service(true);//true为公平锁，false为非公平锁 ThreadLocal?线程局部变量，是一个map，保存线程的副本。 关键字volatile？在当前的 Java 内存模型下，线程可以把变量保存高速缓存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取和写入。在任何时刻，两个不同的线程总是看到某个成员变量的同一个值，这样也就保证了同步数据的可见性。volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。可见性：volatile 修饰的成员变量在每次被线程访问时，都强迫从主存（共享内存）中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主存（共享内存）。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值，这样也就保证了同步数据的可见性。 原子操作：atomic?支持在单个变量上进行线程安全编程。例如：AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference等一些基本类型。 为什么不能使用String类型的锁？因为数据类型String的常量池属性，所以synchronized(string)在使用时某些情况下会出现一些问题，比如两个线程运行synchronized(“abc”)｛｝和synchronized(“abc”)｛｝修饰的方法时，这两个线程就会持有相同的锁，导致某一时刻只有一个线程能运行。所以尽量不要使用synchronized(string)而使用synchronized(object) volatile和synchronized的比较？ volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞； volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。 什么是死锁？死锁的条件有哪些？两个或者多个线程之间相互等待，导致线程都无法执行，叫做线程死锁。互斥条件：使用的资源是不能共享的。不可抢占条件：线程持有一个资源并等待获取一个被其他线程持有的资源。请求与保持条件：线程持有一个资源并等待获取一个被其他线程持有的资源。循环等待条件：线程之间形成一种首尾相连的等待资源的关系。 五、线程同步 什么是线程安全？当一个类，不断被多个线程调用，仍能表现出正确的行为时，那它就是线程安全的。多线程同时访问同一份资源，才有可能发生线程安全问题。要想写出线程安全的代码，我们需要用到使用synchronize、volatile，或者将线程安全委托给基础构建模块（concurrent包下）。 什么是线程同步？多线程之间访问线程安全。线程同步是实现线程安全的一种手段。 java.util.concurrent.*;包下的类。 什么是同步？什么是异步？同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。异步的意思是两个线程毫无相关，自己运行自己的。 六、线程间通信 Exchanger：两线程交换数据； locks.Condition():线程互相唤醒和等待； 通过多线程的线程安全集合变量； 使用管道流； 线程间通信的方式？synchronized关键字、volatile关键字以及等待/通知（wait/notify）机制。管道输入/输出流、Thread.join()的使用、ThreadLocal的使用。 管道输入/输出流和普通文件的输入/输出流或者网络输入、输出流不同之处在于管道输入/输出流主要用于线程之间的数据传输，而且传输的媒介为内存。 Thread.join()：主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法。 ThreadLocal：线程局部变量。有一种情况之下，我们需要满足这样一个条件：变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下ThreadLocal就非常使用，比如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。 七、线程池 无限制创建线程的不足。线程池的优势。降低资源消耗。提高响应速度。提高响应速度。 Executor 框架Executor 框架结构主要由三大部分组成： 任务：执行任务需要实现的Runnable接口或Callable接口。 任务的执行：包括任务执行机制的核心接口Executor ，以及继承自Executor 接口的ExecutorService接口。ScheduledThreadPoolExecutor和ThreadPoolExecutor这两个关键类实现了ExecutorService接口。 异步计算的结果 父类ThreadPoolExecutor.（1）线程池大小corePoolSize()；当线程池里的线程数少于corePoolSize时，每来一个任务，我就创建一条线程去处理，不管线程池中有没有空闲的线程；线程池里的线程数达到corePoolSize时，新来的任务，会先放到任务队列里面；当任务队列放满了（如果队列是有界队列），那么要怎么办？马上拒绝新的任务吗？似乎不妥，面对这种业务突然繁忙的情况，我是不是可以破例再创建多几条线程呢？于是就有了maximumPoolSize，如果任务队列满了，但是线程池中的线程数还少于maximumPoolSize，那我就允许线程池继续创建线程；从厨房拿出来的桌子，在高峰期过后，就要渐渐撤回了吧？同样，当我发现线程池中线程的数量超过corePoolSize，就会去监控线程，发现某条线程很久没有工作了，就把它关掉，这里的很久是多久，那就要看你传过来的keepAliveTime是多少了。（2）饱和策略：RejectedExecutionHandler1）AbortPolicy：默认情况，直接抛出异常；2）CallerRunsPolicy：只用调用者所在线程执行任务；3）DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；4）DiscardPolicy：不处理，丢弃掉；5）实现RejectedExecutionHandler接口，自定义策略； Executors类，在父类基础上做了一些包装。Executors.newCachedThreadPool()：无界线程池，可以自动进行线程回收；Executors.newFixedThreadPool(int)：固定大小线程池；Executors.newSingleThreadExecutor()：单个后台线程； ExecutorService类的方法execute(), submit(Runnable task), shutdown； 各种线程池的适用场景介绍FixedThreadPool： 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；SingleThreadExecutor： 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。CachedThreadPool： 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；ScheduledThreadPoolExecutor： 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；SingleThreadScheduledExecutor： 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。 八、线程队列 BlockingQueue相关实现：1) ArrayBlockingQueue;2) LinkedBlockingQueue;3) PriorityBlockingQueue;4) SychronousQueue; 九、线程阀 CountDownLatch：计数装置。当需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发时间，以便进行后面的操作。这时候就使用CountDownLatch，里面最终要的方法是countDown()和await()； CyclicBarrier：循环屏障。与CountDownLatch相似，但是可以设定等待次数的规则； Future-&gt;FutureTask：闭锁。结合Runnable使用。一般FutureTask多用于耗时的计算，主线程在完成自己的任务后，再去获取结果。只有在计算完成时获取，否则会一直阻塞直到任务完成状态。 Semaphore：信号量。维护当前访问个数，提供同步机制，控制同时访问的个数。 ThreadLocal的使用？变量值的共享可以使用public static变量的形式，所有线程都使用一个public static变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的ThreadLocal类正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。ThreadLocal翻译成中文比较准确的叫法应该是：线程局部变量。这个玩意有什么用处，或者说为什么要有这么一个东东？先解释一下，在并发编程的时候，成员变量如果不做任何处理其实是线程不安全的，各个线程都在操作同一个变量，显然是不行的，并且我们也知道volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，我们需要满足这样一个条件：变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下ThreadLocal就非常使用，比如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal就比较好的解决了这个问题。应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发生变化，他仅仅是充当一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮我们做了这个事情。 InheritableThreadLocal？ThreadLocal类固然很好，但是子线程并不能取到父线程的ThreadLocal类的变量，InheritableThreadLocal类就是解决这个问题的。 任务从保存到再加载的过程就是一次上下文切换。如何减少上下文切换？ 减少锁的使用。因为多线程竞争锁时会引起上下文切换。 使用CAS算法。这种算法也是为了减少锁的使用。CAS算法是一种无锁算法。 减少线程的使用。人物很少的时候创建大量线程会导致大量线程都处于等待状态。 使用协程。 CAS算法？CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。相对应的，独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 四种避免死锁的常见方法：避免一个线程同时获得多个锁避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 解释下，关于线程安全的最基础的两个关键字：volatile和synchronized？volatile是让修改的变量立刻同步到主内存的；volatile实现了比synchronize更轻量级的同步机制，或者说，加锁机制既确保了可见性，有确保了原子性，而volatile只能保证可见性。synchronized用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码； 他通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。synchronized的作用：确保了操作的原子性。原先count++是三个动作，其他线程可以在这三个操作之间对count变量进行修改，而在使用了synchronize之后，这三个动作就变成一个不可拆分、一气呵成的动作，不必担心在这个操作的过程中会有其他线程进行干扰，这就是原子性。原子操作是线程安全的，这其实也是我们经常使用synchronize来实现线程安全的原因。可见性的意思是变量的修改可以被其他线程观察到，在上面计数器的例子中，由于一次只有一个线程可以执行count++，抢不到锁的线程，必须等抢到锁的线程更新完count之后，才可以去执行count++，而这个时候，count也已经完成了更新，新的锁持有者，可以看到更新后的count，而不至于拿着旧的count值去进行计算，这就是可见性。synchronized如何“保证在同一时刻最多只有一个线程执行该段代码”的？关于synchronize，我们经常使用的隐喻就是锁，首先进入的线程，拿到了锁的唯一一把钥匙，至于其他线程，就只能阻塞（Blocked）；等到线程走出synchronize之后，会把锁释放掉，也就是把钥匙扔出去，下一个拿到钥匙的线程，就可以结束阻塞状态，继续运行。但是锁从哪来呢？随随便便抓起一个东西就可以作为锁么？还真是这样，Java中每一个对象都有一个与之关联的锁，称为内置锁：当我们使用synchronize修饰非静态方法时，用的是调用该方法的实例的内置锁，也就是this;当我们使用synchronize修饰静态方法时，用的是调用该方法的所在的类对象的内置锁;内置锁的可重入性（Reentrancy）:子类、父类之间。Java中每个对象都有一个内置锁。与内置锁相对的是显示锁，使用显示锁需要手动创建Lock对象，而内置锁则是所有对象自带的。synchronized使用对象自带的内置锁来进行加锁，从而保证在同一时刻最多只有一个线程执行代码。所有的加锁行为，都可以带来两个保障——原子性和可见性。其中，原子性是相对锁所在的线程的角度而言，而可见性则是相对其他线程而言。锁的持有者是“线程”，而不是“调用”，这也是锁的为什么是可重入的原因。可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。 堆区：只存放类对象，线程共享；方法区：又叫静态存储区，存放class文件和静态数据，线程共享;栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享; 脏读？读取的值被别人改过了。发生脏读的情况实在读取实例变量时，此值已经被其他线程更改过。 锁的可重入性。 12345678910111213public class UnReentrant&#123; Lock lock = new Lock(); public void outer()&#123; lock.lock(); inner(); lock.unlock(); &#125; public void inner()&#123; lock.lock(); //do something lock.unlock(); &#125;&#125; outer中调用了inner，outer先锁住了lock，这样inner就不能再获取lock。其实调用outer的线程已经获取了lock锁，但是不能在inner中重复利用已经获取的锁资源，这种锁即称之为不可重入。通常也称为自旋锁 。相对来说，可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。 Java中wait、sleep、yield的区别? sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的 wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。 yield()方法上来，与wait()和sleep()方法有一些区别，它仅仅释放线程所占有的CPU资源，从而让其他线程有机会运行，但是并不能保证某个特定的线程能够获得CPU资源。谁能获得CPU完全取决于调度器，在有些情况下调用yield方法的线程甚至会再次得到CPU资源。所以，依赖于yield方法是不可靠的，它只能尽力而为。 Java中的wait方法应在同步代码块中调用，但是sleep方法不需要。 使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首先获得锁（译者注：阻塞态），然后再进入就绪态。所以，根据你的需求，如果你需要暂定你的线程一段特定的时间就使用sleep()方法，如果你想要实现线程间通信就使用wait()方法。 wait和sleep区别？wait只能在同步（synchronize）环境中被调用，而sleep不需要。详见Why to wait and notify needs to call from synchronized method进入wait状态的线程能够被notify和notifyAll线程唤醒，但是进入sleeping状态的线程不能被notify方法唤醒。wait通常有条件地执行，线程会一直处于wait状态，直到某个条件变为真。但是sleep仅仅让你的线程进入睡眠状态。wait方法在进入wait状态的时候会释放对象的锁，但是sleep方法不会。wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程。 yield和sleep的区别记住sleep和yield作用于当前线程。yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。执行了yield方法的线程什么时候会继续运行由线程调度器来决定，不同的厂商可能有不同的行为。yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。 问：阻塞和等待之间的区别答：等待在一个等待队列里，要有人通知才能再度回到runnable状态争抢锁，阻塞则是一直在那循环尝试抢占锁。 start方法和run方法区别？start() 方法的作用是启动一个新线程，新线程会执行相应的run()方法，start()不能被重复调用。而run()方法则只是普通的方法调用，在调用线程中顺序运行而已。 一个进程一定要有一个线程吗？没有线程的进程是什么？通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。 并发，为什么要用多线程？ wait方法能不能被重写，wait能不能被中断？wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java多线程","slug":"秋招/面试题/Java多线程","permalink":"http://yoursite.com/categories/秋招/面试题/Java多线程/"},{"name":"Java","slug":"秋招/面试题/Java多线程/Java","permalink":"http://yoursite.com/categories/秋招/面试题/Java多线程/Java/"},{"name":"面经","slug":"秋招/面试题/Java多线程/Java/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java多线程/Java/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/tags/Java多线程/"}]},{"title":"数据库面经知识点总结","slug":"数据库面经知识点总结","date":"2018-10-11T12:32:06.000Z","updated":"2018-11-20T20:37:31.946Z","comments":true,"path":"2018/10/11/数据库面经知识点总结/","link":"","permalink":"http://yoursite.com/2018/10/11/数据库面经知识点总结/","excerpt":"","text":"数据库两种引擎MyISAM和InnoDB的区别？1) count运算上的区别： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。2) 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。3)是否支持外键： MyISAM不支持，而InnoDB支持。MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 数据库索引有了解过嘛，解释一下两种引擎。MyISAM特点： 不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁； 不支持事务； 不支持外键； 不支持崩溃后的安全恢复； 在表有读取查询的同时，支持往表中插入新纪录； 支持BLOB和TEXT的前500个字符索引，支持全文索引； 支持延迟更新索引，极大地提升了写入性能； 对于不会进行修改的表，支持压缩表，极大地减少了磁盘空间的占用； InnoDB特点： 1. 支持行锁，采用MVCC来支持高并发，有可能死锁； 2. 支持事务； 3. 支持外键； 4. 支持崩溃后的安全恢复； 5. 不支持全文索引； 让介绍一下数据库索引？数据库索引有哪些，什么时候会失效，索引底层是怎么实现的？说一下InnoDB的索引结构？索引底层是怎么实现的?索引（Index）是帮助MySQL高效获取数据的数据结构。Mysql索引使用的数据结构主要有B树索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。Mysql的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 MySQL数据库索引有哪些? 从数据类型角度：B+树索引，哈希索引等； 从物理存储角度：聚集索引，非聚集索引； 从逻辑角度：主键索引，普通索引，组合索引，唯一索引，空间索引等； 索引什么时候会失效？有5种索引失效的情况：（1）对单字段建了索引，但是where条件多字段。（2）建立联合索引，where条件单字段。与上面情况正好相反。（3）对索引列运算，运算包括（+、-、*、/、！、&lt;&gt;、%、like’%_’（%放在前面）、or、in、exist等），导致索引失效。（4）类型错误，如字段类型为varchar，where条件用number；（5）对索引应用内部函数，这种情况下应该建立基于函数的索引。 聚集索引和非聚集索引的区别.整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。非聚集索引， 也就是我们平时经常提起和使用的常规索引。非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个，这个跟没问题没差别，一般人都知道。 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续，这个大家也都知道。 聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针。 InnoDB和MyISAM索引的区别？MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引方式也叫做“非聚集”的。第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。 mysql的联合索引用户可以在多个列上建立索引,这种索引叫做复合索引(组合索引)。 SQL优化思路，联合索引与底层树结构的映像关系，索引结构（B+、B），为什么用这样的结构SQL优化就是让SQL执行的更快。 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引； 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描； 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描； 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描； in 和 not in 也要慎用，否则会导致全表扫描； 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描； 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描； 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引； 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致 Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志； 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差 select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的； 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些； 尽量避免大事务操作，提高系统并发能力； 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改； B树与B+树的区别？因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。b+树在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定; 查看索引使用情况需要哪个关键字？使用EXPLAIN关键字；查看索引的使用情况show global status like &#39;Handler_read%&#39;;Handler_read_key 数值越大的话，表示索引使用率高;Handler_read_rnd 查询直接操作了数据文件，是没有使用索引;Handler_read_rnd_next 数值越大的话，表示索引低效;Handler_read_next 此选项表明在进行索引扫描时，按照索引从数据文件里取数据的次数; 索引为什么快？假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大O标记法就是O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此，这一亿次匹配在不经缓存优化的情况下就是一亿次IO开销，以现在磁盘的IO能力和CPU的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有10层，那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，用大O标记法就是O(log n)，n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用程序来表示就是Math.Log(100000000,10)，100000000是记录数，10是树的分叉数（真实环境下分叉数远不止10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。 索引的缺点？索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。 数据库四种事务特性，隔离级别，死锁。数据事务脏读，不可重复读，幻读的解决方案?四种特性ACID：（1）原子性Atomicity：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；（2）一致性Consistency：执行事务前后，数据保持一致；（3）隔离性Isolation：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；（4）持久性Durability: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响； 为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：（1）未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。最低级别，任何情况都无法保证。（2）提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的 修改在提交之前对其它事务是不可见的。可避免脏读的发生。（3）可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同样数据的结果是一样的。可避免脏读、不可重复读的发生。（4）可串行化（SERIALIXABLE）：强制事务串行执行。可避免脏读、不可重复读、幻读的发生。在MySQL数据库中，支持上面四种隔离级别，默认的为REPEATABLE READ(可重复读)。 数据库的三范式？第一范式：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性存在传递函数依赖关系。第二范式：完全依赖于主键，消除非主属性对主码的部分函数依赖第三范式：每个非关键字列都独立于其他非关键字列，并依赖于关键字，第三范式指数据库中不能 数据库优化措施？数据库高并发下的优化思路？大量数据，高并发访问如何优化？当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：第一优化你的sql和索引；第一优化你的sql和索引；（1）限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。（2）读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；（3）缓存：使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；（4）垂直分区：根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。（5）水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库。（6）（4）和（5）代表分库分表的两种形式。 数据库分库分表，垂直和水平来分？分表解决的是，过大的数据表影响计算速度的问题，比如单表上亿，那么我拆成十个表，那么我必然会比一个表更快，原因是，用了一部分计算落表时间，来换取表计算的时间。分库更多解决的是机器的局限的问题，单机容量有限，单机容量实际上是由机器硬件决定，比如我的网卡打满，CPU打满，机器磁盘写满，这种case，必须将计算分布到其他机器上解决。先拆分进程，随后将进程拆分到不同的机器上。 热点数据访问优化?实际应用中涉及热点数据访问时，Innodb是一个高性能的较好的选择，但前提是要能够预估热点数据的大小，只有当热点数据小于Innodb buffer pool（即热点数据全部能够放入内存）时，才能够获得高性能。 MySQL数据库表的连接方式？leftjoin和rightjoin的区别？1.内连接（等值连接）：只返回两个表中联接字段相等的记录。2.左连接：返回左表中的所有记录以及和右表中的联接字段相等的记录。3.右连接：返回右表中的所有记录以及和左表中的联接字段相等的记录。4.自连接（同一个表内）： 数据库查询返回一列空值如何操作?执行下面的SQL语句就可以查询：SELECT * FROM 数据库表名 WHERE 某一个字段 IS NULL 数据库百万条数据，用limit查询前十条和最后十条性能的区别，说明原因？前十条较快，最后十条较慢。因为数据库也并不知道最后十条的记录从什么地方开始，即使有索引也需要从头计算一次。出现这种性能问题，多数情形下是程序员偷懒了。在前端数据浏览翻页，或者大数据分批导出等场景下，是可以将上一页的最大值当成参数作为查询条件的。可以使用create_time进行排序，然后用limit取出最后10条。 修改MySQL字符集需要哪个关键字？1.修改mysql表的字符编码方式: alter table t_name convert to character set utf8;2.修改数据库的字符集: alter database mydb character set utf8; 数据库分库分表解决大数据量查询效率问题怎么做？两种拆分方式：垂直拆分：是指按业务功能模块拆分，比如分为订单库、商品库、用户库，这种方式多个数据库之间的表结构不同。水平拆分：按照一定的分片算法将同一个表的数据进行分块保存到不同数据库的数据表中，这些数据库中的表结构完全相同。某种意义上讲，我们的网站系统是按照业务功能进行垂直拆分的，不同的业务系统负责管理不同的业务数据库。在同一个业务系统中，比如订单系统，当单库单表的数据量不断增长时，往往只需要考虑水平拆分。 实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树实现的？红黑树这些二叉树结构的数据结构可以达到最高的查询效率这是毋庸置疑的。红黑树基本都是存储在内存中才会使用的数据结构，但是数据库要对磁盘进行操作。操作系统磁盘读写有一个最少内容的限制，即使我们只需要一个字节的内容，我们也要把一整个上的内容读完。现在问题就来了一个父节点只有2个子节点，并不能填满一个簇（cluster）上的所有内容啊。怎么才能把浪费的这部分内容利用起来呢？答案就是B+树。由于B+树分支比二叉树更多，所以相同数量的内容，B+树的深度更浅，深度代表磁盘 io次数.数据库设计的时候B+树有多少个分支都是按照磁盘一个簇上最多能放多少节点设计的。所以涉及到磁盘上查询的数据结构，一般都用B+树。 数据库水平切分多库相交于切分成多表的好处？分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库。 MySQL的锁有哪些?乐观锁和悲观锁?锁的分类一、按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql）二、按锁级别划分，可分为共享锁、排他锁三、按使用方式划分，可分为乐观锁、悲观锁四、按加锁方式划分，可分为自动锁、显示锁 Mysql用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这些锁统称为悲观锁(Pessimistic Lock)。显著的特点是不同的存储引擎支持不同的锁机制。悲观锁：假定会发生并发冲突，则屏蔽一切可能违反数据完整性的操作。乐观锁：假定不会发生并发冲突，只在数据提交时检查是否违反了数据完整性（不能解决脏读问题）。 乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。共享锁相当于对于同一把门，它拥有多个钥匙一样。排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。行锁给某一行加上锁，也就是一条记录加上锁。表锁和行锁相对应，给这个表加上锁。 行锁、页面锁和表锁？Mysql的行锁和表锁（ 锁是计算机协调多个进程或纯线程并发访问某一资源的机制）表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用。（BDB） 从数据库中主键字段取出上万条数据，用哪种排序好 redis在项目中用来干什么，基于什么考虑。讲了频繁访问的数据放到redis中，还有拿redis做异步任务队列。 单机redis有可能挂掉，解决措施。 你说的SQL优化，怎么优化的，怎么思考的？","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"数据库","slug":"秋招/面试题/数据库","permalink":"http://yoursite.com/categories/秋招/面试题/数据库/"},{"name":"MySQL","slug":"秋招/面试题/数据库/MySQL","permalink":"http://yoursite.com/categories/秋招/面试题/数据库/MySQL/"},{"name":"面经","slug":"秋招/面试题/数据库/MySQL/面经","permalink":"http://yoursite.com/categories/秋招/面试题/数据库/MySQL/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"JVM知识点总结","slug":"JVM知识点总结","date":"2018-10-09T19:29:03.000Z","updated":"2018-11-20T20:37:21.370Z","comments":true,"path":"2018/10/09/JVM知识点总结/","link":"","permalink":"http://yoursite.com/2018/10/09/JVM知识点总结/","excerpt":"","text":"JVM：垃圾回收算法，垃圾回收器。垃圾回收算法： 标记-清除法：标记出没有用的对象，然后一个一个回收掉；缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作。 复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉；缺点：将内存缩小为了原来的一半 标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内；优点：解决了标记-清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。 分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法； 垃圾回收器： 1. Serial New 收集器是针对新生代的收集器，采用的是复制算法； 2. Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理； 3. Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法； 4. Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理； 5. Parallel Old（并行）收集器，针对老年代，标记整理； 6. CMS收集器，基于标记清理； 7. G1收集器(JDK)：整体上是基于标记清理，局部采用复制； 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。 Java内存模型？ 程序计数器：当前线程所执行的字节码的行号指示器，用于记录下一条要运行的指令，线程私有 Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有 Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有 Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享； 介绍一下GC机制？Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控；Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理；可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用； GC中如何判断对象需要被回收？先判断对象的死活。主要有两种方法： 引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了。缺点是：存在循环引用的情况。 可达性算法：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括：java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象；在Java语言里，可作为GC Roots的对象包括以下几种：虚拟机栈（栈帧中的本地变量表）中的引用的对象方法区中的类静态属性引用的对象方法区中的常量引用的对象。本地方法栈中JNI(即一般说的Native方法)的引用的对象。 新生代、老年代、永久代的分配策略？ 结构（堆大小 = 新生代 + 老年代 ）： （1）新生代(1/3)(初始对象，生命周期短)：Eden区、survivior0、survivior1（8:1:1）； （2）老年代(2/3)(长时间存在的对象) 分配策略： （1）小对象优先分配在Eden区域； （2）如果Eden区域空间不够，那么尝试把活着的对象放到survivor0中去（Minor GC） 如果survivor0可以放入，那么放入之后清除Eden区； 如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中； 如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把 survivor1中的对象复制到survivor0中，保持survivor1一直为空； 如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC）； （3）大对象直接进入老年代：因为他们需要大量连续空间； （4）长期存活的对象进入老年代（年龄计数器，每次在suvivor区域熬过一次minor GC增加1，默认最多15）； （5）动态年龄判断，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代； 新生代到老年代的转换有哪些情况（条件）？有四种情况：（1）大对象直接进入老年代；（2）长期存活的对象；（3）Minor GC后，suvivor区依然无法存放的对象，进入老年代；（4）动态年龄判断，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代； 类加载机制？ MinorGC和FullGC？Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法；Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法； Java内存堆和栈？ 栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中； 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问； 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError； 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小； 静态变量存在哪？存放在方法区。 Java的四种引用？ 强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题 软引用（SoftReference）如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中 弱引用（WeakReference）弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中; 虚引用（PhantomReference）虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 JVM三大性能调优参数-Xms -Xmx -Xss? 为什么JVM调优经常会将-Xms和-Xmx参数设置成一样?-Xss规定了每个线程堆栈的大小。一般情况下256K是足够了。影响了此进程中并发线程数大小。-Xms初始的Heap的大小。在很多情况下，-Xms和-Xmx设置成一样的。这么设置，是因为当Heap不够用时，JVM会反复重新申请内存，导致性能大起大落，影响程序运行稳定性。 JAVA虚拟机的作用？将Java字节码转化为机器指令。实现了平台无关性。 在java 7 和 java 8中GC的区别。持久代被替换成了元空间，更容易进行参数调优。 如果经常出现full GC怎么定位代码哪里出了问题? System.gc()方法的调用。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。 老年代空间不足。不要创建过大的对象及数组。 堆中分配很大的对象。所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。 Java什么时候会发生内存泄漏？ 长生命周期的对象持有短生命周期对象的引用：例如：在全局静态map中缓存局部变量，且没有清空操作，随着时间的推移，这个map会越来越大，造成内存泄露。 连接资源不释放，例如：Java 数据库连接一般用DataSource.getConnection()来创建，当不再使用时必须用Close()方法来释放； 为了避免内存泄露，在编写代码的过程中可以参考下面的建议： 尽早释放无用对象的引用 使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域 尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收 避免在循环中创建对象 开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。 双亲委托类加载机制（Bootstrap，双亲委派，运行时常量池）? 概念：虚拟机把描述类字节码文件加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）； 类的声明周期： （1）加载过程：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； （2）验证过程：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证 （3）准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配 （4）解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程 （5）初始化阶段：类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器()方法的过程 （6）使用阶段 （7）卸载阶段 Java类加载器：类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次；Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现；Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的；System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径； 双亲委派机制的作用：（1）共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。 （2）隔离功能：因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器，保证java/Android核心类库的纯净和安全，防止恶意加载。 双亲委派模型的工作过程： （1）首先会先查找当前ClassLoader是否加载过此类，有就返回； （2）如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类； （3）如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样； 定义：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。 内存泄漏了解多少，想办法写程序造成堆内存溢出，栈内存溢出，方法区溢出？堆内存：写一个类，然后在ArrayList中无限循环add这个类的对象；栈内存：无限递归调用；方法区：用一个装String的ArrayList，向里面add String.valueOf(i++).intern()；String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 new()创建过程都实现了什么?①类加载检查： 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。②分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。③初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。④设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。⑤执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 String对象的两种创建方式？String str1 =&quot;abcd&quot;; 和 String str2 = new String(&quot;abcd&quot;);。这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。记住：只要使用new方法，便需要创建新的对象。 常量池？Java基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 Java对象创建方式有哪些？ 使用new关键字创建对象； 使用Class类的newInstance方法(反射机制)； 使用Constructor类的newInstance方法(反射机制)； 使用Clone方法创建对象； 使用(反)序列化机制创建对象； Java常量池。Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。1）所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。2）而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。常量池的好处：常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等；如果你用了String s1 = new String(&quot;abc&quot;); 那么，会有两个String被创建，一个是你的Class被CLassLoader加载时，你的”abc”被作为常量读入，在constant pool里创建了一个共享的”abc” 。然后，当调用到new String(&quot;abc&quot;)的时候，会在heap里创建这个new String(&quot;abc&quot;); new开辟空间多大事怎么决定的？内存对齐。与操作系统有关。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java","slug":"秋招/面试题/Java","permalink":"http://yoursite.com/categories/秋招/面试题/Java/"},{"name":"JVM","slug":"秋招/面试题/Java/JVM","permalink":"http://yoursite.com/categories/秋招/面试题/Java/JVM/"},{"name":"面经","slug":"秋招/面试题/Java/JVM/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java/JVM/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"计算机网络常见面试题","slug":"计算机网络常见面试题","date":"2018-10-04T02:09:09.000Z","updated":"2018-11-20T20:36:36.432Z","comments":true,"path":"2018/10/03/计算机网络常见面试题/","link":"","permalink":"http://yoursite.com/2018/10/03/计算机网络常见面试题/","excerpt":"","text":"TCP的三次握手和四次挥手? 为什么是3次，2次可以吗？4次呢？(从失效的数据报谈2次为什么不行，从响应时间说为什么不用4次)3次握手：a.客户端首先发送SYN请求报文b.服务端收到报文并返回客户端一个ACK确认报文，并分配资源c.客户端收到报文并返回服务端一个ACK确认报文，并分配资源建立连接（三次握手：客户端：“喂，你听得到吗？”SYN服务端：“我听得到呀，你听得到我吗？” ACK,SYN客户端：“我能听到你，今天balabala……” ）ACK（两次握手：客户端：“喂，你听得到吗？”服务端：“我听得到”客户端：…………客户端：“…………”客户端：…………客户端：“……你妹的”）（四次握手：客户端：“喂，你听得到吗？”服务端：“我听得到呀，你听得到我吗？”客户端：“我能听到你，你能听到我吗？”服务端：“……不想跟傻逼说话”）4次挥手：a.假设客户端向服务端发送FIN请求结束报文。b.服务端返回ACK报文，并且确认数据是否传送完毕。c.客户端收到ACK报文后，进入等待关闭状态，等待服务端发送FIN请求结束报文 （等待时间超过一定时间还没有收到ACK报文可以重传FIN请求报文）d.服务端数据传送完毕后发送FIN请求结束报文，客户端接受到后返回ACK，服务端客户端关闭TCP连接（客户端：我说完了（FIN）；服务端：我知道你说完了（ACK），我再给你说两句；服务端： 我说完了，咱们断了吧（FIN）客户端：我知道你说完了（ACK）） 浏览器从接收到一个URL到最后展示出页面，经历了哪些过程？大概进行以下3个步骤展示页面： 1.通过三次握手建立TCP的链接。 2.成功建立连接后，服务器会根据url请求中的信息进行处理，作出响应。一般是找到一个HTML文件返还给客户端。（一般的web技术都会把请求进行封装然后交给我们的服务器进行处理，比如servlet会把请求封装成httpservletrequest对象，把响应封装成httpsevletresponse对象） 3.客户端得到HTML文件，进行渲染。 长连接和短连接？在HTTP/1.0中，默认使用的是短连接。即浏览器和服务器每进行一次HTTP操作，就会建立一次连接，任务结束就断开连接。当浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（Js文件、css文件等），就会建立一个HTTP会话。在HTTP/1.1起，默认使用长连接。用以保持连接特性。【长连接通常在响应头会添加 Connection:keep-alive 】。使用长连接的情况下，当某个网页打开完毕之后，客户端和服务器之间的TCP连接不会关闭，如果客户端再次访问该服务器上的网页，会使用上一次已经建立的连接。长连接不是永久保持连接，它有一个保持时间。实现长连接的前提是客户端和服务器端都需要支持长连接。 长连接怎么实现的？从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive forward与redirect区别，说一下你知道的状态码，redirect的状态码是多少?直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。对于直接方式，客户端浏览器只发出一次请求，Servlet把请求转发给Servlet、HTML、JSP或其它信息资源，由第2个信息资源响应该请求，两个信息资源共享同一个request对象。对于间接方式，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。它本质上是两次HTTP请求，对应两个request对象。1 信息性状态码 接受的请求正在处理2 成功状态码 请求正常处理完毕3 重定向状态码 需要进行附加操作以完成请求4 客户端错误状态码 服务器无法处理请求5** 服务器错误状态码 服务器处理请求出错 GET和POST区别?GET用于获取数据，POST用于提交数据；GET把请求的数据放在url上，即header上；POST把数据放在HTTP的包体内（request body）；GET后退按钮/刷新无害，POST数据会被重新提交；GET书签可收藏，POST为书签不可收藏；GET能被缓存，POST不能缓存；编码类型不同；GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中；GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）；POST无限制；GET只允许ASCII字符；POST没有限制； cookie和session介绍一下区别?Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 cookie数据存放在客户的浏览器上，session数据放在服务器上； cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie； 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie； 把ip地址转化成mac地址的协议是什么协议？ARP协议是“Address Resolution Protocol”(地址解析协议)。 Ip地址几位？IPV4是32位，IPV6是128位。 讲讲Http协议？HTTP（超文本传输协议，HyperText Transfer Protocol)对器客户端和服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。 什么是Http协议无状态协议?怎么解决Http协议无状态协议?无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息；无状态协议解决办法： 通过1、Cookie 2、通过Session会话保存。 Http协议由什么组成?请求报文包括三部分:(1).请求行:包含请求方法,URI,HTTP版本协议；(2).请求首部字段；(3).请求内容实体；响应报文包含三部分:(1).响应行:包含HTTP版本,状态码,状态码原因短语；(2).响应首部字段；(3).响应内容实体； http1.1，1.0和2.0的区别? 长连接：HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。 节约带宽：HTTP 1.1支持只发送header信息； HOST域：HTTP 1.1现在web server设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。 多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 服务器推送：当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。 说下https的请求过程。 客户端向服务器发出加密请求； 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端； 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内； 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告； 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告； http，https，怎么实现的?后者是前者的安全实现，客户端发起请求时服务端会返回一个公匙，然后客户端根据公匙规则发送消息，服务端根据自己的配对密匙解密实现加密。https = http+ssl（安全套接字层） 输入一个网址到加载整个页面经历的整个过程。 输入地址 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）浏览器发送异步请求 tcp怎么实现拥塞控制？TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。TCP的拥塞控制采用的是窗口机制，通过调节窗口的大小实现对数据发送速率的调整。拥塞窗口调整的原则是：只要网络没有出现拥塞，就可以增大拥塞窗口，以便将更多的数据发送出去，相当于提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量，从而缓解网络的拥塞。 Tcp粘包？“粘包问题”的概念用一句话说：就是不同结构的多个包合成了一个大包，从而不知道怎么去把这个大包分割出原来的包。 arp攻击？ARP欺骗攻击建立在局域网主机间相互信任的基础上的当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b，可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ＩＰ是１９２.１６８.０.１，我的硬件地址是ｍａｃ－ｃ，此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。 知不知道一个应用层协议，运输层既没有使用TCP，也没有使用UDP？SCTP（Stream Control Transmission Protocol，流控制传输协议）是IETF（Internet Engineering Task Force，因特网工程任务组）在2000年定义的一个传输层（Transport Layer）协议，是提供基于不可靠传输业务的协议之上的可靠的数据报传输协议。SIP（Session Initiation Protocol，会话初始化协议）和SS7（Signaling System No.7，七号信令系统）。在商业领域中，您可以在Cisco的IOS（Inter-Operation Specification，互操作规范）中找到SCTP的影子。 转发与重定向（302）： 从地址栏显示来说forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说forward:转发页面和转发到的页面可以共享request里面的数据.redirect:不能共享数据. 从运用地方来说forward:一般用于用户登陆的时候,根据角色转发到相应的模块.redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 从效率来说forward:高.redirect:低. HTTP过程？ 详细讲下cookie和session，token，OAuth2.0协议","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"网络","slug":"秋招/面试题/网络","permalink":"http://yoursite.com/categories/秋招/面试题/网络/"},{"name":"面经","slug":"秋招/面试题/网络/面经","permalink":"http://yoursite.com/categories/秋招/面试题/网络/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"Java集合框架知识点总结","slug":"Java集合框架知识点总结","date":"2018-10-02T13:35:01.000Z","updated":"2018-11-20T20:36:56.097Z","comments":true,"path":"2018/10/02/Java集合框架知识点总结/","link":"","permalink":"http://yoursite.com/2018/10/02/Java集合框架知识点总结/","excerpt":"","text":"一、Map1. HashMap hashMap和ConcurrentHashMap的区别？ConcurrentHashMap：java5中新增了ConcurrentMap接口和它的一个实现类ConcurrentHashMap。ConcurrentHashMap具体是怎么实现线程安全的呢？从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。hashMap： 从JDK1.2起，就有了HashMap，正如前一篇文章所说，HashMap不是线程安全的，因此多线程操作时需要格外小心。 hashMap内部具体如何实现的？HashMap是典型的空间换时间的一种技术手段。HashMap底层使用哈希表（数组 + 链表 + 红黑树）实现。 （1）put()方法：存储对象时，我们将K/V传给put方法时，对key的hashCode做hash操作得到桶中的存储位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。 （2）get()方法：获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，如果产生碰撞，进一步调用equals()方法确定键值对。 （3）哈希碰撞：如果发生碰撞（键的哈希值存在冲突碰撞，也就是不同的键的哈希值可能相等）的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 （4）解决碰撞的方法有： 1. 链地址法/拉链法（Hashmap使用）：就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面）占用空间又少呢？答案就是好的Hash算法和扩容机制。首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。超过threshold这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。 2. 再哈希法：就是算hashcode的方法不止一个，一个要是算出来重复啦，再用另一个算法去算。 3. 开放地址法：当发生地址冲突后，求解下一个地址用。 （5）HashMap的扩容机制：当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的 默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。 （6）HashMap中hash函数怎么是是实现的？还有哪些 hash 的实现方式？ 1. 对key的hashCode做hash操作（高16bit不变，低16bit和高16bit做了一个异或； 2. h &amp; (length-1); //通过位操作得到下标index； 如果hashMap的key是一个自定义的类，怎么办？使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。 因为在HashMap中，如果要比较key是否相等，要同时使用这两个函数。equals()很明显是对两个对象的地址值进行的比较（即比较引用是否相同）. HashMap与HashTable区别？HashMap的一些特性，譬如HashMap可以接受null键（只能有1个null键）和值，而Hashtable则不能；HashMap是非synchronized;HashMap非线程安全，但是个很快。 为什么String, Interger这样的类适合作为键？因为这些对象是不可变的，而且已经重写了equals()和hashCode()方法了。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等等。 能否让HashMap同步？HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap); 为什么重写equals一定要重写hashCode？面临问题：若两个对象equals相等，但不在一个区间，根本没有机会进行比较，会被认为是不同的对象。所以Java对于eqauls方法和hashCode方法是这样规定的： 如果两个对象相同，那么它们的hashCode值一定要相同。也告诉我们重写equals方法，一定要重写hashCode方法。 如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较。 你了解重新调整HashMap大小存在什么问题吗？当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。HashMap在resize时候如果多个线程并发操作如何导致死锁。此时为什么不使用CocurrentHashMap? 设计一个HashMap。自己写一个HashMap 为什么HashMap初始容量是16？HashMap的容量是2的n次方？hash()方法：因为HashMap要求key的hashCode值分布越均匀性能就越好。所以HashMap内部有一个hash()方法，能够对hashCode进行重新计算，以期望得到更加分布均衡的hashCode值。indexFor()方法是根据hash值和Entry[]的长度进行取模运算，确定数组的index。在计算机数学里有这么一个法则：当SIZE满足大小是2的幂的时候，X % SIZE（取模操作）和 X &amp; (SIZE-1）是等价的。并且后者的效率更高。 Map有几种遍历方式？keySet集合迭代，entrySet集合迭代，keySet 集合for-each 循环，entrySet集合for-each循环。（for,Iterator） ==比较的是什么？ equals方法与‘==’运算符有什么区别？为什么重写equals一定要重写hashcode？对于基本数据类型，==比较的是他们的值；对于引用数据类型，==比较的是他们在内存中的存放地址；在Object类中equals()方法实际上是判断两个对象是否具有相同的引用。默认情况下也就是从超类Object继承而来的equals方法与‘==’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。Map接口的类会使用到键对象的哈希码，当我们调用put方法或者get方法对Map容器进行操作时，都是根据键对象的哈希码来计算存储位置的，因此如果我们对哈希码的获取没有相关保证，就可能会得不到预期的结果。 为什么hashmap的大小初始值为16?为什么初始加载因子设置为0.75？如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小；加载因子设置为0.75而不是1，是因为设置过大，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，性能下降，设置过小也不合适，如果是0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。 Object若不重写hashCode()的话，hashCode()如何计算出来的？说如果对象不重写该方法，则返回相应对象的JVM内存地址的映射。public native int hashCode();native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。JNI允许Java代码使用以其他语言编写的代码和代码库。 Object作为HashMap的key的话，对Object有什么要求吗？如果HashMap Key的哈希值在存储键值对后发生改变，Map可能再也查找不到这个Entry了。如果Key对象是可变的，那么Key的哈希值就可能改变。在HashMap中可变对象作为Key会造成数据丢失。在HashMap中使用不可变对象作为key。在HashMap中，使用String、Integer等不可变类型用作Key是非常明智的。如果可变对象在HashMap中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。 如何自实现一个不可变（Immutable）类？定义类的时候，对用于计算hashCode的某个数据域只给get方法，而不提供set方法，使其不能被改变。 问HashMap什么情况下发生死链 2. HashtableHashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 Hashtable对null的处理是怎样的？在使用Hashtable时，如果传入的键的值为空，则会抛出NullPointerException。而HashMap中可以存放键为null的映射。 3. LinkedHashMapLinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。可以作为Queue的实现类。 4. TreeMapTreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 TreeMap底层实现原理？红黑树原理?红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。红黑树的规则： 每个节点都只能是红色或者黑色 根节点是黑色 每个叶节点（NIL节点，空节点）是黑色的。 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。所以红黑树它是复杂而高效的，其检索效率O(log n)。 二、Collection1. List可以允许重复的对象。可以插入多个null元素。是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List中添加或删除元素的场合更为合适。 ArrayList和LinkedList？LinkedList,ArrayList末尾插入谁效率高？ArrayList和LinkedList都实现了List接口。ArrayList的底层实现用的是数组，LinkedList实现是基于链表，ArrayList适合查找，LinkedList适合增删。在末尾插入的话，ArrayList效率更高。 ArrayList的sublist修改是否影响list本身？ArrayList.subList(int fromIndex, int toIndex)方法返回一个List: 此List的值包含fromIndex所在的值, 但不包含toIndex所在的值. 如果fromIndex等于toIndex, 那么会返回一个没有任何元素的空List. 返回的List支持java.util.List接口的所有操作.ArrayList的subList方法获取到的是ArrayList的一段list，只是其中的一段视图。所以修改subList, ArrayList同时会修改，因为本来就是同一个东西。 ArrayList和LinkedList你知道吗？你知道它怎么动态扩容的吗？ArrayList的底层是动态数组，初始容量为10，增长因子为1.5。jdk1.8时，ArrayList的扩充规则为：当第一次调用add方法时，首先对数组中元素的个数进行增加，其次调用ensureExplicitCapacity方法进行数组的初始化工作，接着调用ensureExplicitCapacity方法查看已有的元素是否大于数组的长度，如果不大于则不进行扩充，如果大于则进行调用grow方法进行扩充。扩充一共分为5步，第一步先获取原数组容量，然后设置新数组的容量是原数组容量的1.5倍，如果新容量小于老容量则将老容量的值设置给新容量。如果新容量的值大于数组的最大值调用hugeCapacity方法。最后调用copyOf在原数组上增加容量。 2. Set Set如何保证不重复？因为map中的key是不允许重复的，所以set中的元素不能重复。HashSet中add()中调用了HashMap的put()，将一个key-value对放入HashMap中。add方法的参数（要存储的value）作为HashMap的key，PRESENT（Object PRESENT = new Object();）作为固定value。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后用这个值计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java集合框架","slug":"秋招/面试题/Java集合框架","permalink":"http://yoursite.com/categories/秋招/面试题/Java集合框架/"},{"name":"面经","slug":"秋招/面试题/Java集合框架/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java集合框架/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://yoursite.com/tags/Java集合框架/"}]},{"title":"Java基础知识总结","slug":"Java基础知识","date":"2018-09-08T00:01:11.000Z","updated":"2018-11-20T20:35:44.602Z","comments":true,"path":"2018/09/07/Java基础知识/","link":"","permalink":"http://yoursite.com/2018/09/07/Java基础知识/","excerpt":"","text":"递归方式遍历文件夹？ public void traverseFolder2(String path) { File file = new File(path); if (file.exists()) { File[] files = file.listFiles(); if (files.length == 0) { System.out.println(\"文件夹是空的!\"); return; } else { for (File file2 : files) { if (file2.isDirectory()) { System.out.println(\"文件夹:\" + file2.getAbsolutePath()); traverseFolder2(file2.getAbsolutePath()); } else { System.out.println(\"文件:\" + file2.getAbsolutePath()); } } } } else { System.out.println(\"文件不存在!\"); 为啥有时会出现4.0-3.6=0.40000001这种现象？浮点数运算丢失精度。4.0的二进制表示并非是精确的4.0，反而最为接近的二进制表示是4.00000001。而至于为什么有些浮点计算会得到准确的结果，应该也是碰巧那个计算的二进制与十进制之间能够准确转换。 一个十进制的数在内存中是怎么存的？用二进制存储。第一位是符号位。 abstract interface区别？从语言层面上： 抽象类可以有非抽象方法，而接口中只能存在抽象方法（默认 public abstract） 抽象类中的成员变量可以是多种类型，而接口中的成员变量必须用public static final(常量)修饰 一个类只能继承一个抽象类（单继承），但可以实现多个接口（多继承）。 抽象类中允许含有静态代码块和静态方法，而接口类不能。 设计层面上：抽象类可以类比为模板，而接口可以类比为协议；抽象类是对整一个类的属性，行为等方面进行抽象，而接口则是对行为抽象； 有抽象方法一定是抽象类吗？抽象类一定有抽象方法吗？抽象方法一定在抽象类中；抽象类可以没有抽象方法； super()和this()能不能同时使用?在构造函数中，不能同时出现。因为this 与super 调用构造函数时，都必须第一行，这样导致他们不能同时使用，但你并不需要担心没有初始化父类。因为，this 最终指向的子类构造函数中，一定会调用super() 初始化父类，默认的或者带参的。 String,StringBuffer,StringBuilder区别?String内容不可变，StringBuffer和StringBuilder内容可变；StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String为什么不可变?String 的底层实现是依靠 char[] 数组，既然依靠的是基础类型变量，那么他一定是可变的， String 之所以不可变，是因为Java的开发者通过技术实现，隔绝了使用者对String的底层数据的操作。 String，是否可以继承，“+”怎样实现?String类是用final关键字修饰，所以不可以继承；String为不可变的，每次String对象做累加时都会创建StringBuilder对象，使用StringBuilder的append的方法实现+操作。 Final关键字。 final关键字可以用于局部变量、成员变量、方法以及类。 final修饰变量时，必须在声明的时候初始化，并且不能够再次对final的变量赋值； final方法不能被重写。 final类不能被继承。 在匿名类中所有变量都必须是final变量。 接口中声明的所有变量本身是final的。 final和abstract这两个关键字是反相关的，final类就不可能是abstract的。 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。 按照Java代码惯例，final变量就是常量，而且通常常量名要大写。 Object类中常用的方法？ clone()浅拷贝：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。 getClass()：返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。 equals():Object原生的equals()方法内部调用的正是==，与==具有相同的含义。 hashCode()返回一个整形数值，表示该对象的哈希码值。 toString()：toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。 wait(…)：wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 notify() / notifyAll()方法:唤醒在此对象监视器上等待的单个线程/所有线程。 finalize()：Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的。 说下Java的克隆体系？Java中跟克隆有关的两个类分别是Cloneable接口（标志接口）和Object类中的clone方法，通过两者的协作来实现克隆。在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。注意：在克隆方法中，如果我们需要对可变对象的final域也进行拷贝，由于final的限制，所以实际上是无法编译通过的。因此为了实现克隆，我们需要考虑舍去该可变对象域的final关键字。如果你决定用线程安全的类实现Cloneable接口，需要保证它的clone方法做好同步工作。默认的Object.clone方法是没有做同步的。 抽象方法和类方法的区别，static的抽象方法可以吗？用static声明方法表明这个方法在不生成类的实例时可直接被类调用，而abstract方法没有方法体不能被调用，两者矛盾。 Java的四个特性。抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于抽取多类事物的共性。多态：父类引用可以指向子类对象，更好的可扩展性和可维护性。允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。 Switch-case语句中能用的基本数据类型？byte,short，char，int四种整形类型，jdk1.5后支持枚举类型，java.lang.String类型（从java 7才允许）； Integer与int区别?Integer是int的包装类，是引用数据类型；int则是java的一种基本数据类型;Integer与int的比较： 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同） Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。Java对于-128到127之间的数，会进行缓存； 重写和重载区别？重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。 Java会不会内存泄漏？会发生。举例：因为arrays数值中任然持有着它的引用，所以内存泄漏。`public Object pop(){ Object object=arrays[size]; size--; return object;}` String中equal()怎么实现的？ 若当前对象和比较的对象是同一个对象，即return true。也就是Object中的equals方法。 若当前传入的对象是String类型，则比较两个字符串的长度，即value.length的长度。 2.1 若长度不相同，则return false; 2.2 若长度相同，则按照数组value中的每一位进行比较，不同，则返回false。若每一位都相同，则返回true。3.若当前传入的对象不是String类型，则直接返回false Final.finally.finanize区别？final关键字可以用于类，方法，变量前，用来表示该关键字修饰的类，方法，变量具有不可变的特性。finalize方法来自于java.lang.Object，用于回收资源。可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用；finally在异常处理时提供finally块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch子句就会执行，然后控制就会进入finally块； JDK中哪些实现了单例模式？java.lang.reflect.Proxy类，java.lang.Runtime类，线程池。 如果A类要访问B类中的字段,要怎么去设计?在B类中使用getter和setter；或者匿名内部类； static关键字的用法？static是java中非常重要的一个关键字，而且它的用法也很丰富，主要有四种用法：用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；用来修饰成员方法，将其变为类方法，可以直接使用“类名.方法名”的方式调用，常用于工具类；静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。 Java中的泛型是什么 ? 使用泛型的好处是什么?泛型是参数化类型。提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。 Java的泛型是如何工作的 ? 什么是类型擦除 ?泛型是通过类型擦除来实现的。编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。 10 道 Java 泛型面试题 HashTable和HashMap区别： 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数 如果finally块中有return语句的话，它将覆盖掉函数中其他return语句。 sleep和wait的区别有： 这两个方法来自不同的类分别是Thread和Object 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用synchronized(x){x.notify()//或者wait()} sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常；？？？ 类中的成员变量，存放在堆区;局部变量，存放在栈区. 集合框架中线程安全的类：喂（Vector）S（Stack）H（hashtable）E（enumeration）。 栈区：存放函数的参数、局部变量等；堆区：存放对象；全局区(静态区)：存放全局变量和静态变量；常量区：存放常量字符串；代码区：存放函数体的二进制代码。 接口与抽象类：接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。另外，接口和抽象类在方法上有区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中的抽象方法的访问类型可以是public，protected和默认类型 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型 一个类可以实现多个接口，但只能继承一个抽象类。二者在应用方面也有一定的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。 泛型： 只看尖括号里边的！！明确点和范围两个概念 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt; 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值 List&lt;?&gt;和List是相等的，都代表最大范围； 补充：List既是点也是范围，当表示范围时，表示最大范围 父类静态域——》子类静态域——》父类成员初始化——》父类构造块——》父类构造方法——》子类成员初始化——》子类构造块——》子类构造方法 接口中的成员变量：为什么是public：因为接口必然是要被实现的，如果不是public，这个属性就没有意义了；为什么是static：因为如果不是static，那么由于每个类可以继承多个接口，那就会出现重名的情况；为什么是final：这是为了体现java的开闭原则，因为接口是一种模板，既然是模板，那就对修改关闭，对扩展开放。 Java中的异常处理？三种类型的异常：(1)检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。(2)运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。(3)错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。 String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？（1）可变性：String类中使用字符数组private final char value[]保存字符串，所以String对象是不可变的;（2）线程安全性：String中的对象是不可变的，线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。（3）性能：相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 什么是反射机制？反射机制的应用场景有哪些？JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例;4)动态配置实例的属性 Java IO 什么是流,按照传输的单位,分成哪两种流,并且他们的父类叫什么流是指数据的传输？字节流，字符流字节流：InputStream OutputStream字符流：Reader Writer float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true，内存是怎样的？ Java递归栈最深能递归多少次 内部类 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法; Inner 类中定义的方法可以直接访问Outer类中的数据，而不受访问控制符的影响。 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类(); 其他 进程和线程的区别？（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 （2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 （4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 （5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 （6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 Abstract不能跟哪些关键字共用？ static，private，final 匿名内部类只针对一个方法使用。 开发中，匿名内部类当作参数传递。把匿名内部类看成一个对象。 链式编程：调用一个方法后，紧接着调用另外方法。证明调用方法返回的是对象。 &amp;&amp;和&amp;的区别?a:最终结果一样。b:&amp;&amp;具有短路效果。左边是false，右边不执行。&amp;是无论左边是false还是true,右边都会执行 交换两个数字（不用第三方变量）？x = x + y;y = x - y;x = x - y;","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"Java","slug":"秋招/Java","permalink":"http://yoursite.com/categories/秋招/Java/"},{"name":"基础","slug":"秋招/Java/基础","permalink":"http://yoursite.com/categories/秋招/Java/基础/"},{"name":"面经","slug":"秋招/Java/基础/面经","permalink":"http://yoursite.com/categories/秋招/Java/基础/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"秋招总结","slug":"秋招总结","permalink":"http://yoursite.com/tags/秋招总结/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"牛客网Java面试常考知识点总结","slug":"牛客网Java面试常考知识点总结","date":"2018-09-05T14:20:18.000Z","updated":"2018-11-20T20:36:16.919Z","comments":true,"path":"2018/09/05/牛客网Java面试常考知识点总结/","link":"","permalink":"http://yoursite.com/2018/09/05/牛客网Java面试常考知识点总结/","excerpt":"","text":"字符串间比较：12345678910111213141516public class Demo &#123; public static void main(String args[]) &#123; String str1 = new String(&quot;hello&quot;); String str2 = new String(&quot;hello&quot;); String str3 = &quot;hello&quot;; String str4 = &quot;hello&quot;; String str5 = &quot;he&quot;+&quot;llo&quot;; String str6 = &quot;he&quot;; String str7 = &quot;llo&quot;; System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str3==str4); System.out.println(str3==&quot;hello&quot;); System.out.println(str4==(str6+str7)); &#125;&#125; 上面代码的输出结果是：false false true true false String str1 = new String(&quot;hello&quot;);这种方式创建的字符串，和正常创建对象一样，保存在堆区。String str3 = &quot;hello&quot;;这种方式创建的字符串，保存在字符串常量区。 CGI(Common Gateway Interface)和servlet 的总结与对比： CGI: 主要用Perl、Shell Script或C编写Servlet:用java语言编写 CGI：每个请求都会启动一个新的进程，每个进程只为一个客户所服务，导致服务器内存和cpu开销大。Servlet：每个请求会产生新的线程，而不是进程，减少系统中进程数量，并发处理能力强。多个客户能在同一个进程中的同时得到服务。 CGI进程在服务完成后就被销毁，所以效率上低于servlet。Servlet进程（实例）处于服务器进程中，只有在服务器被卸载时才会被卸载。 CGI是不可移植的，是运行于特定平台上的。Servlet是可移植的，运行于JVM上的。 基本类型与包装类型的比较： 基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较 一个文件中，可以有多个public class。一个类中可以有两个main方法。 集合中线程安全的类有：vector，stack，hashtable，enumeration，除此之外均是非线程安全的类与接口 HashTable和HashMap区别： 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 引用类型只有String可以直接赋值，其他的都要new出来。 成员内部类前面可以修饰public,protected和private；可以把局部内部类当做一个局部变量，所以它是不需要加任何修饰符的。局部内部类前不能用修饰符public和private,protected，内部类就随意了。 如果finally块中有return语句的话，它将覆盖掉函数中其他return语句。 &lt;&lt;表示左移位 &gt;&gt;表示带符号右移位；&gt;&gt;&gt;表示无符号右移；但是没有&lt;&lt;&lt;运算符 exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。 LinkedBlockingQueue是一个可选有界队列，不允许null值；PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）；LinkedBlockingQueue是线程安全的；PriorityQueue底层实现是小根堆，不是FIFO的； 对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们；成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）；匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用；静态内部类不能直接访问外部类的非静态成员，但可以通过new外部类（）.成员的方式访问。 类中实例变量可以不用初始化，使用相应类型的默认值即可；方法中的定义的局部变量必须初始化，否则编译不通过。 sleep和wait的区别有： 这两个方法来自不同的类分别是Thread和Object 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用synchronized(x){x.notify()//或者wait()} sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 类中的成员变量，存放在堆区;局部变量，存放在栈区. super.getClass().getName();//返回：包名+类名 Java中的byte，short，char进行计算时都会提升为int类型。而声明为final的变量会被JVM优化。 jre 判断程序是否执行结束的标准是所有的前台线程执行完毕。使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。 集合框架中线程安全的类：喂（Vector）S（Stack）H（hashtable）E（enumeration）。 列表（List）的元素是有 序、可重复的；集合（Set）的元素是无序、不可重复的。 非运行异常=检查异常 需要try catch捕获或者throws抛出。 栈区：存放函数的参数、局部变量等；堆区：存放对象；全局区(静态区)：存放全局变量和静态变量；常量区：存放常量字符串；代码区：存放函数体的二进制代码。 const和goto是保留字。 return i++, 先返回i，然后i+1。 Java8的接口方法可以有如下定义：only public, abstract, default, static and strictfp are permitted ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小； StringBuffer s = new StringBuffer(x); x为初始化容量长度 HashTable与HashMap: HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对） HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。 Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。Hashtable和HashMap的区别主要是前者是同步的，后者是快速失败机制保证. java对于String类型的相加是通过StringBuffer实现的，先构造一个StringBuffer对象来存放tao，然后通过append方法追加上bao。StringBuffer对象的分配是在堆上的。 java object默认的基本方法中没有copy()，含有如下方法：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize(). 程序运行时异常由Java虚拟机自动进行处理. super是java提供的一个关键字，super用于限定该对象调用它从父类继承得到的Field或方法。super关键字不能出现在static修饰的方法中，因为static修饰的方法是属于类的。如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的field，而不是该类自己定义的field。需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。 str1指向常量池中的字符串；str2是通过StringBuilder类new出的对象，指向堆。故为false. 123String str1 = &quot;hello&quot;;String str2 = &quot;he&quot; + new String(&quot;llo&quot;);System.err.println(str1 == str2); 父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法； ResultSet跟普通的数组不同，索引从1开始而不是从0开始. 接口与抽象类：接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。另外，接口和抽象类在方法上有区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中的抽象方法的访问类型可以是public，protected和默认类型 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型 一个类可以实现多个接口，但只能继承一个抽象类。二者在应用方面也有一定的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。 Java标识符由数字、字母、下划线(_)、美元符号($)或人民币(¥)组成，首位不能是数字。并且Java关键字不能作为标识符。 会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程;对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”; HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据； 抛出一个异常时可以终止当前线程的运行. ThreadLocal类用于创建一个线程本地变量在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。ThreadLocal的使用场景：数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。 泛型： 只看尖括号里边的！！明确点和范围两个概念 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt; 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值 List&lt;?&gt;和List是相等的，都代表最大范围； 补充：List既是点也是范围，当表示范围时，表示最大范围 服务器端通过new ServerSocket()创建TCP连接对象；服务器端通过TCP连接对象调用accept()方法创建通信的Socket对象；客户端通过new Socket()方法创建通信的Socket对象。 Java中类是单继承，但接口可以多继承，Interfere1 extends Interface2,Interface3… 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ），其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。 所谓 volatile的措施，就是： 每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。 volatile保证了其他线程的立即可见性，就没有保证原子性。 由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。 hashcode和equals的约定关系如下： 如果两个对象相等，那么他们一定有相同的哈希值（hash code）。 如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断） private方法是可以继承的，只是不能调用. ArrayList的底层是数组，数组通过索引可以快速查找，但是增删都要移动元素的位置，所以增删效率低。LinkedList底层是链表，链表查找只能顺序查找，不能随机查找，所以查找的效率低; 真数组： 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性. 造成Full GC的原因： 年老代被写满 持久代被写满 显示调用System.GC 上一个GC后个heap的各域分配策略动态变化。 构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。 Java表达式转型规则由低到高转换： 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型； 被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。 运行时异常 包括：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常（编译异常） 包括：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常 int i = 0; i = i++;什么都没做。 两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally子句的内容将被执行。 join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。 父类没有无参的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数。 静态语句块中x为局部变量，不影响静态变量x的值。 System是java.lang包下的一个类，out为System的final静态成员（PrintStream类型），println()是PrintStream类的实例方法。 抽象类有构造方法，但是不能new一个对象。 String(大姐，出生于JDK1.0时代) 不可变字符序列 &lt;StringBuffer(二姐，出生于JDK1.0时代) 线程安全的可变字符序列 &lt;StringBuilder(小妹，出生于JDK1.5时代) 非线程安全的可变字符序列。 转发与重定向（302）： 从地址栏显示来说forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说forward:转发页面和转发到的页面可以共享request里面的数据.redirect:不能共享数据. 从运用地方来说forward:一般用于用户登陆的时候,根据角色转发到相应的模块.redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 从效率来说forward:高.redirect:低. 抽象类的方法可以是public protected的，接口的方法只能是public的. wait必须捕获异常 并且需要用当前synchronized锁对象进行调用. 管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向 的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容 量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。当管道满时，进程在 写管道会被阻塞，而当管道空时，进程读管道会被阻塞。 重写接口中的方法，访问权限一定是public。 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。 基本数据类型，比较的时候比较的是数值、 对该数据加锁，放在同步代码块中。 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理） Struts1和2的区别：Struts1和Struts2的区别和对比:Action 类: Struts1要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口，而struts2的Action是接口。 Struts 2 Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts2提供一个ActionSupport基类去 实现 常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。线程模式: Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。 Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）Servlet 依赖: Struts1 Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和 HttpServletResponse 被传递给execute方法。 Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。可测性: 测试Struts1 Action的一个主要问题是execute方法暴露了servlet API（这使得测试要依赖于容器）。一个第三方扩展－－Struts TestCase－－提供了一套Struts1的模拟对象（来进行测试）。 Struts 2 Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。捕获输入: Struts1 使用ActionForm对象捕获输入。所有的ActionForm必须继承一个基类。因为其他JavaBean不能用作ActionForm，开发者经常创建多余的类捕获输入。动态Bean（DynaBeans）可以作为创建传统ActionForm的选择，但是，开发者可能是在重新描述(创建)已经存 在的JavaBean（仍然会导致有冗余的javabean）。 Struts 2直接使用Action属性作为输入属性，消除了对第二个输入对象的需求。输入属性可能是有自己(子)属性的rich对象类型。Action属性能够通过 web页面上的taglibs访问。Struts2也支持ActionForm模式。rich对象类型，包括业务对象，能够用作输入/输出对象。这种 ModelDriven 特性简化了taglib对POJO输入对象的引用。表达式语言： Struts1 整合了JSTL，因此使用JSTL EL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。 Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－”Object Graph Notation Language” (OGNL). 创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前。 枚举类 所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化。 JDK中提供的java、javac、jar等开发工具也是用Java编写的。底层实现c语言。 创建Statement是不传参的，PreparedStatement是需要传入sql语句。 父类静态域——》子类静态域——》父类成员初始化——》父类构造块——》父类构造方法——》子类成员初始化——》子类构造块——》子类构造方法 淡云一笔安洛三福 单目&gt;算数运算符&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 两个最基本的java回收算法：复制算法和标记清理算法复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象两个概念：新生代和年老代新生代：初始对象，生命周期短的永久代：长时间存在的对象整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理Parallel Old（并行）收集器，针对老年代，标记整理CMS收集器，基于标记清理G1收集器：整体上是基于标记 整理 ，局部采用复制综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。 DBMS中事务有四个特性，持久性，一致性，原子性，隔离性，持久性实现恢复管理子系统，一致性实现并发控制子系统，原子性实现完整性管理子系统，隔离性实现安全控制管理子系统. 抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含. Java程序的种类有：（a）内嵌于Web文件中，由浏览器来观看的_Applet（b）可独立运行的 Application（c）服务器端的 Servlets 依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁. 接口中的成员变量：为什么是public：因为接口必然是要被实现的，如果不是public，这个属性就没有意义了；为什么是static：因为如果不是static，那么由于每个类可以继承多个接口，那就会出现重名的情况；为什么是final：这是为了体现java的开闭原则，因为接口是一种模板，既然是模板，那就对修改关闭，对扩展开放。 finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，但是不建议在finally中return。 suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态. 抛InterruptedException的代表方法有：java.lang.Object 类的 wait 方法java.lang.Thread 类的 sleep 方法java.lang.Thread 类的 join 方法 动态include和静态include区别：静态的include：是jsp的指令来实现的，&lt;% @ include file=”xx.html”%&gt; 特点是 共享request请求域，先包含再编译，不检查包含页面的变化。动态的include：是jsp动作来实现的，&lt;jsp:include page=”xx.jsp” flush=”true”/&gt; 这个是不共享request请求域，先编译在包含，是要检查包含页面的变化的。 并不是静态块最先初始化,而是静态域.(BM：啊!多么痛的领悟!)而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的! 静态变量和静态代码块的执行顺序就是代码前后的顺序。 在jdk1.8之前声明抽象方法不可写出大括号。 java 虚拟机，对于方法的调用采用的是栈帧（方法调用和方法执行），调用则入栈，完成之后则出栈。不就回收了内存资源而针对于其他，GC回收的时间不定。 byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候（比如先前的引用变量x=null时），才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因。总结起来就是对象存储在堆内存，引用变量存储在栈内存。栈内存指向堆内存。 java继承中对构造函数是不继承的，只是显式或者隐式调用。 默认ArrayList的长度是10个。 导包只可以导到当前层，不可以再导入包里面的包中的类。 java 1.8开始支持接口中定义静态方法。 堆区：只存放类对象，线程共享；方法区：又叫静态存储区，存放class文件和静态数据，线程共享;栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享; public Method[] getDeclaredMethods()返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。 SimpleDateFormat是线程不安全的。 截止JDK1.8版本,java并发框架支持锁包括读写锁，自旋锁，乐观锁。 Hibernate鼓励使用双向一对多关联，不使用单向一对多关联。单向一对多关联映射是在one端维护关系的，必须先保存many端后才可以保存one端，所以在保存many端时该端不知道one端是否存在相应的数据，所以只能将维护的关系字段设置为null，如果为非空则无法保存。因为是one端维护关系，所以在保存one端时，会发出多余的update语句维护many端的外键关系。 在jvm中 是使用监视器锁来实现不同线程的异步执行,在语法的表现就是synchronized 。 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱；包装类的equals()方法不处理数据转型。","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"Java","slug":"秋招/面试题/Java","permalink":"http://yoursite.com/categories/秋招/面试题/Java/"},{"name":"面经","slug":"秋招/面试题/Java/面经","permalink":"http://yoursite.com/categories/秋招/面试题/Java/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2018-09-02T16:41:00.000Z","updated":"2018-11-18T21:04:55.481Z","comments":true,"path":"2018/09/02/ArrayList源码分析/","link":"","permalink":"http://yoursite.com/2018/09/02/ArrayList源码分析/","excerpt":"","text":"ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。ArrayList继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391package java.util;import sun.misc.SharedSecrets;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;/** * 概述： * List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。 * 除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。 * 时间复杂度： * 方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。 * 添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。 * 容量： * 每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。 * 容量可以自动增长。 * 如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。 * 也可以通过带初始容量的构造器初始化这个容量。 * 线程不安全： * ArrayList不是线程安全的。 * 如果需要应用到多线程中，需要在外部做同步 * modCount： * 定义在AbstractList中：protected transient int modCount = 0; * 已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。 * 此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。 * 如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。 * 在迭代期间面临并发修改时，它提供了快速失败 行为，而不是非确定性行为。 * 子类是否使用此字段是可选的。 * 如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。 * 对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 concurrentmodificationexceptions。 * 如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。 * transient： * 默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8) */public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空的对象数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认的空数组 * 无参构造函数创建的数组 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 存放数据的数组的缓存变量，不可序列化 */ transient Object[] elementData; /** * 元素数量 * * @serial */ private int size; /** * 带有容量initialCapacity的构造方法 * * @param 初始容量列表的初始容量 * @throws IllegalArgumentException 如果指定容量为负 */ public ArrayList(int initialCapacity) &#123; // 如果初始化时ArrayList大小大于0 if (initialCapacity &gt; 0) &#123; // new一个该大小的object数组赋给elementData this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;// 如果大小为0 // 将空数组赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;// 小于0 // 则抛出IllegalArgumentException异常 throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125; &#125; /** * 不带参数的构造方法 */ public ArrayList() &#123; // 直接将空数组赋给elementData this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 带参数Collection的构造方法 * * @param c 其元素将被放入此列表中的集合 * @throws NullPointerException 如果指定的集合是空的 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toarray可能（错误地）不返回对象[]（见JAVA BUG编号6260652） if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 使用空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 因为容量常常会大于实际元素的数量。内存紧张时，可以调用该方法删除预留的位置，调整容量为元素实际数量。 * 如果确定不会再有元素添加进来时也可以调用该方法来节约空间 */ public void trimToSize() &#123; modCount++; // 如果size小于length if (size &lt; elementData.length) &#123; // 重新将elementData设置大小为size elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * 使用指定参数设置数组容量 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，容量预取0，否则去默认值(10) int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; //若参数大于预设的容量，在使用该参数进一步设置数组容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; /** * 得到最小扩容量 * * @param minCapacity */ private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; /** * 判断是否需要扩容 * * @param minCapacity */ private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果最小需要空间比elementData的内存空间要大，则需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 数组的最大容量，可能会导致内存溢出(VM内存限制) */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容，以确保它可以至少持有由参数指定的元素的数目 * * @param minCapacity 所需的最小容量 */ private void grow(int minCapacity) &#123; // 获取到ArrayList中elementData数组的内存空间长度 int oldCapacity = elementData.length; // 扩容至原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， // 不够就将数组长度设置为需要的长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //若预设值大于默认的最大值检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间 // 并将elementData的数据复制到新的内存空间 elementData = Arrays.copyOf(elementData, newCapacity); &#125; /** * 检查是否溢出，若没有溢出，返回最大整数值(java中的int为4字节，所以最大为0x7fffffff)或默认最大值 * * @param minCapacity * @return */ private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) //溢出 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回ArrayList的大小 * * @return ArrayList中的元素数量 */ public int size() &#123; return size; &#125; /** * 返回是否为空 * * @return true 如果ArrayList中无元素 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 是否包含一个数 返回bool * * @param o 检测o是否为ArrayList中元素 * @return true 如果ArrayList中包含o元素 */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回一个值在数组首次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回一个值在数组最后一次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N) * * @param o * @return */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回副本，元素本身没有被复制，复制过程数组发生改变会抛出异常 * * @return v ArrayList副本 */ public Object clone() &#123; try &#123; // 调用父类(翻看源码可见是Object类)的clone方法得到一个ArrayList副本 ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用Arrays类的copyOf，将ArrayList的elementData数组赋值给副本的elementData数组 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; // 返回副本v return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * 转换为Object数组，使用Arrays.copyOf()方法 * * @return 一个数组包含所有列表中的元素, 且顺序正确 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 将ArrayList里面的元素赋值到一个数组中去 * 如果a的长度小于ArrayList的长度，直接调用Arrays类的copyOf，返回一个比a数组长度要大的新数组，里面元素就是ArrayList里面的元素； * 如果a的长度比ArrayList的长度大，那么就调用System.arraycopy，将ArrayList的elementData数组赋值到a数组，然后把a数组的size位置赋值为空。 * * @param a 如果它的长度大的话，列表元素将存储在这个数组中; 否则，将为此分配一个相同运行时类型的新数组。 * @return 一个包含ArrayList元素的数组 * @throws ArrayStoreException 将与数组类型不兼容的值赋值给数组元素时抛出的异常 * @throws NullPointerException 数组为空 */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // 创建一个新的a的运行时类型数组，内容不变 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; /** * 返回指定位置的值，因为是数组，所以速度特别快 * * @param index * @return */ @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回指定位置的值，但是会先检查这个位置数否超出数组长度 * * @param index 要返回的元素的索引 * @return ArrayList中指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 检查是否越界 rangeCheck(index); // 返回ArrayList的elementData数组index位置的元素 return elementData(index); &#125; /** * 设置指定位置为一个新值，并返回之前的值，会检查这个位置是否超出数组长度 * * @param index 要替换的元素的索引 * @param element 要存储在指定位置的元素 * @return 之前在指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; // 检查是否越界 rangeCheck(index); // 调用elementData(index)获取到当前位置的值 E oldValue = elementData(index); // 将element赋值到ArrayList的elementData数组的第index位置 elementData[index] = element; return oldValue; &#125; /** * 添加一个值，首先会确保容量 * * @param e 要添加到此列表中的元素 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将e赋值给elementData的size+1的位置 elementData[size++] = e; return true; &#125; /** * 在ArrayList的index位置，添加元素element，会检查添加的位置和容量 * * @param index 指定元素将被插入的索引 * @param element 要插入的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 判断index是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) //src:源数组； srcPos:源数组要复制的起始位置； dest:目的数组； destPos:目的数组放置的起始位置； length:复制的长度 // 将elementData从index位置开始，复制到elementData的index+1开始的连续空间 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 在elementData的index位置赋值element elementData[index] = element; // ArrayList的大小加一 size++; &#125; /** * 在ArrayList的移除index位置的元素,会检查添加的位置，返回之前的值 * * @param index 要删除的元素的索引 * @return 从ArrayList中删除的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 判断是否越界 rangeCheck(index); modCount++; // 读取旧值 E oldValue = elementData(index); // 获取index位置开始到最后一个位置的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 return oldValue; &#125; /** * 在ArrayList的移除对象为O的元素，跟indexOf方法思想基本一致 * * @param o 要从该列表中删除的元素（如果存在） * @return true 如果这个列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * 快速删除指定位置的值，之所以叫快速，应该是不需要检查和返回值，因为只内部使用 * * @param index */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间 elementData[--size] = null; //便于垃圾回收器回收 &#125; /** * 清空数组，把每一个值设为null,方便垃圾回收(不同于reset，数组默认大小有改变的话不会重置) */ public void clear() &#123; modCount++; //便于垃圾回收器回收 for (int i = 0; i &lt; size; i++) elementData[i] = null; //把size设置为0，以便我们不会浏览到null值的内存空间 size = 0; &#125; /** * 添加一个集合的元素到末端，若要添加的集合为空返回false * * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将c转换为数组a Object[] a = c.toArray(); // 获取a占的内存空间长度赋值给numNew int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 将a的第0位开始拷贝至elementData的size位开始，拷贝长度为numNew System.arraycopy(a, 0, elementData, size, numNew); // 将size增加numNew size += numNew; // 如果c为空，返回false，c不为空，返回true return numNew != 0; &#125; /** * 从第index位开始，将c全部拷贝到ArrayList,若要添加的集合为空返回false * * @param index 在哪个索引处插入指定集合中的第一个元素 * @param c 包含要添加到此列表中的元素的集合 * @return true 如果该列表因添加而改变 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException 如果指定的集合是空的 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 判断index大于size或者是小于0,如果是，则抛出IndexOutOfBoundsException异常 rangeCheckForAdd(index); // 将c转换为数组a Object[] a = c.toArray(); int numNew = a.length; // 扩容至size + numNew ensureCapacityInternal(size + numNew); // Increments modCount // 获取需要添加的个数 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 删除指定范围元素。参数为开始删的位置和结束位置 * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex;//后段保留的长度 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); //便于垃圾回收期回收 int newSize = size - (toIndex - fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查index是否超出数组长度 用于添加元素时 */ private void rangeCheck(int index) &#123; // 如果下标超过ArrayList的数组长度 if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 检查是否溢出 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 抛出的异常的详情 */ private String outOfBoundsMsg(int index) &#123; return \"Index: \" + index + \", Size: \" + size; &#125; /** * ArrayList移除集合c中的所有元素 * * @param c 包含要从此列表中移除的元素的集合 * @return &#123;@code true&#125; 如果该列表因移除而改变 * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; // 如果c为空，则抛出空指针异常 Objects.requireNonNull(c); // 调用batchRemove移除c中的元素 return batchRemove(c, false); &#125; /** * 仅保留指定集合c中的元素 * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); // 调用batchRemove保留c中的元素 return batchRemove(c, true); &#125; /** * 根据complement值，将ArrayList中包含c中元素的元素删除或者保留 * * @param c * @param complement true时从数组保留指定集合中元素的值，为false时从数组删除指定集合中元素的值。 * @return 数组中重复的元素都会被删除(而不是仅删除一次或几次)，有任何删除操作都会返回true */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // 定义一个w，一个r，两个同时右移 int r = 0, w = 0; boolean modified = false; try &#123; // r先右移 for (; r &lt; size; r++) // 如果c中不包含elementData[r]这个元素 if (c.contains(elementData[r]) == complement) // 则直接将r位置的元素赋值给w位置的元素，w自增 elementData[w++] = elementData[r]; &#125; finally &#123; // 防止抛出异常导致上面r的右移过程没完成 if (r != size) &#123; // 将r未右移完成的位置的元素赋值给w右边位置的元素 System.arraycopy(elementData, r, elementData, w, size - r); // 修改w值增加size-r w += size - r; &#125; // 如果有被覆盖掉的元素，则将w后面的元素都赋值为null if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w;//改变的次数 //新的大小为保留的元素的个数 size = w; modified = true; &#125; &#125; return modified; &#125; /** * 保存数组实例的状态到一个流（即序列化）。写入过程数组被更改会抛出异常 * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; //执行默认的反序列化/序列化过程。将当前类的非静态和非瞬态字段写入此流 s.defaultWriteObject(); // 写入大小 s.writeInt(size); // 按顺序写入所有元素 for (int i = 0; i &lt; size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 从流中重构ArrayList实例（即反序列化）。 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // 执行默认的序列化/反序列化过程 s.defaultReadObject(); // 读入数组长度 s.readInt(); // ignored if (size &gt; 0) &#123; // 像clone()方法 ，但根据大小而不是容量分配数组 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; //读入所有元素 for (int i = 0; i &lt; size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * 返回一个从index开始的ListIterator对象 * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \" + index); return new ListItr(index); &#125; /** * 返回一个ListIterator对象，ListItr为ArrayList的一个内部类，其实现了ListIterator&lt;E&gt; 接口 * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * 返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口 * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * 通用的迭代器实现 */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; //游标，下一个元素的索引，默认初始化为0 int lastRet = -1; //上次访问的元素的位置 int expectedModCount = modCount;//迭代过程不运行修改数组，否则就抛出异常 //是否还有下一个 public boolean hasNext() &#123; return cursor != size; &#125; //下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification();//检查数组是否被修改 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1;//向后移动游标 return (E) elementData[lastRet = i];//设置访问的位置并返回这个值 &#125; //删除元素 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification();//检查数组是否被修改 try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; //检查数组是否被修改 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * ListIterator迭代器实现 */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * &lt;p&gt; * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * &lt;p&gt; * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; /** * 安全检查 * * @param fromIndex * @param toIndex * @param size */ static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\"); &#125; /** * 子数组 */ private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize == 0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; /** * 返回指定范围的子数组 * * @param fromIndex * @param toIndex * @return */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return \"Index: \" + index + \", Size: \" + this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Creates a &lt;em&gt;&lt;a href=\"Spliterator.html#binding\"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * &lt;p&gt; * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** * Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; /** * 如果ArrayLists是不可变的，或者在结构上不可变（不添加，删除等），我们可以用Arrays.spliterator实现它们的分割器。 * 相反，我们在遍历期间检测到尽可能多的干扰而不会影响性能。 * 我们主要依靠modCounts。这些不能保证检测到并发冲突，有时对线程内干扰过于保守，但在实践中检测到足够的问题是值得的。 * 为了实现这一点，我们 * （1）懒惰地初始化fence和expectedModCount，直到我们需要提交到我们正在检查的状态的最后一点;从而提高精度。 * （这不适用于SubLists，它会使用当前非惰性值的分割符）。 * （2）我们在forEach（对性能最敏感的方法）结束时只执行一次ConcurrentModificationException检查。 * 当使用forEach（而不是迭代器）时，我们通常只能在行为之后检测干扰，而不是之前。 * 进一步的CME触发检查适用于所有其他可能的违反假设的情况，例如null或过小的elementData数组，因为它的大小（）只能由于干扰而发生。 * 这允许forEach的内循环在没有任何进一步检查的情况下运行，并且简化了lambda分辨率。虽然这需要进行多次检查，但请注意，在list.stream（）。 * forEach（a）的常见情况中，除forEach本身之外，不会执行任何检查或其他计算。其他较少使用的方法无法利用这些优化的大部分优势。 */ private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** * Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings(\"unchecked\") E e = (E) list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings(\"unchecked\") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(\"unchecked\") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i = 0, j = 0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k = newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(\"unchecked\") public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings(\"unchecked\") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125;","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"source code","slug":"source-code","permalink":"http://yoursite.com/tags/source-code/"}]},{"title":"JDK1.5与JDK8新特性","slug":"JDK1.5与JDK8新特性","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:30:38.723Z","comments":true,"path":"2018/08/14/JDK1.5与JDK8新特性/","link":"","permalink":"http://yoursite.com/2018/08/14/JDK1.5与JDK8新特性/","excerpt":"","text":"一、JDK1.5新特性 自动装箱与拆箱：自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。自动拆箱的过程：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。自动拆箱，只需将该对象值赋给一个基本类型即可。java——类的包装器类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean 枚举把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。 静态导入通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner;后者一般是导入静态的方法，import static java.lang.System.out。 可变参数（Varargs）可变参数的简单语法格式为：methodName([argumentList], dataType…argumentName); 内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新 的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。一 般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。 泛型(Generic)C++通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。 For-Each循环For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。 JUCConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的,是concurrent包的重要成员。 二、JDK8新特性 Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 接口的默认方法与静态方法我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。 方法引用通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用。 构造器引用。语法是Class::new，或者更一般的Class&lt; T &gt;::new，要求构造器方法是没有参数。 静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数。 特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的。 特定对象的方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入。 重复注解在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。 扩展注解的支持Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。 OptionalJava 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。 StreamStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！ Date/Time API (JSR 310)Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。 JavaScript引擎NashornNashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。 Base64在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。 除了这十大新特性之外，还有另外的一些新特性： 更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。 编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。 并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。 并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。 Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）。另外Java8在JDK JUC 增加新的并发API。 三、参考资料 JDK各个版本的新特性jdk1.5-jdk8 Java8的十大新特性","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java对象排序-Comparator和Comparable","slug":"java对象排序-Comparator和Comparable","date":"2018-08-14T19:44:01.000Z","updated":"2018-11-18T20:33:53.749Z","comments":true,"path":"2018/08/14/java对象排序-Comparator和Comparable/","link":"","permalink":"http://yoursite.com/2018/08/14/java对象排序-Comparator和Comparable/","excerpt":"","text":"当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。 一、Comparator强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。接口方法：int compare(Object o1, Object o2);举例：12345678910111213141516171819202122import java.util.Arrays;import java.util.Comparator;public class SampleComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return toInt(o1) - toInt(o2); &#125; private int toInt(Object o) &#123; String str = (String) o; str = str.replaceAll(&quot;一&quot;, &quot;1&quot;); str = str.replaceAll(&quot;二&quot;, &quot;2&quot;); str = str.replaceAll(&quot;三&quot;, &quot;3&quot;); // return Integer.parseInt(str); &#125; public static void main(String[] args) &#123; String[] array = new String[] &#123; &quot;一二&quot;, &quot;三&quot;, &quot;二&quot; &#125;; Arrays.sort(array, new SampleComparator()); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 二、Comparable强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。接口方法: int compareTo(Object o);假设对象User，需要按年龄排序：123456789101112131415161718192021222324252627public class User &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 改造后的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;public class User implements Comparable &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int compareTo(Object o) &#123; return this.age - ((User) o).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 三、Comparator和Comparable的区别先看一下使用Comparator对User集合实现排序的方式：1234567891011121314151617import java.util.Arrays;import java.util.Comparator;public class UserComparator implements Comparator &#123; public int compare(Object o1, Object o2) &#123; return ((User) o1).getAge() - ((User) o2).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(&quot;a&quot;, 30), new User(&quot;b&quot;, 20) &#125;; Arrays.sort(users, new UserComparator()); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + &quot; &quot; + user.getAge()); &#125; &#125;&#125; 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用： 类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身 可以使用多种排序标准，比如升序、降序等 四、补充一个例子：12345678List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Collections.sort(persons, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; Collator collator = Collator.getInstance(Locale.CHINA); return collator.compare(o1.getName(), o2.getName()); &#125; &#125;); 使用Collections.sort方法，传一个Comparator实现类，比较对象字段实现compare方法。 References java对象排序-Comparator和Comparable Java根据对象的某个字段排序","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Development","slug":"Java/Development","permalink":"http://yoursite.com/categories/Java/Development/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java保留两位小数的5种方法","slug":"java保留两位小数5种方法","date":"2018-08-14T19:24:40.000Z","updated":"2018-11-18T20:34:18.312Z","comments":true,"path":"2018/08/14/java保留两位小数5种方法/","link":"","permalink":"http://yoursite.com/2018/08/14/java保留两位小数5种方法/","excerpt":"","text":"#java保留两位小数5种方法 第一种： 1System.out.println(String.format(&quot;%.2f&quot;, f)); 第二种： 123BigDecimal bg = new BigDecimal(f); double f1 = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(f1); 第三种： 12DecimalFormat df = new DecimalFormat(&quot;#.00&quot;); System.out.println(df.format(f)); 第四种： 123NumberFormat nf = NumberFormat.getNumberInstance(); nf.setMaximumFractionDigits(2); System.out.println(nf.format(f)); 第五种： 1234float price=89.89;int itemNum=3;float totalPrice=price*itemNum;float num=(float)(Math.round(totalPrice*100)/100);//如果要求精确4位就*10000然后/10000 Referencejava保留两位小数5种方法","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Java","slug":"Development/Java","permalink":"http://yoursite.com/categories/Development/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"排序算法总结","slug":"排序算法总结","date":"2018-08-14T13:03:08.000Z","updated":"2018-11-20T20:36:27.042Z","comments":true,"path":"2018/08/14/排序算法总结/","link":"","permalink":"http://yoursite.com/2018/08/14/排序算法总结/","excerpt":"","text":"排序 基本有序的情况下：快排最慢，堆排最快。 选择排序的最坏和平均复杂度相同。 归并排序的也是一样的。 折半插入排序，是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。 所以，很明显比较的次数减少了 比较次数与初始元素顺序无关的排序算法（即最好、最坏情况的时间复杂度一样）选择排序O(n^2)堆排序O(nlogn)归并排序O(nlogn)基数排序O(tn) 元素的移动次数与关键字的初始排列次序无关的是：基数排序； 元素的比较次数与初始序列无关是：选择排序 算法的时间复杂度与初始序列无关的是：直接选择排序 对n个记录的线性表进行快速排序为减少算法的递归深度，每次分区后,先处理较短的部分 外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。 插入排序、选择排序、起泡排序原本时间复杂度是O(n2)，更换为链式存储后的时间复杂度还是O(n2)。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加。 先序遍历：根左右；中序遍历：左根右；后序遍历：左右跟。 快排的阶段性排序结果的特点是，第i趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大。 小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2] 递归算法改为非递归算法不是采用队列做辅助结构，而是栈； 影响时间复杂度的主要因素为比较的次数。 二叉排序树的主要用途是链式存储结构的二分查找，查找的最坏次数是树的高度，因此高度最小的二叉排序树是最佳的。 基数排序又称桶排序，它基于分治的思想，它将序列分为若干组，组与组之间是有序的（比如第一堆最大的元素也不会比第二堆最小的元素更大，诸如此类），因此可以把问题划分为若干个子问题进行并行处理。 二叉排序树的任一结点，左小右大。 对长度为n的线性表排序，在最坏情况下，比较次数除堆排序的比较次数是O(nlogn),其他都是n(n-1)/2。 字符串 KMP算法时间复杂度为O(m+n)，空间复杂度为O(m)。 设有两个串p和q，其中q是p的子串，求q在p中首次出现的位置的算法称为匹配。 队列和栈 深度优先遍历DFS可以用栈实现；宽度优先遍历BFS用队列实现。 用链接方式存储的队列，在进行插入运算时，一般情况下，仅需修改队尾指针；但当队列为空时，插入元素时，队头和队尾指针都需修改。 有序表中所有元素以递增或递减方式排列，对数据之间的关系进行了描述，是一种逻辑结构。 循环队列的相关条件和公式： 队空条件：rear==front 队满条件：(rear+1) %QueueSIze==front，其中QueueSize为循环队列的最大长度 计算队列长度：（rear-front+QueueSize）%QueueSize 入队：（rear+1）%QueueSize 出队：（front+1）%QueueSize 输入受限 的 双端队列 是指元素只能从 队列 的一 端输入 ,但可以从 队列 的两端 输出；输出受限 的 双端队列 是指只有一端可以进行出队操作而从两端都可以进行入队操作的 队列。 广度优先用队列，深度优先用栈。 线性表可以分顺序存储和链式存储。 抓住front=tail时，队列可能空，也可能满！ 循环队列插入时，队头指针不变，队尾指针后移一位。 所谓建初始堆意思是从这里开始调整。 一个中缀式到其他式子的转换方法：a+b*c-(d+e)第一步：按照运算符的优先级对所有的运算单位加括号： 式子变成拉：((a+(b*c))-(d+e)) 第二步：转换前缀与后缀表达式 前缀：把运算符号移动到对应的括号前面 则变成拉：-( +(a *(bc)) +(de)) 把括号去掉：-+a*bc+de 前缀式子出现 后缀：把运算符号移动到对应的括号后面 则变成拉：((a(bc)* )+ (de)+ )- 把括号去掉：abc*+de+- 后缀式子出现 先序遍历：根左右；中序遍历：左根右；后序遍历：左右根。 栈内存操作系统来分配，堆内存由程序员自己来分配。 递归过程转换为非递归过程，一般都要用栈来模拟这个过程调用. 选择排序，是每一次从未排序序列中找出一个最大或者最小的数，放到已排好序的数列最后。因此关键字比较次数跟数列的初始排列顺序是没有关系的. 初始数据集排列顺序与比较次数无关的有：归并，堆，选择排序。 插入排序、堆排序、冒泡排序、快速排序的比较：插入排序是依次比较找到自己的位置，有序的数组比较次数少；堆排序在数据有序时能够降低维护堆的性质时的交换次数；标准冒泡排序的比较次数是固定的，但是改进的冒泡排序可以对于有序的数组减少比较次数；快速排序在有序时复杂度最高达到O(n2)，完全无序时O(nlogn)； 元素的移动次数与关键字的初始排列次序无关的是：基数排序； 元素的比较次数与初始序列无关是：选择排序； 算法的时间复杂度与初始序列无关的是：直接选择排序；","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"},{"name":"面试题","slug":"秋招/面试题","permalink":"http://yoursite.com/categories/秋招/面试题/"},{"name":"排序","slug":"秋招/面试题/排序","permalink":"http://yoursite.com/categories/秋招/面试题/排序/"},{"name":"面经","slug":"秋招/面试题/排序/面经","permalink":"http://yoursite.com/categories/秋招/面试题/排序/面经/"}],"tags":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"Java常见的坑","slug":"Java常见的坑","date":"2018-07-24T20:27:45.000Z","updated":"2018-11-18T21:38:08.469Z","comments":true,"path":"2018/07/24/Java常见的坑/","link":"","permalink":"http://yoursite.com/2018/07/24/Java常见的坑/","excerpt":"","text":"对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals方法进行判断。 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException。subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生ConcurrentModificationException 异常。 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(\"guan\"); list.add(\"bao\"); String[] array = new String[list.size()]; array = list.toArray(array); 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出 UnsupportedOperationException异常。asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。 使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Development","slug":"Java/Development","permalink":"http://yoursite.com/categories/Java/Development/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Git面试题","slug":"Git面试题","date":"2018-07-18T18:59:43.000Z","updated":"2018-11-18T20:32:54.809Z","comments":true,"path":"2018/07/18/Git面试题/","link":"","permalink":"http://yoursite.com/2018/07/18/Git面试题/","excerpt":"","text":"fetch和merge和pull的区别pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。git fetch：相当于是从远程获取最新版本到本地，不会自动mergegit merge : 将内容合并到当前分支git pull：相当于是从远程获取最新版本并merge到本地 tagtag指向一次commit的id，通常用来给开发分支做一个标记打标签 : git tag -a v1.01 -m “Relase version 1.01”提交标签到远程仓库 : git push origin –tags查看标签 : git tag查看某两次tag之间的commit：git log –pretty=oneline tagA..tagB查看某次tag之后的commit: git log –pretty=oneline tagA.. Git和SVN的区别Git是分布式版本控制系统，SVN是集中式版本控制系统 Git工作流程 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中 常用命令git show # 显示某次提交的内容 git show $idgit add # 将工作文件修改提交到本地暂存区git rm # 从版本库中删除文件git reset # 从暂存区恢复到工作文件git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git diff # 比较当前文件和暂存区文件差异 git diffgit log -p # 查看每次详细修改内容的diffgit branch -r # 查看远程分支git merge # 将branch分支合并到当前分支git stash # 暂存git stash pop #恢复最近一次的暂存git pull # 抓取远程仓库所有分支更新并合并到本地git push origin master # 将本地主分支推到远程主分支 git add 和 git stage 有什么区别？其实，他们两是同义的，所以，惊不惊喜，意不意外？这个问题竟然是个陷阱…引入 git stage 的原因其实比较有趣：是因为要跟 svn add 区分，两者的功能是完全不一样的，svn add 是将某个文件加入版本控制，而 git add 则是把某个文件加入暂存区，因为在 git 出来之前大家用 svn 比较多，所以为了避免误导，git 引入了git stage，然后把 git diff –staged 做为 git diff –cached 的相同命令。基于这个原因，我们建议使用 git stage 以及 git diff –staged。 git reset、git revert 和 git checkout 有什么区别？首先是它们的共同点：用来撤销代码仓库中的某些更改。然后是不同点：首先，从 commit 层面来说：git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset 还支持三种标记，用来标记 reset 指令影响的范围。git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。 然后，从文件层面来说：git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 –mixed、–soft 和 –hard。git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。git revert 不支持文件层面的操作. 参考资料 面试中的那些 Git 问题 - 基础部分 git常见面试题","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"如何删除GitHub中的目录?","slug":"如何删除GitHub中的目录?","date":"2018-06-30T20:35:01.000Z","updated":"2018-11-18T20:23:53.142Z","comments":true,"path":"2018/06/30/如何删除GitHub中的目录?/","link":"","permalink":"http://yoursite.com/2018/06/30/如何删除GitHub中的目录?/","excerpt":"","text":"如何删除GitHub中的目录？ 有时候错误上传目录到GitHub上，需要删除。只需要执行以下步骤： git clone 你的文件路径 ls -la git rm -r --cached 要删除的文件夹 git commit -m &#39;删除了target&#39; //提交,添加操作说明 git push -u origin master 将本次更改更新到github项目上去 关于git rm -r --cached中的“cached”参数，经查阅StackOverflow，解释如下： git rm on the other hand removes a file from the working directory and the index and when you commit, the file is removed from the tree as well. git rm –cached however removes the file from index alone and keeps it in your working copy. This is the exact opposite of git add file In this case, you made index to be different from the HEAD and the working, in it that the HEAD has the previously committed version of the file, working copy had the las modification if any or content from HEAD of the file and you removed the file from the index. A commit now will sync the index and tree and the file will be removed. 参考资料 “git rm –cached x” vs “git reset head — x”?","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git删除远程仓库文件夹或文件的方法","slug":"Git删除远程仓库文件夹或文件的方法","date":"2018-06-20T14:59:21.000Z","updated":"2018-11-18T20:48:14.332Z","comments":true,"path":"2018/06/20/Git删除远程仓库文件夹或文件的方法/","link":"","permalink":"http://yoursite.com/2018/06/20/Git删除远程仓库文件夹或文件的方法/","excerpt":"","text":"Git删除远程仓库文件夹或文件的方法 背景：想删除一个git目录里的文件，当时提交了，但想删除master里的，怎么办？1234git rm -r -n --cached *git rm -r --cached *git commit -m &quot;移除src目录下所有文件的版本控制&quot;git push origin master 如下，我把src里的全部移除，但是本地文件还保留: git rm -r -n –cached /src/\\ //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。 git rm -r –cached /src/\\ //最终执行命令. git commit -m”移除src目录下所有文件的版本控制” //提交 git push origin master //提交到远程服务器 原文链接：http://www.cnblogs.com/xusir/p/4111723.html","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java常考面试题","slug":"Java常考面试题","date":"2018-06-20T00:34:09.000Z","updated":"2018-11-18T21:39:35.168Z","comments":true,"path":"2018/06/19/Java常考面试题/","link":"","permalink":"http://yoursite.com/2018/06/19/Java常考面试题/","excerpt":"","text":"Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或是static的方法?“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。 是否可以在static环境中访问非static变量？static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 Java支持的数据类型有哪些？什么是自动拆装箱？Java语言支持的8种基本数据类型是：byte，short，int，long，float，double，boolean，char。自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程 Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。方法的重载是可以改变返回值类型的。 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。 Java支持多继承么？Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 接口和抽象类的区别是什么？不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 什么是值传递和引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递. 进程和线程的区别是什么？进程是运行在内存中的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。线程与进程的区别归纳：a. 进程是运行中的程序，线程是进程的内部的一个执行序列b. 进程是资源分配的单元，线程是执行行单元c. 进程间切换代价大，线程间切换代价小d. 进程拥有资源多，线程拥有资源少e. 多个线程共享进程的资源 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 继承Thread类，重写run方法； 实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性； 实现callable接口，重写call方法，有返回值。 使用实现了Executor接口的ThreadPoolExecutor来创建线程池。实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 概括的解释下线程的几种可用状态。 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 同步方法和同步代码块的区别是什么？同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；同步方法使用关键字 synchronized修饰方法;同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰； 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？监视器和锁在java中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程能访问同步代码块。每一个对象都与一个监视器相关联，没有获取到锁的对象不能执行这块同步代码块. 什么是死锁(deadlock)？所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类框架的基本接口有哪些？Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。克隆和序列化又被称为标识接口，在java中只起到标识类的作用。 什么是迭代器(Iterator)？迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 算法导论中原话：“基数排序是首先按最低位有效数字进行排序，才是稳定的算法”。 不稳定：快选堆希稳定：插冒归基 Iterator和ListIterator的区别是什么？下面列出了他们的区别：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 快速失败（fail—fast）：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 安全失败（fail—safe）采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。在java.util包下的都是快速失败。安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。在java.util.concurrent包下的全是安全失败的。 Java中的HashMap的工作原理是什么？hashmap的底层是以数组和单向链表进行实现的，当进行put操作的时候，首先通过hashcode()方法进行计算key的hash值，然后找出链表索引，然后看索引上是否有相同的key值，如果有就更新value值，如果没有就把值加在链表尾。hashmap有两个重要的属性参数，capacity（容量）和loadfactor（负载因子），初始值分别为16与0.75，当存储的数据的数量达到了capacity*loadfactor就会进行扩容操作（resize），将容量扩充为2n。一般进行初始化的时候，可以重新设置capacity与loadfactor，但是一般capacity的默认值一般是比较好的，不需要进行更改。只需要考虑capacity的值就行了，一般如果能够提前预估容量大小，将会大大减少扩容的消耗。 hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 HashMap和Hashtable有什么区别？都实现了Map接口，但是不同点有: HashMap是非线程安全的，HashTable是线程安全的。 HashMap的键和值都允许有null值存在，而HashTable则不行。 因为线程安全的问题，HashMap效率比HashTable的要高。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？下面列出了Array和ArrayList的不同点： Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 什么是Java优先级队列(Priority Queue)？优先级队列就是一种自己定义队列中元素大小的队列 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？O：大O是上界Θ：大Θ是平均值Ω：大Ω是下界 如何权衡是使用无序的数组还是有序的数组？有序数组查询容易，插入难。无序数组插入容易，查询难.查找复杂度：有序数组O(log n) ，无序数组 O(n)插入复杂度：有序数组O(n) ，无序数组 O(1) Java集合类框架的最佳实践有哪些？一开始还在想，难道有什么经典的算法或者什么方法理论，称之为最佳实践。看了答案才知道是怎么去选择一个合适的集合类框架。 那么，首先选一个适合的。比如固定那就选不拓展，插入频繁就链表，查询频繁就数组。不知道这个答案可以不？根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。编程的时候接口优于实现。底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 Enumeration接口和Iterator接口的区别有哪些？iterator是快速失败的，当你在遍历的时候，如果另起一个线程来修改它（集合的内容）的结构，这时迭代器会立马感知到，引起快速失败，抛出ConcurrentModificationException异常。所以说iterator 是安全的。 HashSet和TreeSet有什么区别？HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。触发主GC（Garbage Collector，垃圾回收）的条件：（1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。（2）Java堆内存不足时，GC会被调用。 System.gc()和Runtime.gc()会做什么事情？这俩个方法都是用来提示java虚拟机进行垃圾回收，但是否立即回收还是延迟回收由java虚拟机决定。 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 垃圾回收器在回收某对象时，垃圾收集器会调用对象的finalize()方法。 析构finalization，比如你在调用了一些native的方法，可以要在finaliztion里去调用释放函数。 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?虚拟机中的共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 年轻代: 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 年老代: 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代:用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 JVM的永久代中会发生垃圾回收么？JAVA堆内存分为持久代，年轻代和老年代。年轻代存放新生成的对象。垃圾回收主要是针对这个区域。在年轻代中经历了N次垃圾回收依然存活的对象被放入老年代中。持久代存放的是类定义信息，与垃圾收集器关系不大。 Java中的两种异常类型是什么？他们有什么区别？Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。 Java中Exception和Error有什么区别？Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。 throw和throws有什么区别？throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 finally代码块和finalize()方法有什么区别？无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 什么是JDBC？JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 Class.forName()方法有什么作用？初始化参数指定的类，并且返回此类对应的Class 对象. PreparedStatement比Statement有什么优势？PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象。PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法, excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。PreparedStatements的代码可读性，可维护性强于statement.防止sql注入攻击，极大的提高了安全性。 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStatement Connection.prepareCall(); 数据库连接池是什么意思？像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 什么是RMI？Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。 RMI体系结构的基本原则是什么？RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。 RMI体系结构分哪几层？RMI体系结构分以下几层：存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 RMI中的远程接口(Remote Interface)扮演了什么样的角色？远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 java.rmi.Naming类扮演了什么样的角色？java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。 RMI的绑定(Binding)是什么意思？绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。 Naming类的bind()和rebind()方法有什么区别？bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 让RMI程序能正确运行有哪些步骤？为了让RMI程序能正确运行必须要包含以下几个步骤：编译所有的源文件。使用rmic生成stub。启动rmiregistry。启动RMI服务器。运行客户端程序 RMI的stub扮演了什么样的角色？远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：初始化到包含了远程对象的JVM的连接。序列化参数到远程的JVM。等待方法调用和执行的结果。反序列化返回的值或者是方法没有执行成功情况下的异常。把值返回给调用者。 什么是分布式垃圾回收(DGC)？它是如何工作的？DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。 解释下Marshalling和demarshalling。当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。 解释下Serialization和Deserialization。Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 什么是Servlet？Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。 说一下Servlet的体系结构。所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。 GenericServlet和HttpServlet有什么区别？GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法. 解释下Servlet的生命周期。1.加载实例化 2.初始化 3.处理请求 4.销毁Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。②装载并创建该Servlet的一个实例对象。③调用Servlet实例对象的init()方法。④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 doGet()方法和doPost()方法有什么区别？doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。 什么是Web应用程序？web应用程序就是一种可以通过web进行访问的应用程序，简单的说就是可以直接通过浏览器进行访问的应用程序。基于典型的B/S模式的应用程序，核心是对数据库的相关操作和处理. 什么是服务端包含(Server Side Include)？服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。 什么是Servlet链(Servlet Chaining)？Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 如何知道是哪一个客户端的机器正在请求你的Servlet？ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。 HTTP响应的结构是怎么样的？响应消息行：包含协议/版本，响应状态码，对响应状态码的描述（一切正常);响应消息头：:服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作;响应消息正文：和网页右键“查看源码”看到的内容一样; 什么是cookie？session和cookie有什么区别？cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。 浏览器和Servlet通信使用的是什么协议？浏览器和Servlet通信使用的是HTTP协议。 什么是HTTP隧道？HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。 sendRedirect()和forward()方法有什么区别？sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。 么是URL编码和URL解码？URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 什么是JSP页面？jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。 JSP请求是如何被处理的？客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。 JSP有什么优点？JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。JSP页面可以被预编译。JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive：包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。Taglib指令： 用来声明页面中使用的自定义的标签库。 什么是JSP动作(JSP action)？JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：jsp:include-当JSP页面被请求的时候包含一个文件。jsp:useBean-找出或者是初始化Javabean。jsp:setProperty-设置JavaBean的属性。jsp:getProperty-获取JavaBean的属性。jsp:forward-把请求转发到新的页面。jsp:plugin-产生特定浏览器的代码。 什么是Scriptlets？指jsp页面里 &lt;% %&gt; 中间的代码。一个包含任何在JSP页面中合法的脚本语言的代码片断的JSP脚本元素。Java Web开发时，尽量不要在JSP中出现这种Scriptlets，尽量多使用JSP标签，或者JSTL，或者一些框架的标签。 什么是JSP表达式(Expression)？格式：&lt;%=有值得表达式%&gt; 表达式返回值不能是void类型。 隐含对象（内置对象）是什么意思？有哪些隐含对象？JSP隐含对象就是在编译成servlet时，servlet里产生的可以直接用的内置对象，共有九个：application，request，response，session，config，page，out，pagecontext，exception。 面向对象软件开发的优点有哪些？代码开发模块化，更易维护和修改。代码复用。增强代码的可靠性和灵活性。增加代码的可理解性。面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。 封装的定义和好处有哪些？封装就是将过程和数据包围起来，对数据的访问只能通过自定义的界面。封装有属性封装和方法封装，封装定义了访问这些属性和方法的范围，分别有pubilc，paivare，protected和默认的friendy。封装减少了复杂性，提高了代码的安全性. 多态的定义？多态就是：父类对象的引用，所指对象，可以是父类的对象，也可以是子类的对象。为了实现代码复用，减少代码量。 继承的定义？继承就是对象的新类从现有类中派生，新类拥有原始类所有特性。 抽象的定义？抽象和封装的不同点？抽象: 抽象就是忽略一个问题中与当前目标无关的那些方面，以便更充分的注意与当前目标有关的部分，抽象不打算了解问题的全部，而是只选择其中的一个部分，抽象包括两个方面：过程抽象和数据抽象。封装：就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。 Networks OSI，TCP/IP，五层协议的体系结构，以及各层协议.OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS每一层的作用如下：物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类?A类地址：以0开头， 第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）E类地址：保留其中A、B、C是基本类，D、E类作为多播和保留使用。以下是留用的内部私有地址：A类 10.0.0.0–10.255.255.255B类 172.16.0.0–172.31.255.255C类 192.168.0.0–192.168.255.255IP地址与子网掩码相与得到网络号：ip : 192.168.2.110&amp;Submask : 255.255.255.0=网络号 ：192.168.2 .0注: 主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255） 巧记IP地址分类。A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。D类地址(224~239)：以1110开头，保留位多播地址。E类地址(240~255)：以1111开头，保留位今后使用。 ARP是地址解析协议，简单语言解释一下工作原理。1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 各种协议的介绍。ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 描述RARP协议。RARP，逆地址解析协议，其作用是完成MAC地址到IP地址的映射，主要用于无盘工作站，因为为无盘工作站配置对额IP地址无法保存。其工作流程是：在网络中建立一个ARAP服务器，用于保存MAC地址和IP地址的映射关系。当无盘工作站启动后，其会封装一个ARAP数据包，其中尤其MAC地址，然后广播到网络中去，当服务器接收到请求包，就查找对应的MAC地址对应的IP地址装入响应报文中发给请求者。因为需要广播请求报文，所以RARP只能用于具有广播能力的网络。 TCP三次握手和四次挥手的全过程？ 三次握手： 客户端发送SYN请求，进入SYN_SEND状态 服务端收到SYN请求，并返回一个ACK应答，并发送一个SYN其请求，服务器进入SYN_RECV状态。 客户端收到服务端的SYN请求和ACK应答，发送ACK应答，客户端进入ESTABLISH状态，服务端收到应答后进入ESTABLISH。如果没有收到应答，数据包都会根据TCP的重传机制进行重传。 四次挥手： 客户端发送FIN包，请求断开连接，客户端进入FIN_WAIT1状态 服务端收到FIN包后返回应答，进入CLOSE_WAIT状态 客户端收到FIN的应答后进入FIN_WAIT2状态 服务端发送FIN请求包，进入LAST_ACK状态 客户端收到FIN请求包后，发送应答进入TIME_WAIT状态 服务器收到ACK应答后，进入close状态。 在浏览器中输入www.baidu.com后执行的全部过程。 客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 TCP和UDP的区别？ TCP面向连接的运输层协议，UDP无连接 TCP是可靠交付，UDP是尽最大努力交付 TCP面向字节流，UDP面向报文 TCP是点对点连接的，UDP一对一，一对多，多对多都可以 TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等TCP对应的协议：（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。当一个应用进程需要把某个域名解析为IP地址时，该应用进程就会调用解析程序，并成为一个DNS用户，把待解析的域名放在DNS请求报文中，以UDP数据报的形式发送给本地域名服务器，本地域名服务器查找到相应域名的IP地址后，就将该域名的IP地址信息放入应答报文中返回给客户进程，如果本地域名服务器没有直接查找到对应的IP地址，则向根域名服务器发出迭代查询，再将查询到的IP地址信息回传给客户程序。 TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？A：喂，听到吗？ B：能听到，你呢？A：….B：… OS 操作系统的五大管理功能:（1）作业管理：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等；（2）文件管理：又称为信息管理；（3）存储管理：实质是对存储“空间”的管理，主要指对主存的管理；（4）设备管理：实质是对硬件设备的管理，其中包括对输入输出设备的分配、启动、完成和回收；（5）进程管理：实质上是对处理机执行“时间”的管理，即如何将CPU真正合理地分配给每个任务。 cpu工作状态分为系统态（或称管理态，管态）和用户态（或称目态）。 引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为：当cpu处于用户态时，不允许执行特权指令，当cpu处于系统态时，可执行包括特权指令在内的一切机器指令。 98或 xp 都可以有多个用户帐号密码，但请注意多用户是指多个用户同时操作。而98和 XP 在同一时间只能使用一个用户，所以包括 XP 在内，都只是单用户多任务的。 操作系统有四个明显的特征：并发性，共享性，虚拟性以及不确定性。 CPU要完成一组I/O操作，只需要向I/O通道发送一条I/O指令，通道接到指令，通过执行通道程序，并且与设备控制器一起共同来实现对I/O设备的控制和操作。 分时系统具有多路性、交互性、“独占”性和及时性的特征。 并发和共享是操作系统的两个最基本的特性，它们又是互为存在条件。一方面资源共享是以程序（进程）的并发性执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题。另一方面若系统不能对资源共享实施有效管理，则也必将影响到程序并发执行。 系统调用提供了用户程序和操作系统之间的接口。 多道程序系统的运行必须要依赖通道和中断硬件机构的支持。 系统态，即内核态，三种情况下会出现由用户态转为内核态，中断，异常，系统调用。 单道批处理并不会因为你请求了我就准备响应你，我的响应不是你的请求决定的，而是取决于我执行完上一个没有，多道批处理是我空出CPU了你就可以进来执行，取决于什么时候空出来，这两个都没有一个时间标准，不确定什么时候响应，，时间间隔的标准要求在一定时间内必须响应，不管你做没做完。 批处理不能处理需要交互类型的作业啊。 多道操作系统特意准备：特权指令（多道优先级）跳转指令（程序跳转）。如果不是多道的操作系统，也就是单任务处理的，那么一个一个的执行就好了，当出现多道的时候，就会出现优先级的问题，因此特权指令是为了提供在优先级不同的条件下，用户状态的切换，跳转指令就是从我们的程序跳转到另一个了，可能会感觉时钟会有用，给每一个程序分配一定的时间，让其运行，但是这个并不是必须的，因为可以根据优先级来采取抢占式的执行，所以时钟不是特别提供的，特权指令和跳转指令在单道批处理下是不能够起到作用的 独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。共享设备：多个用户作业或多个进程可以“同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。 进程的模式有系统态和用户态 两种，一般用户编写的程序是在用户态下工作，当程序中有中断或者调用系统函数 时，会切换到系统态下运行。 分时操作系统 ，主要分为三类：单道分时操作系统，多道分时操作系统，具有前台和后台的分时操作系统。 实时系统应具有的两个基本特征是( 及时)和( 可靠)。 批处理操作系统的主要缺点是缺少交互性。 操作系统的三种基本类型是：批处理操作系统,分时操作系统,实时操作系统。 从用户的观点出发，操作系统是用户和计算机之间的接口有命令接口,程序接口,图形接口三种。 操作系统中采用多道程序设计技术后，提高了CPU和外部设备的利用率。 操作系统的特征是并发性,共享性,虚拟性,异步性。 操作系统目前有五大类型：批处理操作系统,分时操作系统,实时操作系统,网络操作系统,分布式操作系统。 dos是磁盘操作系统的缩写。 计算机操作命令可分为联机命令,shell程序语言命令,脱机作业控制语言命令。 操作系统的目标是方便性,有效性,可扩充性,开放性。 系统调用和一般用户函数调用的区别？在操作系统中，系统调用程序在系统态执行；一般用户函数调用程序由用户准备，在用户态执行。 一般用户最常用的操作系统接口是什么接口？一般用户最常用的操作系统与用户的接口是控制接口。用户使用这个接口控制、管理和操作计算机系统，利用它控制程序的执行。控制接口分为脱机接连、命令接口、图形接口、多媒体接口。 过程调用和系统调用的共同点是什么，它们与中断调用的差别是什么？过程调用和系统调用的执行完全是同步的，也就是在相同的数据集上重复执行，它们的调用点是相同的，都需要保存现场信息，转去执行另外的程序，执行后返回。中断调用是异步的，在相同的数据集上重复执行，中断的发生点可以是不同的。 分时系统的响应时间受哪些因素的影响？分时系统的相应时间是指用户从终端发出一个命令到系统处理完这个命令并做出回答所需要的时间。这个时间受时间片长度、终端用户个数、命令本身功能、硬件特性、主存与辅存的交换速度等影响。 实时系统和分时系统的主要区别有两点：（1）分时系统的目标是提供一种通用性很强的系统，有较强的交互能力；而实时系统则大都是具有特殊用途的专用系统，交互能力略差。（2）分时系统对响应时间虽有要求，但一般来说，响应时间由人所能承受的等待时间来确定；而实时系统对响应时间要求很高，一般由控制系统或信息处理磁头所能接受的延迟时间来决定。 为什么中断机构对于多道操作系统是必不可少的？很多进程的切换是由中断引起的，如时钟中断，尤其是分时系统。用户程序进行系统调用时通过软中断来实现，如TRAP。通道和外设的操作也要向操作系统发送中断。 网络操作系统和分布式操作系统的区别？网络OS中的用户使用自己的机器可以访问网络上别的机器的资源，通过网络将很多机器连接起来，共享硬件资源，但是，整个系统对用户来说是分散的，不透明的。分布式OS的用户也是通过网络将多台机器连接起来，但是整个系统对用户是透明的，用户对整个OS就好像使用一个自己的机器一样。 简述操作系统的定义。操作系统是计算机系统的一种系统软件，它统一管理计算机系统的资源和控制程序的执行。 作业在系统中有哪几种状态？一个作业进入系统到运行结束，一般要经历进入、后备、运行和完成四个阶段，相应地，作业亦有进入、后备、运行和完成四种状态。① 进入状态：作业的信息从输入设备上预输入到输入井，此时称为作业处于进入状态。② 后备状态：当作业的全部信息都已输入，且由操作系统将其存放在输入井中，此时称作业处于后备状态。系统将所有处于后备状态的作业组成后备作业队列，等待作业调度程序的调度。③ 运行状态：一个后备作业被作业调度程序选中，分配了必要的资源，调入内存运行，称作业处于运行状态。④ 完成状态：当作业正常运行完毕或因发生错误非正常终止时，作业进入这完成状态。 中断装置的职能主要有三点：① 检查是否有中断事件发生；② 若有中断发生，保护好被中断进程的断点及现场信息，以便进程在适当时候能恢复执行；③ 启动操作系统的中断处理程序。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"},{"name":"Java","slug":"面试/Java","permalink":"http://yoursite.com/categories/面试/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/tags/秋招/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"macOS下安装及卸载MySQL","slug":"macOS下安装及卸载MySQL","date":"2018-06-12T14:24:17.000Z","updated":"2018-11-18T20:33:22.817Z","comments":true,"path":"2018/06/12/macOS下安装及卸载MySQL/","link":"","permalink":"http://yoursite.com/2018/06/12/macOS下安装及卸载MySQL/","excerpt":"","text":"一、安装 直接从官网down下来，我的macOS版本是10.13.5，使用的mysql版本是5.7.22。 无脑下一步，切记要记住初始时候设置的root密码。如果跟我一样不记得，请参考第三部分。 启动mysql：在MAC中的System Preference里，最后一栏，可以启动和停止mysql，也可以设置开机自动启动。 使用terminal操作mysql： 为Path路径附加mysql的bin目录：PATH=&quot;$PATH&quot;:/usr/local/mysql/bin 登录mysql：mysql -u root -p 你的密码 二、卸载卸载比较麻烦，在terminal下输入以下命令： 123456789sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig //执行完上面命令后使用的是Vim指令，复制上述命令，保存，退出即可。继续完成下列指令：rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* 最后打开系统偏好设置，最下方MySQL图标消失。 三、 忘记密码 击系统偏好设置-&gt;最下边点MySQL，在弹出页面中，关闭服务 进入终端输入 cd /usr/local/mysql/bin/ 切换为管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 继续输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES 回车后，输入命令 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;你的新密码&#39;); 密码设置成功！ 四、参考资料 Mac OS X下完全卸载MySQL mac 安装mysql详细教程","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"},{"name":"MySQL","slug":"Database/MySQL","permalink":"http://yoursite.com/categories/Database/MySQL/"},{"name":"Development","slug":"Database/MySQL/Development","permalink":"http://yoursite.com/categories/Database/MySQL/Development/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"}]},{"title":"Maven常用构建命令","slug":"Maven常用构建命令","date":"2018-06-03T18:05:11.000Z","updated":"2018-11-18T20:26:26.273Z","comments":true,"path":"2018/06/03/Maven常用构建命令/","link":"","permalink":"http://yoursite.com/2018/06/03/Maven常用构建命令/","excerpt":"","text":"Maven常用构建命令 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 mvn -v:查看版本 mvn compile mvn test mvn package mvn clean：删除target mvn install：安装jar包到本地仓库中","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"MAC下安装并配置Maven","slug":"MAC下安装并配置Maven","date":"2018-06-03T12:14:33.000Z","updated":"2018-11-18T20:27:18.081Z","comments":true,"path":"2018/06/03/MAC下安装并配置Maven/","link":"","permalink":"http://yoursite.com/2018/06/03/MAC下安装并配置Maven/","excerpt":"","text":"下载Maven打开Maven官网下载页面：http://maven.apache.org/download.cgi下载:apache-maven-3.1.0-bin.tar.gz。解压下载的安装包到某一目录，比如：/Users/xxx/Documents/maven 配置环境变量打开terminel输入以下命令：vim ~/.bash_profile 打开.bash_profile文件，在次文件中添加设置环境变量的命令 12export M2_HOME=/Users/xxx/Documents/maven/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 添加之后保存并推出，执行以下命令使配置生效：source ~/.bash_profile 查看配置是否生效terminal输入：mvn -v命令，输出如下： Maven 3.1.0 (893ca28a1da9d5f51ac03827af98bb730128f9f2; 2013-06-28 10:15:32+0800)12345Maven home: /Users/***/Library/MavenJava version: 1.*.*_40, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jreDefault locale: en_US, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.13.4\", arch: \"x86_64\", family: \"mac\" 则表示配置成功。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Java后台开发工程师秋招攻略2018Fall","slug":"Java后台开发工程师秋招攻略2018Fall","date":"2018-06-02T22:21:44.000Z","updated":"2018-11-19T23:09:40.629Z","comments":true,"path":"2018/06/02/Java后台开发工程师秋招攻略2018Fall/","link":"","permalink":"http://yoursite.com/2018/06/02/Java后台开发工程师秋招攻略2018Fall/","excerpt":"","text":"这份攻略是6月份左右刚开始准备秋招时候用的，但是后来在执行的时候发现，这份网上总结而来的攻略并不符合实际情况。现在已找到工作，把6月-11月以来所闻所见所想记录于海外计算机系留学生2018秋招总结-已拿某AI独角兽offer。 一、 算法和数据结构基础1. 数据结构：数组，链表，哈希表，堆，队列，栈，二叉树，B树/B+树，红黑树，图(研发问图不多) 2. 常见的排序算法(冒泡，插入，快排，堆排，归并排序…) 3. 简单的动态规划问题(背包，上楼梯) 4. 各种时间空间复杂度分析 二、Java 基础1. 最基本的语言基础：语法，关键字含义，面向对象…. 2. 集合类(ArrayList, HashMap, ConcurrentHashmap…等等) 3. 多线程(锁，CAS，线程池，concurrent 包下的类) 4. 语言特性：反射，动态代理，泛型，Java 8 新特性 5. IO (装饰器模式，NIO) 6. JVM：内存模型，垃圾回收，类加载机制 三、 Java Web1. Tomcat，Servlet，JSP，Cookie/Session 等基本概念 2. 框架使用和原理：Spring(AOP，IoC)，MyBatis 等 四、数据库(主要是 MySQL)1. 基本 SQL 语句，索引优化 2. 存储引擎(InnoDB，MyISAM)，索引原理 3. 事务 ACID，隔离级别 4. 分库分表，主从复制，读写分离 五、计算机网络1. OSI 7 层模型和 TCP 4 层模型 2. 传输层：TCP/IP 相关知识，和 UDP 比较 3. HTTP 协议：报文结构，POST/GET 方法 4. 网络编程 (socket, NIO, select 等) 六、操作系统1. 基本 Linux 的操作指令 2. 进程/线程比较，进程间通信方式，P/V 操作 3. 磁盘调度，虚拟内存 4. 死锁，中断 七、书籍推荐1. 《算法》（第四版）图以前章节 2. 《剑指 Offer》 3. 《Java 编程思想》 4. 《Java多线程编程核心技术》(高洪岩 著) 5. 《Java 并发编程实战》 6. 《深入理解 Java 虚拟机》 7. 《Java 8 实战》 8. 《鸟哥的 Linux 私房菜》 9. 《MySQL 必知必会》 10. 《Maven 实战》 11. 《图解 HTTP》 12. 《敏捷软件开发》 13. 《架构探险－从零开始写 Java Web 框架》 14. 《Spring 3.x 企业应用开发实战》 15. 《Head First 设计模式》 16. 《大型网站技术架构》（李智慧 著） 17. 《大型网站系统与 Java 中间件实践》","categories":[{"name":"秋招","slug":"秋招","permalink":"http://yoursite.com/categories/秋招/"}],"tags":[{"name":"秋招攻略","slug":"秋招攻略","permalink":"http://yoursite.com/tags/秋招攻略/"}]},{"title":"鸟哥Linux私房菜学习笔记（二）","slug":"鸟哥Linux私房菜学习笔记（二）","date":"2018-05-23T15:50:30.000Z","updated":"2018-11-18T20:38:08.958Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（二）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（二）/","excerpt":"","text":"##什么是挂载？挂载的用途是什么？书上讲的挂载不是很清楚，在网络上搜索后，对挂载有了较为深刻的理解，在此总结如下。 在Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。 Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给Linux的所有区都在/下的某个位置，比如/home等等。 提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。 我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。 这时提问者使用了mount /dev/sdb1 ~/Share/，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。 所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。 Linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ 这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。 插入CD，系统其实自动执行了mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理 ##参考资料 Linux学习笔记（二）：什么是挂载？mount的用处在哪？","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"鸟哥Linux私房菜学习笔记（一）","slug":"鸟哥Linux私房菜学习笔记（一）","date":"2018-05-23T15:39:11.000Z","updated":"2018-11-18T20:37:46.301Z","comments":true,"path":"2018/05/23/鸟哥Linux私房菜学习笔记（一）/","link":"","permalink":"http://yoursite.com/2018/05/23/鸟哥Linux私房菜学习笔记（一）/","excerpt":"","text":"之前把这本书看过一遍，但是时间一长就忘记了。在此review一遍，准备秋招，又能加深理解。虚拟机：VMware物理机版本：macOS10.13.4Linux版本：CentOS7.0 64位虚拟机配置：20G硬盘，2GB内存 ##基础知识及常用命令 Linux默认提供6个terminal来让用户登录，切换的方式为：CTRL+ALT+F1~F6。F7切换为图形界面。 Linux系统对字母大小写敏感。 显示时间和日期的命令：date 显示日历的命令：cal 计算器：bc 常用的关机命令：shutdown； shutdown -h 20:00是指在晚上8点钟关机；shutdown -h now是指立刻关机。 ##注意事项 VMware虚拟机进入BIOS：开机按F2键 安装时需自定义分区 ##参考资料 Linux学习笔记(一)：Win10上用VMware虚拟机安装Linux-CentOS","categories":[{"name":"Development","slug":"Development","permalink":"http://yoursite.com/categories/Development/"},{"name":"Linux","slug":"Development/Linux","permalink":"http://yoursite.com/categories/Development/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"七牛云qshell使用教程","slug":"七牛云qshell使用教程","date":"2018-04-22T12:44:56.000Z","updated":"2018-11-18T20:32:05.181Z","comments":true,"path":"2018/04/22/七牛云qshell使用教程/","link":"","permalink":"http://yoursite.com/2018/04/22/七牛云qshell使用教程/","excerpt":"","text":"###1.下载qshell本人使用的是MAC，官网开发者工具处下载的qshell无法运行，但是可以从Github下载qshell，修改名称为qshell,并运行。 ###2.修改权限如果在Linux或者Mac系统上遇到Permission Denied的错误，请使用命令chmod +x qshell来为文件添加可执行权限。 ###3.修改路径将qshell复制到/usr/local/bin/目录下。使其在terminal下能够直接被调用。 ###4.配置账户 配置access key和secret key：qshell account AK SK 查看当前key：qshell account ###5.常用命令|命令|类别|描述|详细||——|————|———-|——–||account|账号|设置或显示当前用户的AccessKey和SecretKey|文档||dircache|存储|输出本地指定路径下所有的文件列表|文档||listbucket|存储|列举七牛空间里面的所有文件|文档||prefop|存储|查询七牛数据处理的结果|文档||fput|存储|以文件表单的方式上传一个文件|文档||rput|存储|以分片上传的方式上传一个文件|文档||qupload|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（配置式）|文档||qupload2|存储|同步数据到七牛空间， 带同步进度信息，和数据上传完整性检查（命令式）|文档||qdownload|存储|从七牛空间同步数据到本地，支持只同步某些前缀的文件，支持增量同步|文档||stat|存储|查询七牛空间中一个文件的基本信息|文档||delete|存储|删除七牛空间中的一个文件|文档||move|存储|移动或重命名七牛空间中的一个文件|文档||copy|存储|复制七牛空间中的一个文件|文档||chgm|存储|修改七牛空间中的一个文件的MimeType|文档||chtype|存储|修改七牛空间中的一个文件的存储类型，支持普通存储（0）和低频存储（1）|文档||expire|存储|修改七牛空间中的一个文件的生存时间|文档||fetch|存储|从Internet上抓取一个资源并存储到七牛空间中|文档||sync|存储|从Internet上抓取一个资源并存储到七牛空间中，适合大文件的场合|文档||prefetch|存储|更新七牛空间中从源站镜像过来的文件|文档||batchdelete|存储|批量删除七牛空间中的文件，可以直接根据listbucket的结果来删除|文档||batchchgm|存储|批量修改七牛空间中文件的MimeType|文档||batchchtype|存储|批量修改七牛空间中的文件的存储类型，支持普通存储（0）和低频存储（1）|文档||batchexpire|存储|批量修改七牛空间中的文件的生存时间|文档||batchcopy|存储|批量复制七牛空间中的文件到另一个空间|文档||batchmove|存储|批量移动七牛空间中的文件到另一个空间|文档||batchrename|存储|批量重命名七牛空间中的文件|文档||batchsign|存储|批量根据资源的公开外链生成资源的私有外链|文档||batchstat|存储|批量查询七牛空间中文件的基本信息|文档||privateurl|存储|生成私有空间资源的访问外链|文档||saveas|存储|实时处理的saveas链接快捷生成工具|文档||reqid|存储|七牛自定义头部X-Reqid解码工具|文档||buckets|存储|获取当前账号下所有的空间名称|文档||domains|存储|获取指定空间的所有关联域名|文档||qetag|存储|根据七牛的qetag算法来计算文件的hash|文档||m3u8delete|存储|根据流媒体播放列表文件删除七牛空间中的流媒体切片|文档||m3u8replace|存储|修改流媒体播放列表文件中的切片引用域名|文档||cdnrefresh|CDN|批量刷新cdn的访问外链或目录|文档||cdnprefetch|CDN|批量预取cdn的访问外链|文档||b64encode|工具|base64编码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||b64decode|工具|base64解码工具，可选是否使用UrlSafe方式，默认UrlSafe|文档||urlencode|工具|url编码工具|文档||urldecode|工具|url解码工具|文档||ts2d|工具|将timestamp(单位秒)转为UTC+8:00中国日期，主要用来检查上传策略的deadline参数|文档||tms2d|工具|将timestamp(单位毫秒)转为UTC+8:00中国日期|文档||tns2d|工具|将timestamp(单位100纳秒)转为UTC+8:00中国日期|文档||d2ts|工具|将日期转为timestamp(单位秒)|文档||ip|工具|根据淘宝的公开API查询ip地址的地理位置|文档||unzip|工具|解压zip文件，支持UTF-8编码和GBK编码|文档||alilistbucket|第三方|列举阿里OSS空间里面的所有文件|文档|","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"七牛云","slug":"七牛云","permalink":"http://yoursite.com/tags/七牛云/"}]},{"title":"尾调用及其优化","slug":"尾调用及其优化","date":"2018-04-04T01:31:21.000Z","updated":"2018-11-18T20:25:38.750Z","comments":true,"path":"2018/04/03/尾调用及其优化/","link":"","permalink":"http://yoursite.com/2018/04/03/尾调用及其优化/","excerpt":"","text":"之前一直对尾调用相关概念比较模糊，在此做一个总结。 一、 什么是尾调用尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。function f(x){ return g(x); }上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下两种情况，都不属于尾调用。 // 情况一function f(x){ let y = g(x); return y;}// 情况二function f(x){ return g(x) + 1;}上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x &gt; 0) { return m(x) } return n(x);}上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 二、 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3);上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。 三、 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5) // 120上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1) // 120对于以上的阶乘，由于递归在方法的末尾，因此方法中的局部变量已经毫无用处，编译器完全可以将其“复用”，并把尾递归优化为“循环”方式。由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 四、递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}function factorial(n) { return tailFactorial(n, 1);}factorial(5) // 120上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 function currying(fn, n) { return function (m) { return fn.call(this, m, n); };}function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5) // 120 五、参考资料 尾调用优化 浅谈尾递归的优化方式","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"recursive","slug":"recursive","permalink":"http://yoursite.com/tags/recursive/"}]},{"title":"MAC下Homebrew的安装及使用","slug":"MAC下Homebrew的安装及使用","date":"2018-04-02T15:19:03.000Z","updated":"2018-11-18T20:28:24.927Z","comments":true,"path":"2018/04/02/MAC下Homebrew的安装及使用/","link":"","permalink":"http://yoursite.com/2018/04/02/MAC下Homebrew的安装及使用/","excerpt":"","text":"##1. 什么是什么是HomebrewHomebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebrew可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 ##2. Homebrew的安装Homebrew的安装很简单，只需在终端下输入如下指令：ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序。 这时你在命令行状态下面就可以使用 brew 命令了。 ##3. Homebrew的使用 安装软件：brew install 软件名，例：brew install wget 搜索软件：brew search 软件名，例：brew search wget 卸载软件：brew uninstall 软件名，例：brew uninstall wget 更新所有软件：brew update 更新具体软件：brew upgrade 软件名 ，例：brew upgrade git 显示已安装软件：brew list 查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git 查看那些已安装的程序需要更新： brew outdated 显示包依赖：brew reps通过 update 可以把包信息更新到最新，不过包更新是通过git命令，所以要先通过 brew install git 命令安装git。 ##4. 参考资料 【工具】Homebrew的安装及使用","categories":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/categories/Mac/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://yoursite.com/tags/homebrew/"}]},{"title":"比特币与区块链","slug":"比特币与区块链","date":"2018-03-23T23:23:18.000Z","updated":"2018-11-18T20:36:41.843Z","comments":true,"path":"2018/03/23/比特币与区块链/","link":"","permalink":"http://yoursite.com/2018/03/23/比特币与区块链/","excerpt":"","text":"I learned the basic ideas of bitcoin and blockchain in the computer security class last week, so I just write a summary here. ##1.LedgerFirstly, let’s talk about the ledger. Why use a ledger? If you exchange money with some people very frequently, using a ledger is better than cash. So you guys can create a ledger and record all the transactions. For example, Alice, Bob, Charlie and you. You can see some records in the ledger as below:Alice pays Bob $20Bob pays Charlie $40Charle pays you $30You pay Alice $10 This ledger is public, everybody could add new records in it. In the end of every moth, people will look at the list of records and settle up.As above description, the protocol is pretty simple: Anyone could add records to the Ledger; Settle up with US dollars every moth; However, there is a problem of the protocol. Anyone can add a new transaction if he/she want. For example, Alice can add a record that Bob pays Alice $200 without telling Bob. How to solve this problem? ##2.Digital SignatureIn the real world, we can sign our name at the end of every transaction. The signature could prove we already have seen it and approve it. In the computer world, we should use digital signature. The digital signature leverages hash function. There is an example as below: Transaction Signature Alice pays Bob $20 Signature1=hash(“Alice pays Bob $20”) Bob pays Charlie $40 Signature2=hash(“Bob pays Charlie $40”) Bob pays Charlie $30 Signature3=hash(“Bob pays Charlie $30”) There is a crucial problem. As the handwritten signature, a digital signature could be forged. Actually, the digital signature is a string of bits, people could copy it. So it cannot prevent forgeries. How to prove the signature’s owner? ##3.Public-key CryptoWhat is Public-key cryptography? You can click the hyperlink to see the details. To solve the problem as above, the basic idea is: Get the hash value by hash fuction (SHA-256);HashValue=SHA-256(OriginalRecord) Alice use her own private key to encrypt the hash value generated before;Signature=Sign(HashValue,PrivateKey) Anyone could use Alice’s public key to decrypt the signature and compare the result with original record. This process is called signature verify, the result is true or false;Result(T/F)=Verify(OriginalRecord,Signature,PublicKey) If the result is true, it means: This signature belongs to this record; This signature belongs to Alice; This record is not modified by others; However, there is another problem: even though other people cannot forge Alice’s signature, but they can copy a whole record to a new line. Luckily, there is a solution: add an unique sequence number to every record. Until now, the protocol looks like below. Anyone could add records to the Ledger; Settle up with US dollars every moth; Only signed transactions are valid; It seems perfect, but there must be some people break the rules. So we must rely on some honor system. In the paper “Bitcoin: A Peer-to-Peer Electronic Cash System”, the author proposed “peer-to-peer”. It means that it shouldn’t be a central system in the protocol. If Bob owes a lot of money and runs away, how to handle this problem? The protocol should be changed as below: Anyone could add records to the Ledger; No overspending; Only signed transactions are valid; In theory, if all people in the world was using this ledger, people could live their whole life just sending and receiving money on this ledger without real US dollars. So the ledger should be placed in a public place, such as a website where anyone can add new records. But who host the website? As I described above, we cannot use a central system, but we can have everybody hold their own copy of ledger. In the network, if someone makes a transaction what he/she does it broadcast that out into the whole network. According to this approach, how could you get everyone to agree on what the right ledger is? how to make everyone received and believes that transaction? how to add the transactions in the ledger if you received them together? ##4.Bitcoin&amp;BlockchainFor a hash function like SHA-256, whatever you put into it, the result is a 256 bits string. What the miners do is that they find a number add into the ledger, and then use SHA-256(ledger+number) to get a result. The result first 30 bits are “0”! But find the number is very very hard. The only way to find the special number is guessing and checking. So the miner has to go through about a billion different numbers before finding the special one. But the verify process is much easier. The process that people find the number is called “proof of work”. Let’s go back the distributed ledger situations. In the whole network, there are many copies of ledger, every copy is a block. And in each block, it contains a list of transactions(records) with a proof of work(special number). A block is only considered valid if it has a proof of work. But how the next transactions know the previous transactions that use to make sure someone has enough money to pay? We make a block has to contain the hash of the previous block at its header, it means every transaction should base on the previous transactions. It looks like a blockchain. In the blockchain, anyone could be a block creater. The creator is going to listen for transactions being broadcast, collect into some block, and then computes the special number that makes the hash of that block start with N zeros. Once he/she find it, just broadcast out the block he/she found. To reward a bloack creator for all this work, when the creator puts together a block, we allow he/she to include a very special transaction at the top of it, it is called block reward. It means the total number of bitcoin in our economy increases with each block. The process of creating blocks is called “mining”, the creator called “miner”. what the miner did is listening for transactions, creating blocks, broadcasting those blocks, and getting rewarded with new money for doing so. The miner’s computer more powerful, the high possibility they have. However, if someone receive two blocks at the same, what should he does? The solution is that he just makes a branch and keep both of them, and waits for the next block. It is hardly to receive two blocks at the same time. If receive, just wait for the third block. After that, he/she just selects the longer branch and discard the other one. ##5.Techniques Leverage SHA-256 hash function and public-key crypto to generate digital signature Save the transactions by blocks of blockchain Protect the bitcoin network and control the average block time by setting extra works Incent miner to increase the network Transactions of bitcoin don’t rely on bank or other honor system ##6.Tips The Average Block Time is about 10 minuetes The total number of bitcoin is less than 21 million GPU mining is faster than CPU mining. Block Reward: 12.5 BTC (2017) Transaction Fee: average 2 BTC (2017) Average income of one block: 14.5 BTC = 260 thousand USD = 1.7 million USD To maintain the average block time, the bitcoin network upgrade the degree of difficulty every two weeks Bitcoin is saved in your bitcoin client ##7.Reference Ever wonder how Bitcoin (and other cryptocurrencies) actually work? 比特币的原理","categories":[{"name":"Concepts","slug":"Concepts","permalink":"http://yoursite.com/categories/Concepts/"}],"tags":[{"name":"concepts","slug":"concepts","permalink":"http://yoursite.com/tags/concepts/"}]},{"title":"Markdonw语法","slug":"Markdown语法","date":"2018-01-05T14:40:51.000Z","updated":"2018-11-18T20:24:42.831Z","comments":true,"path":"2018/01/05/Markdown语法/","link":"","permalink":"http://yoursite.com/2018/01/05/Markdown语法/","excerpt":"","text":"1.标题标题共有六级。“#”数量代表标题级数。 一级标题 # text 二级标题 ## text 三级标题 ### text … 2.列表 有序列表:1. text2. text3. text 无序列表：* text* text 3.引用只需要在需要引用的文本前加入 “&gt;” 这种尖括号（大于号）即可。&gt; text This is a reference. 4.图片与链接插入链接与插入图片的语法很像，区别在一个”!”号。 图片为：![]() 链接为：[]()My Blog 5.粗体与斜体在文本前加入**text**，即为粗体， *text*即为斜体。注意，星号间不能有空格。 这是 粗体 ，这是 斜体。 6.分隔线分隔线只需要三个星号，像这样***。 我上面和下面都是分隔线。 7.表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 8.代码框代码框只需要用包裹文字即可。用TAB缩进。 参考 Markdown——入门指南 Learning-Markdown","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"markdonw","slug":"markdonw","permalink":"http://yoursite.com/tags/markdonw/"}]},{"title":"开发中遇到的问题及解决方法","slug":"开发中遇到的问题及解决方法","date":"2017-07-20T13:11:26.000Z","updated":"2018-11-21T01:17:23.352Z","comments":true,"path":"2017/07/20/开发中遇到的问题及解决方法/","link":"","permalink":"http://yoursite.com/2017/07/20/开发中遇到的问题及解决方法/","excerpt":"","text":"用MAVEN模板新建项目时，要添加：archetypeCatalog-internal，否则很慢； GIT上新建项目：先在远程仓库建好项目，再checkout到本地编辑，然后提交； 从Tomcat 5.5.15开始，放入到session中的对象必须实现java.io.Serializable接口； &lt;intercept-url pattern=&quot;/login*&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;加入URL接口；拦截需要的URL在controller处理； 文本域中有空格：将其放在一行； MAVEN仓库中可以直接下载JAR包；但是之后删除artifacts，用模块新建； 如果用“.”作为分隔的话,必须是如下写法,String.split(“\\.”),这样才能正确的分隔开,不能用String.split(“.”); intellij web项目中的Facets 和 Artifacts有什么区别？答：Facets表示某个module有的特征，比如web、strtus2、spring、hibernate等；Artifacts是maven中的一个概念，表示某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式；一个module有了Artifacts就可以部署到应用服务器中了！ on update action ：当发现更新时的操作；选择update classes and resources on frame deactivation: 当IDEA 切换时的操作 （比如缩下去 打开网页） 选择update classes and resources也就是 自动编译 自动部署的功能 很多人说Intellij IDEA 不能自动编译 就是这个这个地方没设置好On frame deactivation：在你失去焦点的时候自动编译。例如：修改某文件后你直接切换到了浏览器，或者点了下别的。只要当前的intellij idea 不是焦点就会激活自动编译并更新文件动作。也就是说不用手动按ctrl+F9了。 调试：private static final Logger LOG = LoggerFactory.getLogger(OWLLogCreator.class); 使用AES加密时，当密钥大于128时，代码会抛出Java.security.InvalidKeyException: Illegal key size or default parameters。解决办法：去掉这种限制需要下载Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.网址如下。下载包的readme.txt 有安装说明。就是替换${java_home}/jre/lib/security/ 下面的local_policy.jar和US_export_policy.jar 导入新的SDK后，需要重置Artifacts； JAVA解析JSON数据： RSA非对称加密内容长度有限制，1024位key的最多只能加密127位数据，否则就会报错(javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes) Data must not be longer than 117 bytes异常 RSA加密解密内容超长报错在使用 RSA加密解密内容时会出现这样的异常 ：Data must not be longer than 117 bytes。解决办法是：分段加密和分段解密 1234567891011121314// 加密时超过117字节就报错。为此采用分段加密的办法来加密 byte[] enBytes = null;for (int i = 0; i &lt; data.length; i += 64) &#123; // 注意要使用2的倍数，否则会出现加密后的内容再解密时为乱码 byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(data, i,i + 64)); enBytes = ArrayUtils.addAll(enBytes, doFinal); &#125;// 解密时超过128字节就报错。为此采用分段解密的办法来解密StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; data.length; i += 128) &#123; byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(data, i, i + 128)); sb.append(new String(doFinal));&#125; When you create cipher with default parameters, it defaults to “RSA/ECB/PKCS1Padding”. RSA加解密:1024位的证书，加密时最大支持117个字节，解密时为128；2048位的证书，加密时最大支持245个字节，解密时为256。加密时支持的最大字节数：证书位数/8 -11（比如：2048位的证书，支持的最大加密字节数：2048/8 - 11 = 245） 绕过P+U直接放行 12345678910111213private void saveSession(String username,String password) &#123; User user = new User(username,password); List&lt;Privilege&gt; privileges = new ArrayList&lt;&gt;(); privileges.add(Privilege.COMPANY_ADMIN); user.setPrivileges(privileges); IdsUserDetails userDetails = new IdsUserDetails(user); final UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails, userDetails.getPassword(), userDetails.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(auth); SecurityContextImpl securityContext = new SecurityContextImpl(); securityContext.setAuthentication(auth); SpringSecurityHolder.setSecurityContext(securityContext);&#125; 遍历MAP 12for(Map.Entry&lt;String, Object&gt; entry:map.entrySet())&#123; System.out.println(entry.getKey()+&quot;---&gt;&quot;+entry.getValue());&#125; 以下是Java 判断字符串是否为空的四种方法:方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:if(s == null ||&quot;&quot;.equals(s));方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:if(s == null || s.length() &lt;= 0);方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.if(s == null || s.isEmpty());方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:f (s == null || s == &quot;&quot;);注意:s == null 是有必要存在的. 如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException. 并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException. 如下Java代码: 12345 String str = null; if(str.equals(&quot;&quot;) || str= == null)&#123;//会抛出异常 System.out.println(&quot;success&quot;); &#125; // &quot;&quot;.equals(str);后置确保不会遇null报错； java中如何将对象转成json格式字符串： 123Person person=new Person();Gson gson=new Gson();String json=gson.toJson(person); dos命令目录中不能有空格：在带有空格的参数开始和结尾 加上””双引号。 HTML界面转JSP文件后CSS等不显示，因为资源被拦截，需要改配置： 1234561、 &lt;mvc:resources&gt;的理解使用(1)web.xml配置1 &lt;servlet&gt; 2 &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; 3 &lt;servletclass&gt;org.springframework.web.servlet.DispatcherServle&lt;/servlet-class&gt; 4 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 5 &lt;/servlet&gt; 6 &lt;servlet-mapping&gt; 7 &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; 8 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 9 &lt;/servlet-mapping&gt;这里设置了spring的拦截请求为/，并且会自动在web-inf下面扫描一个名为&quot;springMVC-servlet.xml&quot;的文件，由这个类org.springframework.web.servlet.DispatcherServlet去加载，当然也可以手动配置到listener中。(2)由于你拦截了所有请求，所以会影响到静态资源的获取，有两种方法。 一，仍然拦截所有请求，&lt;mvc:resources location=&quot;/WEB-INF/js/&quot; mapping=&quot;/javascript/**&quot; /&gt;然后设置标签映射，当你要引用/WEB-INF/js/文件夹下的文件时，可以直接引用/javascript/**.js，这样就会去location里面去找，大概原理就是spring在遇到这个标签，会把本地资源拦截并映射到mapping目录下，当你引用mapping的时候，会自动去找对应的文件 @ResponseBody：作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； java中如何忽略字符串中的转义字符：String s2 = StringEscapeUtils.unescapeJava(s); @Autowired不用写配置文件完成层与层之间的调用； 解决多个controller的路径问题：${pageContext.request.contextPath} JSP取得绝对路径&lt;c:set var=&quot;contextPath&quot; value=&quot;${pageContext.request.contextPath}&quot; scope=&quot;application&quot;/&gt; 版本号等常量值可以写一个接口，便于修改； 在 WEB.XML配置&lt;mime-mapping&gt;实现浏览器根据文件类型自动打开。我们用浏览器打开文件的时候会发现如果是doc文件， 会用记事本打开，出现乱码， 但是如果在web.xml里面配置了类型，浏览器就会根据配置的类型自动调用相应的程序打。 Spring-mvc Unable to find a default provider原因：在Spring-mvc.xml配置文件中使用了 “ mvc:annotation-driven “，而这个需要一个关于hibernate的jar包，在项目中引入 hibernate-validator-4.3.1.Final.jar 这个包之后，就可以正常启动了。 IDEA每次新项目要在setting中把maven本地路径打钩； 转发和重定向的区别区别一： 重定向时浏览器上的网址改变 转发是浏览器上的网址不变区别二： 重定向实际上产生了两次请求转发只有一次请求 JAVA中接口中的接口方法默认是public的； LOG4J添加发送邮件功能时，遇到NoClassDefFoundError: javax/mail/MessagingException，原因是tomcat没有mail.jar包，引入即可； controller是按照顺序匹配的么？controller匹配URL规则是先按照最精确的匹配，然后按照通配符等； decorators.xml文件中标签配置: 123&lt;excludes&gt; &lt;pattern&gt;/order/httplist*&lt;/pattern&gt;&lt;/excludes&gt; 表明以/order/httplist为前缀的页面不会被模板页decorate, 1. 例如，如果Controller中有一方法： 1234@RequestMapping(value = &quot;/order/httplist&quot;)public String httplist(Model model,@ModelAttribute(&quot;req&quot;) OrderReq req,HttpServletRequest request)&#123;&#125; 则在响应form表单的httplist–action时，httplist.jsp页面不会被模板页decorate 2. 另外，如果直接通过 document.getElementById(“innerFrame”).src=targetEndpoint+”list?province=”+outProvince+”&amp;carrier=”+outCarrier;跳转到httplist.jsp页面，则同样地，httplist.jsp页面也不会被模板页decorate. /这里面,BindResult result必须紧跟着前面的@ModelAttribute, 否则会出错 Uncaught ReferenceError: $ is not defined：没有引入jQuery； 圈复杂度可以通过程序控制流图计算，公式为：V(G) = e + 2 - n e : 控制流图中边的数量 n : 控制流图中节点的数量(包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点) 窜数据：Spring的Controller默认是Singleton的，这意味着每个request过来，系统都会用原有的instance去处理，这样导致了两个结果:一是我们不用每次创建Controller，二是减少了对象创建和垃圾收集的时间;由于只有一个Controller的instance，当多个线程调用它的时候，它里面的instance变量就不是线程安全的了，会发生窜数据的问题。变量的作用域，一共4种。pageScope: 表示变量只能在本页面使用。requestScope:表示变量能在本次请求中使用。sessionScope:表示变量能在本次会话中使用。applicationScope:表示变量能在整个应用程序中使用。 @ModelAttribute注释的方法会在此controller每个方法执行前被执行 如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，否则就应该是非静态。因此像工具类，一般都是静态的。 根据设计原则，类与类之间的关系，最好是你不认识我，我不认识你，解耦~直接用静态，则破坏了这个原则~ ，另外是推荐使用接口编程的~ 代码混乱-&gt;生产力下降-&gt;管理层增加更多人-&gt;新人对系统并不了解； 工具类Util应该是抽象的，私有的构造方法（不能new）； 理论上, 任何的public的方法都要有测试；","categories":[{"name":"遇到的问题","slug":"遇到的问题","permalink":"http://yoursite.com/categories/遇到的问题/"},{"name":"Java开发","slug":"遇到的问题/Java开发","permalink":"http://yoursite.com/categories/遇到的问题/Java开发/"},{"name":"Java开发常见问题","slug":"遇到的问题/Java开发/Java开发常见问题","permalink":"http://yoursite.com/categories/遇到的问题/Java开发/Java开发常见问题/"}],"tags":[{"name":"遇到的问题","slug":"遇到的问题","permalink":"http://yoursite.com/tags/遇到的问题/"},{"name":"Java开发","slug":"Java开发","permalink":"http://yoursite.com/tags/Java开发/"},{"name":"Java开发常见问题","slug":"Java开发常见问题","permalink":"http://yoursite.com/tags/Java开发常见问题/"}]},{"title":"代码简洁之道","slug":"代码简洁之道","date":"2017-03-20T22:08:22.000Z","updated":"2018-11-21T01:12:01.281Z","comments":true,"path":"2017/03/20/代码简洁之道/","link":"","permalink":"http://yoursite.com/2017/03/20/代码简洁之道/","excerpt":"","text":"有意义的命名，一眼能看出是干嘛的； 类名不应该是动词，应当是名字或名词短语；方法名应该是动词或动词短语； 方法应该短小，20行最佳；方法只做一件事；函数参数应该少；抽离try/catch代码块；不写重复的代码； 不要返回null值，不要传递null； 类：先是公共静态常量，私有静态变量，私有实例变量。很少有公共变量；类应该短小；； 如果一个类中的每个变量被每个方法使用，说明这个类有最大的内聚性； java不要继承接口中的常量； 一个类认识其他类越少，耦合度越低； 变量就像孩子，尽量在视线范围内；","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"}]}]}