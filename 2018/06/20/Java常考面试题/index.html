<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="秋招,java,面试,">










<meta name="description" content="Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？Ja">
<meta name="keywords" content="秋招,java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常考面试题">
<meta property="og:url" content="http://yoursite.com/2018/06/20/Java常考面试题/index.html">
<meta property="og:site_name" content="William&#39;s Blog">
<meta property="og:description" content="Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？Ja">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/Users/william.sun/Desktop/interview-questions/thread-status.png">
<meta property="og:image" content="http://yoursite.com/Users/william.sun/Desktop/interview-questions/JavaCollections.png">
<meta property="og:updated_time" content="2018-11-18T21:39:35.168Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java常考面试题">
<meta name="twitter:description" content="Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？Ja">
<meta name="twitter:image" content="http://yoursite.com/Users/william.sun/Desktop/interview-questions/thread-status.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/20/Java常考面试题/">





  <title>Java常考面试题 | William's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c4513f4fbfc11c5b50e8b9ea0162050";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">William's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">SDET (Software Development Engineer in Test)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/Java常考面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="William's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java常考面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T08:34:09+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol>
<li>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？<br>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</li>
<li>JDK和JRE的区别是什么？<br>Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。<br>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</li>
<li>”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或是static的方法?<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。<br>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</li>
<li>是否可以在static环境中访问非static变量？<br>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</li>
<li>Java支持的数据类型有哪些？什么是自动拆装箱？<br>Java语言支持的8种基本数据类型是：byte，short，int，long，float，double，boolean，char。<br>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。<br>Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程</li>
<li>Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。方法的重载是可以改变返回值类型的。</li>
<li>Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？<br>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。<br>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</li>
<li>Java支持多继承么？<br>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li>
<li>接口和抽象类的区别是什么？<br>不同点在于：<ol>
<li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li>
<li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li>
<li>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。<br>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
</li>
<li>什么是值传递和引用传递？<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.<br>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递.</li>
<li>进程和线程的区别是什么？<br>进程是运行在内存中的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。线程与进程的区别归纳：<br>a. 进程是运行中的程序，线程是进程的内部的一个执行序列<br>b. 进程是资源分配的单元，线程是执行行单元<br>c. 进程间切换代价大，线程间切换代价小<br>d. 进程拥有资源多，线程拥有资源少<br>e. 多个线程共享进程的资源</li>
<li>创建线程有几种不同的方式？你喜欢哪一种？为什么？<ol>
<li>继承Thread类，重写run方法；</li>
<li>实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性；</li>
<li>实现callable接口，重写call方法，有返回值。</li>
<li>使用实现了Executor接口的ThreadPoolExecutor来创建线程池。<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</li>
</ol>
</li>
<li>概括的解释下线程的几种可用状态。<ol>
<li>新建( new )：新创建了一个线程对象。</li>
<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>
<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>
<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。<br>当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li>
<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。<br><img src="/Users/william.sun/Desktop/interview-questions/thread-status.png" alt="线程状态图"></li>
</ol>
</li>
<li>同步方法和同步代码块的区别是什么？<br>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br>同步方法使用关键字 synchronized修饰方法;<br>同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；</li>
<li>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？<br>监视器和锁在java中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程能访问同步代码块。每一个对象都与一个监视器相关联，没有获取到锁的对象不能执行这块同步代码块.</li>
<li>什么是死锁(deadlock)？<br>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br>死锁产生的4个必要条件：<br>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li>
<li>如何确保N个线程可以访问N个资源同时又不导致死锁？<br>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</li>
<li>Java集合类框架的基本接口有哪些？<br>Java集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br><img src="/Users/william.sun/Desktop/interview-questions/JavaCollections.png" alt="Java集合框架"></li>
<li>为什么集合类没有实现Cloneable和Serializable接口？<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。克隆和序列化又被称为标识接口，在java中只起到标识类的作用。</li>
<li>什么是迭代器(Iterator)？<br>迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。</li>
<li>算法导论中原话：“基数排序是首先按最低位有效数字进行排序，才是稳定的算法”。</li>
<li>不稳定：快选堆希<br>稳定：插冒归基</li>
<li>Iterator和ListIterator的区别是什么？<br>下面列出了他们的区别：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
<li>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<ol>
<li>快速失败（fail—fast）：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。<br>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li>
<li>安全失败（fail—safe）<br>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。<br>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。<br>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。在java.util包下的都是快速失败。<br>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。在java.util.concurrent包下的全是安全失败的。</li>
</ol>
</li>
<li>Java中的HashMap的工作原理是什么？<br>hashmap的底层是以数组和单向链表进行实现的，当进行put操作的时候，首先通过hashcode()方法进行计算key的hash值，然后找出链表索引，然后看索引上是否有相同的key值，如果有就更新value值，如果没有就把值加在链表尾。hashmap有两个重要的属性参数，capacity（容量）和loadfactor（负载因子），初始值分别为16与0.75，当存储的数据的数量达到了capacity*loadfactor就会进行扩容操作（resize），将容量扩充为2n。一般进行初始化的时候，可以重新设置capacity与loadfactor，但是一般capacity的默认值一般是比较好的，不需要进行更改。只需要考虑capacity的值就行了，一般如果能够提前预估容量大小，将会大大减少扩容的消耗。</li>
<li>hashCode()和equals()方法的重要性体现在什么地方？<br>Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</li>
<li>HashMap和Hashtable有什么区别？<br>都实现了Map接口，但是不同点有:<ol>
<li>HashMap是非线程安全的，HashTable是线程安全的。</li>
<li>HashMap的键和值都允许有null值存在，而HashTable则不行。</li>
<li>因为线程安全的问题，HashMap效率比HashTable的要高。</li>
<li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li>
</ol>
</li>
<li>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？<br>下面列出了Array和ArrayList的不同点：<ol>
<li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li>
<li>Array大小是固定的，ArrayList的大小是动态变化的。</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>
</ol>
</li>
<li>ArrayList和LinkedList有什么区别？<br>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。  </li>
<li>Comparable和Comparator接口是干什么的？列出它们的区别。<br>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</li>
<li>什么是Java优先级队列(Priority Queue)？<br>优先级队列就是一种自己定义队列中元素大小的队列</li>
<li>你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？<br>O：大O是上界<br>Θ：大Θ是平均值<br>Ω：大Ω是下界</li>
<li>如何权衡是使用无序的数组还是有序的数组？<br>有序数组查询容易，插入难。无序数组插入容易，查询难.<br>查找复杂度：有序数组O(log n) ，无序数组 O(n)<br>插入复杂度：有序数组O(n) ，无序数组 O(1)  </li>
<li>Java集合类框架的最佳实践有哪些？<br>一开始还在想，难道有什么经典的算法或者什么方法理论，称之为最佳实践。看了答案才知道是怎么去选择一个合适的集合类框架。 那么，首先选一个适合的。比如固定那就选不拓展，插入频繁就链表，查询频繁就数组。不知道这个答案可以不？<br>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。<br>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。<br>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。<br>使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。<br>编程的时候接口优于实现。<br>底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</li>
<li>Enumeration接口和Iterator接口的区别有哪些？<br>iterator是快速失败的，当你在遍历的时候，如果另起一个线程来修改它（集合的内容）的结构，这时迭代器会立马感知到，引起快速失败，抛出ConcurrentModificationException异常。<br>所以说iterator 是安全的。</li>
<li>HashSet和TreeSet有什么区别？<br>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。<br>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</li>
<li>Java中垃圾回收有什么目的？什么时候进行垃圾回收？<br>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。<br>触发主GC（Garbage Collector，垃圾回收）的条件：<br>（1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。<br>（2）Java堆内存不足时，GC会被调用。</li>
<li>System.gc()和Runtime.gc()会做什么事情？<br>这俩个方法都是用来提示java虚拟机进行垃圾回收，但是否立即回收还是延迟回收由java虚拟机决定。</li>
<li>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？  <ol>
<li>垃圾回收器在回收某对象时，垃圾收集器会调用对象的finalize()方法。</li>
<li>析构finalization，比如你在调用了一些native的方法，可以要在finaliztion里去调用释放函数。</li>
</ol>
</li>
<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？<br>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</li>
<li>Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?<br>虚拟机中的共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。<ol>
<li>年轻代: 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生<br>命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在<br>Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这<br>个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了<br>的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区<br>(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时<br>存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第<br>一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，<br>Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减<br>少被放到年老代的可能。  </li>
<li>年老代: 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认<br>为年老代中存放的都是一些生命周期较长的对象。  </li>
<li>持久代:用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应<br>用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持<br>久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置。</n></li>
</ol>
</li>
<li>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？<br>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</li>
<li>在Java中，对象什么时候可以被垃圾回收？<br>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</li>
<li>JVM的永久代中会发生垃圾回收么？<br>JAVA堆内存分为持久代，年轻代和老年代。<br>年轻代存放新生成的对象。垃圾回收主要是针对这个区域。<br>在年轻代中经历了N次垃圾回收依然存活的对象被放入老年代中。<br>持久代存放的是类定义信息，与垃圾收集器关系不大。  </li>
<li>Java中的两种异常类型是什么？他们有什么区别？<br>Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。</li>
<li>Java中Exception和Error有什么区别？<br>Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。</li>
<li>throw和throws有什么区别？<br>throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</li>
<li>异常处理完成以后，Exception对象会发生什么变化？<br>Exception对象会在下一个垃圾回收过程中被回收掉。</li>
<li>finally代码块和finalize()方法有什么区别？<br>无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。</li>
<li>什么是JDBC？<br>JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。</li>
<li>解释下驱动(Driver)在JDBC中的角色。<br>JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。</li>
<li>Class.forName()方法有什么作用？<br>初始化参数指定的类，并且返回此类对应的Class 对象.</li>
<li>PreparedStatement比Statement有什么优势？<br>PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象。<br>PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法, excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。<br>PreparedStatements的代码可读性，可维护性强于statement.<br>防止sql注入攻击，极大的提高了安全性。</li>
<li>什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？<br>CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStatement Connection.prepareCall();  </li>
<li>数据库连接池是什么意思？<br>像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。  </li>
</ol>
<hr>
<ol start="56">
<li>什么是RMI？<br>Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。</li>
<li>RMI体系结构的基本原则是什么？<br>RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。</li>
<li>RMI体系结构分哪几层？<br>RMI体系结构分以下几层：<br>存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。<br>远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。<br>传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</li>
<li>RMI中的远程接口(Remote Interface)扮演了什么样的角色？<br>远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</li>
<li>java.rmi.Naming类扮演了什么样的角色？<br>java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。  </li>
<li>RMI的绑定(Binding)是什么意思？<br>绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。</li>
<li>Naming类的bind()和rebind()方法有什么区别？<br>bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</li>
<li>让RMI程序能正确运行有哪些步骤？<br>为了让RMI程序能正确运行必须要包含以下几个步骤：<br>编译所有的源文件。<br>使用rmic生成stub。<br>启动rmiregistry。<br>启动RMI服务器。<br>运行客户端程序</li>
<li>RMI的stub扮演了什么样的角色？<br>远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：<br>初始化到包含了远程对象的JVM的连接。<br>序列化参数到远程的JVM。<br>等待方法调用和执行的结果。<br>反序列化返回的值或者是方法没有执行成功情况下的异常。<br>把值返回给调用者。</li>
<li>什么是分布式垃圾回收(DGC)？它是如何工作的？<br>DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 </li>
<li>RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？<br>RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。  </li>
</ol>
<hr>
<ol start="67">
<li>解释下Marshalling和demarshalling。<br>当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。  </li>
<li>解释下Serialization和Deserialization。<br>Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</li>
<li>什么是Servlet？<br>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</li>
<li>说一下Servlet的体系结构。<br>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</li>
<li>GenericServlet和HttpServlet有什么区别？<br>GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。<br>HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法.</li>
<li>解释下Servlet的生命周期。<br>1.加载实例化 2.初始化 3.处理请求 4.销毁<br>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：<br>①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。<br>②装载并创建该Servlet的一个实例对象。<br>③调用Servlet实例对象的init()方法。<br>④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。<br>⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。  </li>
<li>doGet()方法和doPost()方法有什么区别？<br>doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。<br>doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。  </li>
<li>什么是Web应用程序？<br>web应用程序就是一种可以通过web进行访问的应用程序，简单的说就是可以直接通过浏览器进行访问的应用程序。基于典型的B/S模式的应用程序，核心是对数据库的相关操作和处理.</li>
<li>什么是服务端包含(Server Side Include)？<br>服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。</li>
<li>什么是Servlet链(Servlet Chaining)？<br>Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。</li>
<li>如何知道是哪一个客户端的机器正在请求你的Servlet？<br>ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。</li>
<li>HTTP响应的结构是怎么样的？<br>响应消息行：包含协议/版本，响应状态码，对响应状态码的描述（一切正常);<br>响应消息头：:服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作;<br>响应消息正文：和网页右键“查看源码”看到的内容一样;  </li>
<li>什么是cookie？session和cookie有什么区别？<br>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：<br>无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。<br>在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。  </li>
<li>浏览器和Servlet通信使用的是什么协议？<br>浏览器和Servlet通信使用的是HTTP协议。  </li>
<li>什么是HTTP隧道？<br>HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。</li>
<li>sendRedirect()和forward()方法有什么区别？<br>sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。  </li>
<li>么是URL编码和URL解码？<br>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。  </li>
<li>什么是JSP页面？<br>jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。</li>
<li>JSP请求是如何被处理的？<br>客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。 </li>
<li>JSP有什么优点？<br>JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。<br>JSP页面可以被预编译。<br>JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。<br>开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。<br>开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。  </li>
<li>什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？<br>Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive：<br>包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。<br>页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。<br>Taglib指令： 用来声明页面中使用的自定义的标签库。</li>
<li>什么是JSP动作(JSP action)？<br>JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：<br>jsp:include-当JSP页面被请求的时候包含一个文件。<br>jsp:useBean-找出或者是初始化Javabean。<br>jsp:setProperty-设置JavaBean的属性。<br>jsp:getProperty-获取JavaBean的属性。<br>jsp:forward-把请求转发到新的页面。<br>jsp:plugin-产生特定浏览器的代码。  </li>
<li>什么是Scriptlets？<br>指jsp页面里 &lt;%    %&gt; 中间的代码。<br>一个包含任何在JSP页面中合法的脚本语言的代码片断的JSP脚本元素。Java Web开发时，尽量不要在JSP中出现这种Scriptlets，尽量多使用JSP标签，或者JSTL，或者一些框架的标签。</li>
<li>什么是JSP表达式(Expression)？<br>格式：&lt;%=有值得表达式%&gt; 表达式返回值不能是void类型。  </li>
<li>隐含对象（内置对象）是什么意思？有哪些隐含对象？<br>JSP隐含对象就是在编译成servlet时，servlet里产生的可以直接用的内置对象，共有九个：<br>application，request，response，session，config，page，out，pagecontext，exception。</li>
<li>面向对象软件开发的优点有哪些？<br>代码开发模块化，更易维护和修改。<br>代码复用。<br>增强代码的可靠性和灵活性。<br>增加代码的可理解性。<br>面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。  </li>
<li>封装的定义和好处有哪些？<br>封装就是将过程和数据包围起来，对数据的访问只能通过自定义的界面。封装有属性封装和方法封装，封装定义了访问这些属性和方法的范围，分别有pubilc，paivare，protected和默认的friendy。封装减少了复杂性，提高了代码的安全性.</li>
<li>多态的定义？<br>多态就是：父类对象的引用，所指对象，可以是父类的对象，也可以是子类的对象。为了实现代码复用，减少代码量。</li>
<li>继承的定义？<br>继承就是对象的新类从现有类中派生，新类拥有原始类所有特性。</li>
<li>抽象的定义？抽象和封装的不同点？<br>抽象: 抽象就是忽略一个问题中与当前目标无关的那些方面，以便更充分的注意与当前目标有关的部分，抽象不打算了解问题的全部，而是只选择其中的一个部分，抽象包括两个方面：过程抽象和数据抽象。<br>封装：就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。</li>
</ol>
<h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><ol>
<li>OSI，TCP/IP，五层协议的体系结构，以及各层协议.<br>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）  </li>
<li>IP地址的分类?<br>A类地址：以0开头，   第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；<br>B类地址：以10开头，  第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；<br>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；<br>D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）<br>E类地址：保留<br>其中A、B、C是基本类，D、E类作为多播和保留使用。<br>以下是留用的内部私有地址：<br>A类 10.0.0.0–10.255.255.255<br>B类 172.16.0.0–172.31.255.255<br>C类 192.168.0.0–192.168.255.255<br>IP地址与子网掩码相与得到网络号：<br>ip       : 192.168.2.110<br>&amp;<br>Submask : 255.255.255.0<br>=<br>网络号   ：192.168.2  .0<br>注:  主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</li>
<li>巧记IP地址分类。<br>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。<br>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。<br>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。<br>D类地址(224~239)：以1110开头，保留位多播地址。<br>E类地址(240~255)：以1111开头，保留位今后使用。   </li>
<li>ARP是地址解析协议，简单语言解释一下工作原理。<br>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<br>广播发送ARP请求，单播发送ARP响应。  </li>
<li>各种协议的介绍。<br>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术。<br>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。  </li>
<li>描述RARP协议。<br>RARP，逆地址解析协议，其作用是完成MAC地址到IP地址的映射，主要用于无盘工作站，因为为无盘工作站配置对额IP地址无法保存。其工作流程是：在网络中建立一个ARAP服务器，用于保存MAC地址和IP地址的映射关系。当无盘工作站启动后，其会封装一个ARAP数据包，其中尤其MAC地址，然后广播到网络中去，当服务器接收到请求包，就查找对应的MAC地址对应的IP地址装入响应报文中发给请求者。因为需要广播请求报文，所以RARP只能用于具有广播能力的网络。</li>
<li><p>TCP三次握手和四次挥手的全过程？  </p>
<ol>
<li><p>三次握手：  </p>
<ol>
<li>客户端发送SYN请求，进入SYN_SEND状态  </li>
<li>服务端收到SYN请求，并返回一个ACK应答，并发送一个SYN其请求，服务器进入SYN_RECV状态。 </li>
<li>客户端收到服务端的SYN请求和ACK应答，发送ACK应答，客户端进入ESTABLISH状态，服务端收到应答后进入ESTABLISH。<br>如果没有收到应答，数据包都会根据TCP的重传机制进行重传。  </li>
</ol>
</li>
<li><p>四次挥手：  </p>
<ol>
<li>客户端发送FIN包，请求断开连接，客户端进入FIN_WAIT1状态  </li>
<li>服务端收到FIN包后返回应答，进入CLOSE_WAIT状态  </li>
<li>客户端收到FIN的应答后进入FIN_WAIT2状态  </li>
<li>服务端发送FIN请求包，进入LAST_ACK状态  </li>
<li>客户端收到FIN请求包后，发送应答进入TIME_WAIT状态  </li>
<li>服务器收到ACK应答后，进入close状态。  </li>
</ol>
</li>
</ol>
</li>
<li>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程。" target="_blank" rel="noopener">www.baidu.com后执行的全部过程。</a>  <ol>
<li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。</li>
<li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li>
<li>客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li>
<li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li>
</ol>
</li>
<li>TCP和UDP的区别？  <ol>
<li>TCP面向连接的运输层协议，UDP无连接</li>
<li>TCP是可靠交付，UDP是尽最大努力交付</li>
<li>TCP面向字节流，UDP面向报文</li>
<li>TCP是点对点连接的，UDP一对一，一对多，多对多都可以</li>
<li>TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。  </li>
</ol>
</li>
<li>DNS域名系统，简单描述其工作原理。<br>当一个应用进程需要把某个域名解析为IP地址时，该应用进程就会调用解析程序，并成为一个DNS用户，把待解析的域名放在DNS请求报文中，以UDP数据报的形式发送给本地域名服务器，本地域名服务器查找到相应域名的IP地址后，就将该域名的IP地址信息放入应答报文中返回给客户进程，如果本地域名服务器没有直接查找到对应的IP地址，则向根域名服务器发出迭代查询，再将查询到的IP地址信息回传给客户程序。</li>
<li>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？<br>A：喂，听到吗？ B：能听到，你呢？A：….B：…</li>
</ol>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><ol>
<li>操作系统的五大管理功能:<br>（1）作业管理：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等；<br>（2）文件管理：又称为信息管理；<br>（3）存储管理：实质是对存储“空间”的管理，主要指对主存的管理；<br>（4）设备管理：实质是对硬件设备的管理，其中包括对输入输出设备的分配、启动、完成和回收；<br>（5）进程管理：实质上是对处理机执行“时间”的管理，即如何将CPU真正合理地分配给每个任务。 </li>
<li>cpu工作状态分为系统态（或称管理态，管态）和用户态（或称目态）。 引入这两个工作状态的原因是：为了避免用户程序错误地使用特权指令，保护操作系统不被用户程序破坏。具体规定为：当cpu处于用户态时，不允许执行特权指令，当cpu处于系统态时，可执行包括特权指令在内的一切机器指令。</li>
<li>98或 xp 都可以有多个用户帐号密码，但请注意多用户是指多个用户同时操作。而98和 XP 在同一时间只能使用一个用户，所以包括 XP 在内，都只是单用户多任务的。</li>
<li>操作系统有四个明显的特征：并发性，共享性，虚拟性以及不确定性。</li>
<li>CPU要完成一组I/O操作，只需要向I/O通道发送一条I/O指令，通道接到指令，通过执行通道程序，并且与设备控制器一起共同来实现对I/O设备的控制和操作。</li>
<li>分时系统具有多路性、交互性、“独占”性和及时性的特征。</li>
<li>并发和共享是操作系统的两个最基本的特性，它们又是互为存在条件。一方面资源共享是以程序（进程）的并发性执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题。另一方面若系统不能对资源共享实施有效管理，则也必将影响到程序并发执行。</li>
<li>系统调用提供了用户程序和操作系统之间的接口。</li>
<li>多道程序系统的运行必须要依赖通道和中断硬件机构的支持。</li>
<li>系统态，即内核态，三种情况下会出现由用户态转为内核态，中断，异常，系统调用。</li>
<li>单道批处理并不会因为你请求了我就准备响应你，我的响应不是你的请求决定的，而是取决于我执行完上一个没有，多道批处理是我空出CPU了你就可以进来执行，取决于什么时候空出来，这两个都没有一个时间标准，不确定什么时候响应，，时间间隔的标准要求在一定时间内必须响应，不管你做没做完。</li>
<li>批处理不能处理需要交互类型的作业啊。</li>
<li>多道操作系统特意准备：特权指令（多道优先级）跳转指令（程序跳转）。如果不是多道的操作系统，也就是单任务处理的，那么一个一个的执行就好了，当出现多道的时候，就会出现优先级的问题，因此特权指令是为了提供在优先级不同的条件下，用户状态的切换，跳转指令就是从我们的程序跳转到另一个了，可能会感觉时钟会有用，给每一个程序分配一定的时间，让其运行，但是这个并不是必须的，因为可以根据优先级来采取抢占式的执行，所以时钟不是特别提供的，特权指令和跳转指令在单道批处理下是不能够起到作用的</li>
<li>独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。<br>共享设备：多个用户作业或多个进程可以“同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。<br>虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。  </li>
<li>进程的模式有系统态和用户态 两种，一般用户编写的程序是在用户态下工作，当程序中有中断或者调用系统函数 时，会切换到系统态下运行。</li>
<li>分时操作系统 ，主要分为三类：单道分时操作系统，多道分时操作系统，具有前台和后台的分时操作系统。</li>
<li>实时系统应具有的两个基本特征是( 及时)和( 可靠)。</li>
<li>批处理操作系统的主要缺点是缺少交互性。</li>
<li>操作系统的三种基本类型是：批处理操作系统,分时操作系统,实时操作系统。</li>
<li>从用户的观点出发，操作系统是用户和计算机之间的接口有命令接口,程序接口,图形接口三种。</li>
<li>操作系统中采用多道程序设计技术后，提高了CPU和外部设备的利用率。</li>
<li>操作系统的特征是并发性,共享性,虚拟性,异步性。</li>
<li>操作系统目前有五大类型：批处理操作系统,分时操作系统,实时操作系统,网络操作系统,分布式操作系统。</li>
<li>dos是磁盘操作系统的缩写。</li>
<li>计算机操作命令可分为联机命令,shell程序语言命令,脱机作业控制语言命令。</li>
<li>操作系统的目标是方便性,有效性,可扩充性,开放性。</li>
<li>系统调用和一般用户函数调用的区别？<br>在操作系统中，系统调用程序在系统态执行；一般用户函数调用程序由用户准备，在用户态执行。</li>
<li>一般用户最常用的操作系统接口是什么接口？<br>一般用户最常用的操作系统与用户的接口是控制接口。用户使用这个接口控制、管理和操作计算机系统，利用它控制程序的执行。控制接口分为脱机接连、命令接口、图形接口、多媒体接口。</li>
<li>过程调用和系统调用的共同点是什么，它们与中断调用的差别是什么？<br>过程调用和系统调用的执行完全是同步的，也就是在相同的数据集上重复执行，它们的调用点是相同的，都需要保存现场信息，转去执行另外的程序，执行后返回。中断调用是异步的，在相同的数据集上重复执行，中断的发生点可以是不同的。 </li>
<li>分时系统的响应时间受哪些因素的影响？<br>分时系统的相应时间是指用户从终端发出一个命令到系统处理完这个命令并做出回答所需要的时间。这个时间受时间片长度、终端用户个数、命令本身功能、硬件特性、主存与辅存的交换速度等影响。</li>
<li>实时系统和分时系统的主要区别有两点：（1）分时系统的目标是提供一种通用性很强的系统，有较强的交互能力；而实时系统则大都是具有特殊用途的专用系统，交互能力略差。（2）分时系统对响应时间虽有要求，但一般来说，响应时间由人所能承受的等待时间来确定；而实时系统对响应时间要求很高，一般由控制系统或信息处理磁头所能接受的延迟时间来决定。</li>
<li>为什么中断机构对于多道操作系统是必不可少的？<br>很多进程的切换是由中断引起的，如时钟中断，尤其是分时系统。用户程序进行系统调用时通过软中断来实现，如TRAP。通道和外设的操作也要向操作系统发送中断。</li>
<li>网络操作系统和分布式操作系统的区别？<br>网络OS中的用户使用自己的机器可以访问网络上别的机器的资源，通过网络将很多机器连接起来，共享硬件资源，但是，整个系统对用户来说是分散的，不透明的。分布式OS的用户也是通过网络将多台机器连接起来，但是整个系统对用户是透明的，用户对整个OS就好像使用一个自己的机器一样。</li>
<li>简述操作系统的定义。<br>操作系统是计算机系统的一种系统软件，它统一管理计算机系统的资源和控制程序的执行。</li>
<li>作业在系统中有哪几种状态？<br>一个作业进入系统到运行结束，一般要经历进入、后备、运行和完成四个阶段，相应地，作业亦有进入、后备、运行和完成四种状态。① 进入状态：作业的信息从输入设备上预输入到输入井，此时称为作业处于进入状态。② 后备状态：当作业的全部信息都已输入，且由操作系统将其存放在输入井中，此时称作业处于后备状态。系统将所有处于后备状态的作业组成后备作业队列，等待作业调度程序的调度。③ 运行状态：一个后备作业被作业调度程序选中，分配了必要的资源，调入内存运行，称作业处于运行状态。④ 完成状态：当作业正常运行完毕或因发生错误非正常终止时，作业进入这完成状态。</li>
<li>中断装置的职能主要有三点：① 检查是否有中断事件发生；② 若有中断发生，保护好被中断进程的断点及现场信息，以便进程在适当时候能恢复执行；③ 启动操作系统的中断处理程序。</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="William Sun 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="William Sun 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/秋招/" rel="tag"># 秋招</a>
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/12/macOS下安装及卸载MySQL/" rel="next" title="macOS下安装及卸载MySQL">
                <i class="fa fa-chevron-left"></i> macOS下安装及卸载MySQL
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/20/Git删除远程仓库文件夹或文件的方法/" rel="prev" title="Git删除远程仓库文件夹或文件的方法">
                Git删除远程仓库文件夹或文件的方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MTE2NC8xNzcxMg=="></div>
    </div>

  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="William Sun">
            
              <p class="site-author-name" itemprop="name">William Sun</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/William0617" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:william.sun@pku.edu.cn" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-envelope"></i>Email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="undefined" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-globe"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="undefined" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-text">Java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Networks"><span class="nav-text">Networks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS"><span class="nav-text">OS</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William Sun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
