<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,source code,">










<meta name="description" content="package java.util; import sun.misc.SharedSecrets; import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**  概述： List接口可调整大小的数组实现。实现所有可选的List操">
<meta name="keywords" content="java,source code">
<meta property="og:type" content="article">
<meta property="og:title" content="ArrayList源码分析">
<meta property="og:url" content="http://yoursite.com/2018/09/02/ArrayList源码分析/index.html">
<meta property="og:site_name" content="William&#39;s Blog">
<meta property="og:description" content="package java.util; import sun.misc.SharedSecrets; import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**  概述： List接口可调整大小的数组实现。实现所有可选的List操">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-18T20:35:42.140Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayList源码分析">
<meta name="twitter:description" content="package java.util; import sun.misc.SharedSecrets; import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**  概述： List接口可调整大小的数组实现。实现所有可选的List操">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/02/ArrayList源码分析/">





  <title>ArrayList源码分析 | William's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">William's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/ArrayList源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="William's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ArrayList源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T12:41:00-04:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Development/" itemprop="url" rel="index">
                    <span itemprop="name">Development</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Development/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><pre><code><br>package java.util;</code></pre></p>
<p>import sun.misc.SharedSecrets;</p>
<p>import java.util.function.Consumer;<br>import java.util.function.Predicate;<br>import java.util.function.UnaryOperator;</p>
<p>/**</p>
<ul>
<li>概述：</li>
<li>List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。</li>
<li>除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。</li>
<li>时间复杂度：</li>
<li>方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。</li>
<li>添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。</li>
<li>容量：</li>
<li>每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。</li>
<li>容量可以自动增长。</li>
<li>如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。</li>
<li>也可以通过带初始容量的构造器初始化这个容量。</li>
<li>线程不安全：</li>
<li>ArrayList不是线程安全的。</li>
<li>如果需要应用到多线程中，需要在外部做同步</li>
<li>modCount：</li>
<li>定义在AbstractList中：protected transient int modCount = 0;</li>
<li>已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。</li>
<li>此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。</li>
<li>如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。</li>
<li>在迭代期间面临并发修改时，它提供了快速失败 行为，而不是非确定性行为。</li>
<li>子类是否使用此字段是可选的。</li>
<li>如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。</li>
<li>对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 concurrentmodificationexceptions。</li>
<li>如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。</li>
<li>transient：</li>
<li>默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8)<br>*/</li>
</ul>
<p>public class ArrayList<e> extends AbstractList<e><br>        implements List<e>, RandomAccess, Cloneable, java.io.Serializable {<br>    private static final long serialVersionUID = 8683452581122892189L;</e></e></e></p>
<pre><code>/**
 * 默认容量
 */
private static final int DEFAULT_CAPACITY = 10;

/**
 * 空的对象数组
 */
private static final Object[] EMPTY_ELEMENTDATA = {};

/**
 * 默认的空数组
 * 无参构造函数创建的数组
 */
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
 * 存放数据的数组的缓存变量，不可序列化
 */
transient Object[] elementData;

/**
 * 元素数量
 *
 * @serial
 */
private int size;

/**
 * 带有容量initialCapacity的构造方法
 *
 * @param 初始容量列表的初始容量
 * @throws IllegalArgumentException 如果指定容量为负
 */
public ArrayList(int initialCapacity) {
    // 如果初始化时ArrayList大小大于0
    if (initialCapacity &gt; 0) {
        // new一个该大小的object数组赋给elementData
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {// 如果大小为0
        // 将空数组赋给elementData
        this.elementData = EMPTY_ELEMENTDATA;
    } else {// 小于0
        // 则抛出IllegalArgumentException异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; +
                initialCapacity);
    }
}

/**
 * 不带参数的构造方法
 */
public ArrayList() {
    // 直接将空数组赋给elementData
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

/**
 * 带参数Collection的构造方法
 *
 * @param c 其元素将被放入此列表中的集合
 * @throws NullPointerException 如果指定的集合是空的
 */
public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toarray可能（错误地）不返回对象[]（见JAVA BUG编号6260652）
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // 使用空数组
        this.elementData = EMPTY_ELEMENTDATA;
    }
}

/**
 * 因为容量常常会大于实际元素的数量。内存紧张时，可以调用该方法删除预留的位置，调整容量为元素实际数量。
 * 如果确定不会再有元素添加进来时也可以调用该方法来节约空间
 */
public void trimToSize() {
    modCount++;
    // 如果size小于length
    if (size &lt; elementData.length) {
        // 重新将elementData设置大小为size
        elementData = (size == 0)
                ? EMPTY_ELEMENTDATA
                : Arrays.copyOf(elementData, size);
    }
}

/**
 * 使用指定参数设置数组容量
 *
 * @param minCapacity 所需的最小容量
 */
public void ensureCapacity(int minCapacity) {
    //如果数组为空，容量预取0，否则去默认值(10)
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It&apos;s already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;
    //若参数大于预设的容量，在使用该参数进一步设置数组容量
    if (minCapacity &gt; minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}

private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}

/**
 * 得到最小扩容量
 *
 * @param minCapacity
 */
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

/**
 * 判断是否需要扩容
 *
 * @param minCapacity
 */
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 如果最小需要空间比elementData的内存空间要大，则需要扩容
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

/**
 * 数组的最大容量，可能会导致内存溢出(VM内存限制)
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
 * 扩容，以确保它可以至少持有由参数指定的元素的数目
 *
 * @param minCapacity 所需的最小容量
 */
private void grow(int minCapacity) {
    // 获取到ArrayList中elementData数组的内存空间长度
    int oldCapacity = elementData.length;
    // 扩容至原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组，
    // 不够就将数组长度设置为需要的长度
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    //若预设值大于默认的最大值检查是否溢出
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间
    // 并将elementData的数据复制到新的内存空间
    elementData = Arrays.copyOf(elementData, newCapacity);
}

/**
 * 检查是否溢出，若没有溢出，返回最大整数值(java中的int为4字节，所以最大为0x7fffffff)或默认最大值
 *
 * @param minCapacity
 * @return
 */
private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0)   //溢出
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
}

/**
 * 返回ArrayList的大小
 *
 * @return ArrayList中的元素数量
 */
public int size() {
    return size;
}

/**
 * 返回是否为空
 *
 * @return true 如果ArrayList中无元素
 */
public boolean isEmpty() {
    return size == 0;
}

/**
 * 是否包含一个数 返回bool
 *
 * @param o 检测o是否为ArrayList中元素
 * @return true 如果ArrayList中包含o元素
 */
public boolean contains(Object o) {
    return indexOf(o) &gt;= 0;
}


/**
 * 返回一个值在数组首次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N)
 *
 * @param o
 * @return
 */
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i] == null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
 * 返回一个值在数组最后一次出现的位置，会根据是否为null使用不同方式判断。不存在就返回-1。时间复杂度为O(N)
 *
 * @param o
 * @return
 */
public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size - 1; i &gt;= 0; i--)
            if (elementData[i] == null)
                return i;
    } else {
        for (int i = size - 1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
 * 返回副本，元素本身没有被复制，复制过程数组发生改变会抛出异常
 *
 * @return v ArrayList副本
 */
public Object clone() {
    try {
        // 调用父类(翻看源码可见是Object类)的clone方法得到一个ArrayList副本
        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
        // 调用Arrays类的copyOf，将ArrayList的elementData数组赋值给副本的elementData数组
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        // 返回副本v
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn&apos;t happen, since we are Cloneable
        throw new InternalError(e);
    }
}

/**
 * 转换为Object数组，使用Arrays.copyOf()方法
 *
 * @return 一个数组包含所有列表中的元素, 且顺序正确
 */
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

/**
 * 将ArrayList里面的元素赋值到一个数组中去
 * 如果a的长度小于ArrayList的长度，直接调用Arrays类的copyOf，返回一个比a数组长度要大的新数组，里面元素就是ArrayList里面的元素；
 * 如果a的长度比ArrayList的长度大，那么就调用System.arraycopy，将ArrayList的elementData数组赋值到a数组，然后把a数组的size位置赋值为空。
 *
 * @param a 如果它的长度大的话，列表元素将存储在这个数组中; 否则，将为此分配一个相同运行时类型的新数组。
 * @return 一个包含ArrayList元素的数组
 * @throws ArrayStoreException  将与数组类型不兼容的值赋值给数组元素时抛出的异常
 * @throws NullPointerException 数组为空
 */
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;T&gt; T[] toArray(T[] a) {
    if (a.length &lt; size)
        // 创建一个新的a的运行时类型数组，内容不变
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}


/**
 * 返回指定位置的值，因为是数组，所以速度特别快
 *
 * @param index
 * @return
 */
@SuppressWarnings(&quot;unchecked&quot;)
E elementData(int index) {
    return (E) elementData[index];
}

/**
 * 返回指定位置的值，但是会先检查这个位置数否超出数组长度
 *
 * @param index 要返回的元素的索引
 * @return ArrayList中指定位置的元素
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    // 检查是否越界
    rangeCheck(index);
    // 返回ArrayList的elementData数组index位置的元素
    return elementData(index);
}

/**
 * 设置指定位置为一个新值，并返回之前的值，会检查这个位置是否超出数组长度
 *
 * @param index   要替换的元素的索引
 * @param element 要存储在指定位置的元素
 * @return 之前在指定位置的元素
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E set(int index, E element) {
    // 检查是否越界
    rangeCheck(index);
    // 调用elementData(index)获取到当前位置的值
    E oldValue = elementData(index);
    // 将element赋值到ArrayList的elementData数组的第index位置
    elementData[index] = element;
    return oldValue;
}

/**
 * 添加一个值，首先会确保容量
 *
 * @param e 要添加到此列表中的元素
 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    // 扩容
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 将e赋值给elementData的size+1的位置
    elementData[size++] = e;
    return true;
}

/**
 * 在ArrayList的index位置，添加元素element，会检查添加的位置和容量
 *
 * @param index   指定元素将被插入的索引
 * @param element 要插入的元素
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public void add(int index, E element) {
    // 判断index是否越界
    rangeCheckForAdd(index);
    // 扩容
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
    //src:源数组； srcPos:源数组要复制的起始位置； dest:目的数组； destPos:目的数组放置的起始位置； length:复制的长度
    // 将elementData从index位置开始，复制到elementData的index+1开始的连续空间
    System.arraycopy(elementData, index, elementData, index + 1,
            size - index);
    // 在elementData的index位置赋值element
    elementData[index] = element;
    // ArrayList的大小加一
    size++;
}

/**
 * 在ArrayList的移除index位置的元素,会检查添加的位置，返回之前的值
 *
 * @param index 要删除的元素的索引
 * @return 从ArrayList中删除的元素
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E remove(int index) {
    // 判断是否越界
    rangeCheck(index);

    modCount++;
    // 读取旧值
    E oldValue = elementData(index);
    // 获取index位置开始到最后一个位置的个数
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间
        System.arraycopy(elementData, index + 1, elementData, index,
                numMoved);
    // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间
    elementData[--size] = null; //便于垃圾回收器回收

    return oldValue;
}

/**
 * 在ArrayList的移除对象为O的元素，跟indexOf方法思想基本一致
 *
 * @param o 要从该列表中删除的元素（如果存在）
 * @return true 如果这个列表包含指定的元素
 */
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}


/**
 * 快速删除指定位置的值，之所以叫快速，应该是不需要检查和返回值，因为只内部使用
 *
 * @param index
 */
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index + 1, elementData, index,
                numMoved);
    // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间
    elementData[--size] = null; //便于垃圾回收器回收
}

/**
 * 清空数组，把每一个值设为null,方便垃圾回收(不同于reset，数组默认大小有改变的话不会重置)
 */
public void clear() {
    modCount++;

    //便于垃圾回收器回收
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;
    //把size设置为0，以便我们不会浏览到null值的内存空间
    size = 0;
}

/**
 * 添加一个集合的元素到末端，若要添加的集合为空返回false
 *
 * @param c 包含要添加到此列表中的元素的集合
 * @return true 如果该列表因添加而改变
 * @throws NullPointerException 如果指定的集合是空的
 */
public boolean addAll(Collection&lt;? extends E&gt; c) {
    // 将c转换为数组a
    Object[] a = c.toArray();
    // 获取a占的内存空间长度赋值给numNew
    int numNew = a.length;
    // 扩容至size + numNew
    ensureCapacityInternal(size + numNew);  // Increments modCount
    // 将a的第0位开始拷贝至elementData的size位开始，拷贝长度为numNew
    System.arraycopy(a, 0, elementData, size, numNew);
    // 将size增加numNew
    size += numNew;
    // 如果c为空，返回false，c不为空，返回true
    return numNew != 0;
}

/**
 * 从第index位开始，将c全部拷贝到ArrayList,若要添加的集合为空返回false
 *
 * @param index 在哪个索引处插入指定集合中的第一个元素
 * @param c     包含要添加到此列表中的元素的集合
 * @return true 如果该列表因添加而改变
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws NullPointerException      如果指定的集合是空的
 */
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    // 判断index大于size或者是小于0,如果是，则抛出IndexOutOfBoundsException异常
    rangeCheckForAdd(index);
    // 将c转换为数组a
    Object[] a = c.toArray();
    int numNew = a.length;
    // 扩容至size + numNew
    ensureCapacityInternal(size + numNew);  // Increments modCount
    // 获取需要添加的个数
    int numMoved = size - index;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}

/**
 * 删除指定范围元素。参数为开始删的位置和结束位置
 *
 * @throws IndexOutOfBoundsException if {@code fromIndex} or
 *                                   {@code toIndex} is out of range
 *                                   ({@code fromIndex &lt; 0 ||
 *                                   fromIndex &gt;= size() ||
 *                                   toIndex &gt; size() ||
 *                                   toIndex &lt; fromIndex})
 */
protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;//后段保留的长度
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
            numMoved);

    //便于垃圾回收期回收
    int newSize = size - (toIndex - fromIndex);
    for (int i = newSize; i &lt; size; i++) {
        elementData[i] = null;
    }
    size = newSize;
}

/**
 * 检查index是否超出数组长度 用于添加元素时
 */
private void rangeCheck(int index) {
    // 如果下标超过ArrayList的数组长度
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
 * 检查是否溢出
 */
private void rangeCheckForAdd(int index) {
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
 * 抛出的异常的详情
 */
private String outOfBoundsMsg(int index) {
    return &quot;Index: &quot; + index + &quot;, Size: &quot; + size;
}

/**
 * ArrayList移除集合c中的所有元素
 *
 * @param c 包含要从此列表中移除的元素的集合
 * @return {@code true} 如果该列表因移除而改变
 * @throws ClassCastException   if the class of an element of this list
 *                              is incompatible with the specified collection
 *                              (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 * @throws NullPointerException if this list contains a null element and the
 *                              specified collection does not permit null elements
 *                              (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 *                              or if the specified collection is null
 * @see Collection#contains(Object)
 */
public boolean removeAll(Collection&lt;?&gt; c) {
    // 如果c为空，则抛出空指针异常
    Objects.requireNonNull(c);
    // 调用batchRemove移除c中的元素
    return batchRemove(c, false);
}

/**
 * 仅保留指定集合c中的元素
 *
 * @param c collection containing elements to be retained in this list
 * @return {@code true} if this list changed as a result of the call
 * @throws ClassCastException   if the class of an element of this list
 *                              is incompatible with the specified collection
 *                              (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 * @throws NullPointerException if this list contains a null element and the
 *                              specified collection does not permit null elements
 *                              (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 *                              or if the specified collection is null
 * @see Collection#contains(Object)
 */
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    // 调用batchRemove保留c中的元素
    return batchRemove(c, true);
}

/**
 * 根据complement值，将ArrayList中包含c中元素的元素删除或者保留
 *
 * @param c
 * @param complement true时从数组保留指定集合中元素的值，为false时从数组删除指定集合中元素的值。
 * @return 数组中重复的元素都会被删除(而不是仅删除一次或几次)，有任何删除操作都会返回true
 */
private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    // 定义一个w，一个r，两个同时右移
    int r = 0, w = 0;
    boolean modified = false;
    try {
        // r先右移
        for (; r &lt; size; r++)
            // 如果c中不包含elementData[r]这个元素
            if (c.contains(elementData[r]) == complement)
                // 则直接将r位置的元素赋值给w位置的元素，w自增
                elementData[w++] = elementData[r];
    } finally {
        // 防止抛出异常导致上面r的右移过程没完成
        if (r != size) {
            // 将r未右移完成的位置的元素赋值给w右边位置的元素
            System.arraycopy(elementData, r,
                    elementData, w,
                    size - r);
            // 修改w值增加size-r
            w += size - r;
        }
        // 如果有被覆盖掉的元素，则将w后面的元素都赋值为null
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;//改变的次数
            //新的大小为保留的元素的个数
            size = w;
            modified = true;
        }
    }
    return modified;
}

/**
 * 保存数组实例的状态到一个流（即序列化）。写入过程数组被更改会抛出异常
 *
 * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
 * instance is emitted (int), followed by all of its elements
 * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
 */
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    //执行默认的反序列化/序列化过程。将当前类的非静态和非瞬态字段写入此流
    s.defaultWriteObject();

    // 写入大小
    s.writeInt(size);

    // 按顺序写入所有元素
    for (int i = 0; i &lt; size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * 从流中重构ArrayList实例（即反序列化）。
 */
private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // 执行默认的序列化/反序列化过程
    s.defaultReadObject();

    // 读入数组长度
    s.readInt(); // ignored

    if (size &gt; 0) {
        // 像clone()方法 ，但根据大小而不是容量分配数组
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        //读入所有元素
        for (int i = 0; i &lt; size; i++) {
            a[i] = s.readObject();
        }
    }
}

/**
 * 返回一个从index开始的ListIterator对象
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public ListIterator&lt;E&gt; listIterator(int index) {
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);
    return new ListItr(index);
}

/**
 * 返回一个ListIterator对象，ListItr为ArrayList的一个内部类，其实现了ListIterator&lt;E&gt; 接口
 *
 * @see #listIterator(int)
 */
public ListIterator&lt;E&gt; listIterator() {
    return new ListItr(0);
}

/**
 * 返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口
 *
 * @return an iterator over the elements in this list in proper sequence
 */
public Iterator&lt;E&gt; iterator() {
    return new Itr();
}

/**
 * 通用的迭代器实现
 */
private class Itr implements Iterator&lt;E&gt; {
    int cursor;       //游标，下一个元素的索引，默认初始化为0
    int lastRet = -1; //上次访问的元素的位置
    int expectedModCount = modCount;//迭代过程不运行修改数组，否则就抛出异常

    //是否还有下一个
    public boolean hasNext() {
        return cursor != size;
    }

    //下一个元素
    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() {
        checkForComodification();//检查数组是否被修改
        int i = cursor;
        if (i &gt;= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;//向后移动游标
        return (E) elementData[lastRet = i];//设置访问的位置并返回这个值
    }

    //删除元素
    public void remove() {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();//检查数组是否被修改

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i &gt;= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size &amp;&amp; modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    //检查数组是否被修改
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}

/**
 * ListIterator迭代器实现
 */
private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    ListItr(int index) {
        super();
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor - 1;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() {
        checkForComodification();
        int i = cursor - 1;
        if (i &lt; 0)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i;
        return (E) elementData[lastRet = i];
    }

    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.set(lastRet, e);
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            ArrayList.this.add(i, e);
            cursor = i + 1;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}

/**
 * Returns a view of the portion of this list between the specified
 * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
 * {@code fromIndex} and {@code toIndex} are equal, the returned list is
 * empty.)  The returned list is backed by this list, so non-structural
 * changes in the returned list are reflected in this list, and vice-versa.
 * The returned list supports all of the optional list operations.
 * &lt;p&gt;
 * &lt;p&gt;This method eliminates the need for explicit range operations (of
 * the sort that commonly exist for arrays).  Any operation that expects
 * a list can be used as a range operation by passing a subList view
 * instead of a whole list.  For example, the following idiom
 * removes a range of elements from a list:
 * &lt;pre&gt;
 *      list.subList(from, to).clear();
 * &lt;/pre&gt;
 * Similar idioms may be constructed for {@link #indexOf(Object)} and
 * {@link #lastIndexOf(Object)}, and all of the algorithms in the
 * {@link Collections} class can be applied to a subList.
 * &lt;p&gt;
 * &lt;p&gt;The semantics of the list returned by this method become undefined if
 * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
 * any way other than via the returned list.  (Structural modifications are
 * those that change the size of this list, or otherwise perturb it in such
 * a fashion that iterations in progress may yield incorrect results.)
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws IllegalArgumentException  {@inheritDoc}
 */
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, 0, fromIndex, toIndex);
}

/**
 * 安全检查
 *
 * @param fromIndex
 * @param toIndex
 * @param size
 */
static void subListRangeCheck(int fromIndex, int toIndex, int size) {
    if (fromIndex &lt; 0)
        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
    if (toIndex &gt; size)
        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
    if (fromIndex &gt; toIndex)
        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
                &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
}

/**
 * 子数组
 */
private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {
    private final AbstractList&lt;E&gt; parent;
    private final int parentOffset;
    private final int offset;
    int size;

    SubList(AbstractList&lt;E&gt; parent,
            int offset, int fromIndex, int toIndex) {
        this.parent = parent;
        this.parentOffset = fromIndex;
        this.offset = offset + fromIndex;
        this.size = toIndex - fromIndex;
        this.modCount = ArrayList.this.modCount;
    }

    public E set(int index, E e) {
        rangeCheck(index);
        checkForComodification();
        E oldValue = ArrayList.this.elementData(offset + index);
        ArrayList.this.elementData[offset + index] = e;
        return oldValue;
    }

    public E get(int index) {
        rangeCheck(index);
        checkForComodification();
        return ArrayList.this.elementData(offset + index);
    }

    public int size() {
        checkForComodification();
        return this.size;
    }

    public void add(int index, E e) {
        rangeCheckForAdd(index);
        checkForComodification();
        parent.add(parentOffset + index, e);
        this.modCount = parent.modCount;
        this.size++;
    }

    public E remove(int index) {
        rangeCheck(index);
        checkForComodification();
        E result = parent.remove(parentOffset + index);
        this.modCount = parent.modCount;
        this.size--;
        return result;
    }

    protected void removeRange(int fromIndex, int toIndex) {
        checkForComodification();
        parent.removeRange(parentOffset + fromIndex,
                parentOffset + toIndex);
        this.modCount = parent.modCount;
        this.size -= toIndex - fromIndex;
    }

    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(this.size, c);
    }

    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        rangeCheckForAdd(index);
        int cSize = c.size();
        if (cSize == 0)
            return false;

        checkForComodification();
        parent.addAll(parentOffset + index, c);
        this.modCount = parent.modCount;
        this.size += cSize;
        return true;
    }

    public Iterator&lt;E&gt; iterator() {
        return listIterator();
    }

    public ListIterator&lt;E&gt; listIterator(final int index) {
        checkForComodification();
        rangeCheckForAdd(index);
        final int offset = this.offset;

        return new ListIterator&lt;E&gt;() {
            int cursor = index;
            int lastRet = -1;
            int expectedModCount = ArrayList.this.modCount;

            public boolean hasNext() {
                return cursor != SubList.this.size;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i &gt;= SubList.this.size)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i + 1;
                return (E) elementData[offset + (lastRet = i)];
            }

            public boolean hasPrevious() {
                return cursor != 0;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E previous() {
                checkForComodification();
                int i = cursor - 1;
                if (i &lt; 0)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i;
                return (E) elementData[offset + (lastRet = i)];
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
                Objects.requireNonNull(consumer);
                final int size = SubList.this.size;
                int i = cursor;
                if (i &gt;= size) {
                    return;
                }
                final Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length) {
                    throw new ConcurrentModificationException();
                }
                while (i != size &amp;&amp; modCount == expectedModCount) {
                    consumer.accept((E) elementData[offset + (i++)]);
                }
                // update once at end of iteration to reduce heap write traffic
                lastRet = cursor = i;
                checkForComodification();
            }

            public int nextIndex() {
                return cursor;
            }

            public int previousIndex() {
                return cursor - 1;
            }

            public void remove() {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    SubList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void set(E e) {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    ArrayList.this.set(offset + lastRet, e);
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void add(E e) {
                checkForComodification();

                try {
                    int i = cursor;
                    SubList.this.add(i, e);
                    cursor = i + 1;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            final void checkForComodification() {
                if (expectedModCount != ArrayList.this.modCount)
                    throw new ConcurrentModificationException();
            }
        };
    }

    /**
     * 返回指定范围的子数组
     *
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public List&lt;E&gt; subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, offset, fromIndex, toIndex);
    }

    private void rangeCheck(int index) {
        if (index &lt; 0 || index &gt;= this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private void rangeCheckForAdd(int index) {
        if (index &lt; 0 || index &gt; this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot; + index + &quot;, Size: &quot; + this.size;
    }

    private void checkForComodification() {
        if (ArrayList.this.modCount != this.modCount)
            throw new ConcurrentModificationException();
    }

    public Spliterator&lt;E&gt; spliterator() {
        checkForComodification();
        return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset,
                offset + this.size, this.modCount);
    }
}

@Override
public void forEach(Consumer&lt;? super E&gt; action) {
    Objects.requireNonNull(action);
    final int expectedModCount = modCount;
    @SuppressWarnings(&quot;unchecked&quot;) final E[] elementData = (E[]) this.elementData;
    final int size = this.size;
    for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        action.accept(elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
 * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
 * list.
 * &lt;p&gt;
 * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
 * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
 * Overriding implementations should document the reporting of additional
 * characteristic values.
 *
 * @return a {@code Spliterator} over the elements in this list
 * @since 1.8
 */
@Override
public Spliterator&lt;E&gt; spliterator() {
    return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);
}

/**
 * Index-based split-by-two, lazily initialized Spliterator
 */
static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; {

    /**
     * 如果ArrayLists是不可变的，或者在结构上不可变（不添加，删除等），我们可以用Arrays.spliterator实现它们的分割器。
     * 相反，我们在遍历期间检测到尽可能多的干扰而不会影响性能。
     * 我们主要依靠modCounts。这些不能保证检测到并发冲突，有时对线程内干扰过于保守，但在实践中检测到足够的问题是值得的。
     * 为了实现这一点，我们
     * （1）懒惰地初始化fence和expectedModCount，直到我们需要提交到我们正在检查的状态的最后一点;从而提高精度。
     * （这不适用于SubLists，它会使用当前非惰性值的分割符）。
     * （2）我们在forEach（对性能最敏感的方法）结束时只执行一次ConcurrentModificationException检查。
     * 当使用forEach（而不是迭代器）时，我们通常只能在行为之后检测干扰，而不是之前。
     * 进一步的CME触发检查适用于所有其他可能的违反假设的情况，例如null或过小的elementData数组，因为它的大小（）只能由于干扰而发生。
     * 这允许forEach的内循环在没有任何进一步检查的情况下运行，并且简化了lambda分辨率。虽然这需要进行多次检查，但请注意，在list.stream（）。
     * forEach（a）的常见情况中，除forEach本身之外，不会执行任何检查或其他计算。其他较少使用的方法无法利用这些优化的大部分优势。
     */

    private final ArrayList&lt;E&gt; list;
    private int index; // current index, modified on advance/split
    private int fence; // -1 until used; then one past last index
    private int expectedModCount; // initialized when fence set

    /**
     * Create new spliterator covering the given  range
     */
    ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence,
                         int expectedModCount) {
        this.list = list; // OK if null unless traversed
        this.index = origin;
        this.fence = fence;
        this.expectedModCount = expectedModCount;
    }

    private int getFence() { // initialize fence to size on first use
        int hi; // (a specialized variant appears in method forEach)
        ArrayList&lt;E&gt; lst;
        if ((hi = fence) &lt; 0) {
            if ((lst = list) == null)
                hi = fence = 0;
            else {
                expectedModCount = lst.modCount;
                hi = fence = lst.size;
            }
        }
        return hi;
    }

    public ArrayListSpliterator&lt;E&gt; trySplit() {
        int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
        return (lo &gt;= mid) ? null : // divide range in half unless too small
                new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,
                        expectedModCount);
    }

    public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
        if (action == null)
            throw new NullPointerException();
        int hi = getFence(), i = index;
        if (i &lt; hi) {
            index = i + 1;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) list.elementData[i];
            action.accept(e);
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            return true;
        }
        return false;
    }

    public void forEachRemaining(Consumer&lt;? super E&gt; action) {
        int i, hi, mc; // hoist accesses and checks from loop
        ArrayList&lt;E&gt; lst;
        Object[] a;
        if (action == null)
            throw new NullPointerException();
        if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) {
            if ((hi = fence) &lt; 0) {
                mc = lst.modCount;
                hi = lst.size;
            } else
                mc = expectedModCount;
            if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
                for (; i &lt; hi; ++i) {
                    @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
                    action.accept(e);
                }
                if (lst.modCount == mc)
                    return;
            }
        }
        throw new ConcurrentModificationException();
    }

    public long estimateSize() {
        return (long) (getFence() - index);
    }

    public int characteristics() {
        return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
    }
}

@Override
public boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    // figure out which elements are to be removed
    // any exception thrown from the filter predicate at this stage
    // will leave the collection unmodified
    int removeCount = 0;
    final BitSet removeSet = new BitSet(size);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i];
        if (filter.test(element)) {
            removeSet.set(i);
            removeCount++;
        }
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }

    // shift surviving elements left over the spaces left by removed elements
    final boolean anyToRemove = removeCount &gt; 0;
    if (anyToRemove) {
        final int newSize = size - removeCount;
        for (int i = 0, j = 0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
            i = removeSet.nextClearBit(i);
            elementData[j] = elementData[i];
        }
        for (int k = newSize; k &lt; size; k++) {
            elementData[k] = null;  // Let gc do its work
        }
        this.size = newSize;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    return anyToRemove;
}

@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        elementData[i] = operator.apply((E) elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}

@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void sort(Comparator&lt;? super E&gt; c) {
    final int expectedModCount = modCount;
    Arrays.sort((E[]) elementData, 0, size, c);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
</code></pre><p>}</p>
<p></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="William Sun 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="William Sun 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/source-code/" rel="tag"># source code</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/14/java对象排序-Comparator和Comparable/" rel="next" title="java对象排序-Comparator和Comparable">
                <i class="fa fa-chevron-left"></i> java对象排序-Comparator和Comparable
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="William Sun">
            
              <p class="site-author-name" itemprop="name">William Sun</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/William0617" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:william.sun@pku.edu.cn" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-envelope"></i>Email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/wenliangsun0_0/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/william0617" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William Sun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
